#+title: dogen.text
#+options: <:nil c:nil todo:nil ^:nil d:nil date:nil author:nil
#+tags: { element(e) attribute(a) module(m) }
:PROPERTIES:
:masd.codec.dia.comment: true
:masd.codec.model_modules: dogen.text
:masd.codec.reference: cpp.builtins
:masd.codec.reference: cpp.boost
:masd.codec.reference: cpp.std
:masd.codec.reference: dogen
:masd.codec.reference: dogen.variability
:masd.codec.reference: dogen.tracing
:masd.codec.reference: dogen.logical
:masd.codec.reference: masd
:masd.codec.reference: masd.variability
:masd.codec.reference: dogen.profiles
:masd.codec.input_technical_space: cpp
:masd.variability.profile: dogen.profiles.base.default_profile
:END:

Contains all of the M2T transforms for all supported backendsUML Representation of model:

UML representation:

\image html dogen.text/modeling/dogen.text.svg

* registrar                                                         :element:
  :PROPERTIES:
  :custom_id: B931722F-9408-EA74-F5BB-64E6EB2630ED
  :masd.codec.stereotypes: masd::serialization::type_registrar
  :END:

* main                                                              :element:
  :PROPERTIES:
  :custom_id: 27A3ADDB-879C-4C64-3C23-231434FDFC7E
  :masd.codec.stereotypes: masd::entry_point, dogen::untypable
  :END:

* CMakeLists                                                        :element:
  :PROPERTIES:
  :custom_id: 2A3A366E-D7ED-D9D4-FF53-5D74147084CD
  :masd.codec.stereotypes: masd::build::cmakelists, dogen::handcrafted::cmake
  :END:

* cpp artefact transform implementation                             :element:
  :PROPERTIES:
  :custom_id: 69B1F93C-7797-4824-0F5B-C27E74F0AC5F
  :masd.codec.stereotypes: masd::templating::logic_less_templates
  :END:

** content                                                        :attribute:

#+begin_src mustache
namespace {

const std::string transform_id("{{containing_namespace}}.{{archetype.simple_name}}_transform");

using namespace dogen::utility::log;
auto lg(logger_factory(transform_id));

}

const physical::entities::archetype& {{archetype.simple_name}}_transform::static_archetype() {
    static auto r({{archetype.simple_name}}_factory::make());
    return r;
}

const physical::entities::archetype& {{archetype.simple_name}}_transform::archetype() const {
    return static_archetype();
}
#+end_src

* initializer                                                       :element:
  :PROPERTIES:
  :custom_id: 86D0154D-1617-1904-67FB-66E56D675115
  :masd.codec.stereotypes: dogen::handcrafted::typeable
  :END:

* csharp transform implementation                                   :element:
  :PROPERTIES:
  :custom_id: D2373040-518D-1DA4-280B-BF11A66A7C9A
  :masd.codec.stereotypes: masd::templating::logic_less_templates
  :END:

** content                                                        :attribute:

#+begin_src mustache
namespace {

const std::string transform_id("{{containing_namespace}}.{{archetype.simple_name}}_transform");

using namespace dogen::utility::log;
auto lg(logger_factory(transform_id));

}

const physical::entities::archetype& {{archetype.simple_name}}_transform::static_archetype() {
    static auto r({{archetype.simple_name}}_factory::make());
    return r;
}

const physical::entities::archetype& {{archetype.simple_name}}_transform::archetype() const {
    return static_archetype();
}
#+end_src

* csharp helper transform implementation                            :element:
  :PROPERTIES:
  :custom_id: F855285A-0001-6A44-2123-B91BE996FEBE
  :masd.codec.stereotypes: masd::templating::logic_less_templates
  :END:

** content                                                        :attribute:

#+begin_src mustache
std::string {{class.simple_name}}::id() const {
    static auto r(std::string("<{{facet.qualified_name}}>") +
        std::string("<") + helper_name() + std::string(">"));
    return r;
}

std::string {{class.simple_name}}::family() const {
    static std::string r("{{helper.family}}");
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_formatters() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}.class",
        "{{facet.qualified_name}}.primitive"
    });
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_facets() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}"
    });
    return r;
}

std::string {{class.simple_name}}::helper_name() const {
    static std::string r("{{class.simple_name}}");
    return r;
}

bool {{class.simple_name}}::is_enabled(
    const physical::entities::model& /*m*/,
    const logical::entities::element& /*e*/,
    const physical::entities::artefact& /*a*/,
    const logical::entities::helper_properties& /*hp*/) const {
    return true;
}
#+end_src

* cpp helper transform implementation                               :element:
  :PROPERTIES:
  :custom_id: B5BD06E8-C37C-34F4-6D63-8AD4CF884C39
  :masd.codec.stereotypes: masd::templating::logic_less_templates
  :END:

** content                                                        :attribute:

#+begin_src mustache
std::string {{class.simple_name}}::id() const {
    static auto r(std::string("<{{facet.qualified_name}}>") +
        std::string("<") + helper_name() + std::string(">"));
    return r;
}

std::string {{class.simple_name}}::family() const {
    static std::string r("{{helper.family}}");
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_formatters() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}.class_implementation",
        "{{facet.qualified_name}}.primitive_implementation",
        "masd.cpp.types.class_implementation",
        "masd.cpp.types.primitive_implementation"
    });
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_facets() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}", "masd.cpp.types"
    });
    return r;
}

std::string {{class.simple_name}}::helper_name() const {
    static std::string r("{{class.simple_name}}");
    return r;
}

bool {{class.simple_name}}::is_enabled(
    const physical::entities::model& m,
    const logical::entities::element& e,
    const physical::entities::artefact& a,
    const logical::entities::helper_properties& hp) const {
    return is_streaming_enabled(m, e, a, hp);
}
#+end_src

* cpp helper transform implementation enabled                       :element:
  :PROPERTIES:
  :custom_id: 727646BA-EF4A-0124-F883-58BAFC755ED3
  :masd.codec.stereotypes: masd::templating::logic_less_templates
  :END:

** content                                                        :attribute:

#+begin_src mustache
std::string {{class.simple_name}}::id() const {
    static auto r(std::string("<{{facet.qualified_name}}>") +
        std::string("<") + helper_name() + std::string(">"));
    return r;
}

std::string {{class.simple_name}}::family() const {
    static std::string r("{{helper.family}}");
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_formatters() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}.class_implementation",
        "{{facet.qualified_name}}.primitive_implementation"
    });
    return r;
}

std::list<std::string>
{{class.simple_name}}::owning_facets() const {
    static auto r(std::list<std::string> {
        "{{facet.qualified_name}}"
    });
    return r;
}

std::string {{class.simple_name}}::helper_name() const {
    static std::string r("{{class.simple_name}}");
    return r;
}

bool {{class.simple_name}}::is_enabled(
    const physical::entities::model& /*m*/,
    const logical::entities::element& /*e*/,
    const physical::entities::artefact& /*a*/,
    const logical::entities::helper_properties& /*hp*/) const {
    return true;
}
#+end_src

* entities                                                           :module:
  :PROPERTIES:
  :custom_id: 36D1B683-1A24-BF14-C2EB-2AEAC89565AB
  :END:

** Provenance                                                       :element:
   :PROPERTIES:
   :custom_id: D438AC49-0057-2C24-E353-90E04F9456A7
   :masd.codec.stereotypes: masd::object_template
   :END:

Details of the origin of this model element.

*** provenance                                                    :attribute:
    :PROPERTIES:
    :masd.codec.type: identification::entities::logical_provenance
    :END:

Details of the provenance of this model element.

** model set                                                        :element:
   :PROPERTIES:
   :custom_id: 22914D01-5045-3D14-9643-10BA74314A83
   :masd.codec.stereotypes: Provenance
   :masd.codec.plantuml: model_set o-- model
   :END:

Represents a set of related models.

*** models                                                        :attribute:
    :PROPERTIES:
    :masd.codec.type: std::list<model>
    :END:

Models that belong to this set.

** model                                                            :element:
   :PROPERTIES:
   :custom_id: A9F38CAA-8733-A584-323B-92F41830B694
   :masd.codec.stereotypes: Provenance
   :masd.codec.plantuml: model_set o-- logical_physical_region
   :END:

Represents the combined logical-physical space.

*** logical                                                       :attribute:
    :PROPERTIES:
    :masd.codec.type: logical::entities::model
    :END:

The logical model representation in the logical-physical space.

*** physical                                                      :attribute:
    :PROPERTIES:
    :masd.codec.type: physical::entities::model
    :END:

The physical model representation in the logical-physical space.

*** logical physical regions                                      :attribute:
    :PROPERTIES:
    :masd.codec.type: std::list<logical_physical_region>
    :END:

Contains all of the logical-physical regions that make up the logical physical space
for this model.

** logical physical region                                          :element:
   :PROPERTIES:
   :custom_id: 8E656B50-4D25-E2B4-7BDB-9D3DC7002AC3
   :END:

Represents a region of logical-physical space with a single logical element and
its associated physical elements.

*** logical element                                               :attribute:
    :PROPERTIES:
    :masd.codec.type: boost::shared_ptr<logical::entities::element>
    :END:

Logical element that gives rise to the artefact.

*** physical region                                               :attribute:
    :PROPERTIES:
    :masd.codec.type: physical::entities::region
    :END:

Physical artefacts that will be produced from the logical element.

* transforms                                                         :module:
  :PROPERTIES:
  :custom_id: 2C620A65-7B14-C784-2ABB-C79AC07845F8
  :masd.codec.dia.comment: true
  :END:

Contains all of the text transforms available.

** model to text chain                                              :element:
   :PROPERTIES:
   :custom_id: 44E8B05B-1A6B-70F4-B80B-A37DB6139C67
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** model generation chain                                           :element:
   :PROPERTIES:
   :custom_id: 60A30502-A0C2-F284-3D63-44B52F9A75FA
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** context                                                          :element:
   :PROPERTIES:
   :custom_id: E8E177F2-3053-8104-D863-CB30D5248690
   :masd.cpp.types.class_forward_declarations.enabled: true
   :masd.codec.stereotypes: dogen::typeable, dogen::pretty_printable
   :END:

*** physical meta model                                           :attribute:
    :PROPERTIES:
    :masd.codec.type: boost::shared_ptr<physical::entities::meta_model>
    :END:

Meta-model for the physical dimension.

*** output directory path                                         :attribute:
    :PROPERTIES:
    :masd.codec.type: boost::filesystem::path
    :END:

FIXME: to be removed

*** tracer                                                        :attribute:
    :PROPERTIES:
    :masd.codec.type: boost::shared_ptr<tracing::tracer>
    :END:

*** generation timestamp                                          :attribute:
    :PROPERTIES:
    :masd.codec.type: std::string
    :END:

Human readable timestamp of when the generation took place.

** transformation error                                             :element:
   :PROPERTIES:
   :custom_id: 3946FFA4-1271-EC14-66CB-0AFA8C1AF57F
   :masd.codec.stereotypes: masd::exception
   :END:

An error occurred whilst applying a transformation.

** registrar error                                                  :element:
   :PROPERTIES:
   :custom_id: 8DC11ABB-2EC0-DAB4-369B-182164D0FCCB
   :masd.codec.stereotypes: masd::exception
   :END:

** model to text transform                                          :element:
   :PROPERTIES:
   :custom_id: E110A173-57C7-8464-5F23-772511AAC0AC
   :masd.cpp.types.class_forward_declarations.enabled: true
   :masd.codec.stereotypes: dogen::handcrafted::typeable, dogen::pretty_printable
   :END:

** helper transform                                                 :element:
   :PROPERTIES:
   :custom_id: 2D97EBB0-4AD8-B7B4-A373-D8C0FE7C9996
   :masd.cpp.types.class_forward_declarations.enabled: true
   :masd.codec.stereotypes: dogen::handcrafted::typeable, dogen::pretty_printable
   :END:

** helper chain                                                     :element:
   :PROPERTIES:
   :custom_id: 31D61356-E633-8F74-088B-17D9CFA83F03
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

*** physical model                                                :attribute:
    :PROPERTIES:
    :masd.codec.type: physical::entities::meta_model
    :END:

** helper repository                                                :element:
   :PROPERTIES:
   :custom_id: A55F68C8-4188-AE84-6AAB-31213B9D0D95
   :masd.codec.stereotypes: dogen::typeable, dogen::pretty_printable
   :END:

*** helpers by family                                             :attribute:
    :PROPERTIES:
    :masd.codec.type: std::unordered_map<std::string, std::unordered_map<identification::entities::physical_meta_id, std::list<std::shared_ptr<helper_transform>>>>
    :END:

** helper registrar                                                 :element:
   :PROPERTIES:
   :custom_id: 1F275ABE-316C-16E4-72C3-253EF9A819E3
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

*** repository                                                    :attribute:
    :PROPERTIES:
    :masd.codec.type: helper_repository
    :END:

** initializer                                                      :element:
   :PROPERTIES:
   :custom_id: 824F920A-D295-49E4-505B-B85ACA73BEC0
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** text transform repository                                        :element:
   :PROPERTIES:
   :custom_id: 2D0F012C-47A5-AEE4-20AB-677B89F5188B
   :masd.codec.stereotypes: dogen::typeable, dogen::pretty_printable
   :END:

*** model to text transforms by meta name                         :attribute:
    :PROPERTIES:
    :masd.codec.type: std::unordered_map<identification::entities::logical_meta_id, std::forward_list<std::shared_ptr<model_to_text_transform>>>
    :END:

** text transform registrar                                         :element:
   :PROPERTIES:
   :custom_id: 3D26720B-081B-12A4-80EB-C03EA15B4A50
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** cpp                                                               :module:
   :PROPERTIES:
   :custom_id: 52204566-EAB7-C774-2FBB-019FD66043AC
   :masd.codec.dia.comment: true
   :masd.physical.backend_name: cpp
   :masd.physical.directory_name: cpp
   :masd.physical.major_technical_space: cpp
   :masd.physical.technical_space: cpp
   :masd.label.test: lbl
   :masd.codec.stereotypes: masd::physical::backend
   :END:

Text transforms that implement the C++ backend.

Provides a set of M2T transforms that convert logical model elements into a
physical representation in the C++ technical space, or associated minor
technical spaces.

*** implementation                                                  :element:
    :PROPERTIES:
    :custom_id: 808B5A49-5565-F624-6D93-27D169322EC3
    :masd.codec.stereotypes: masd::physical::part
    :masd.codec.plantuml: implementation o-l- public_headers
    :END:

Contains the implementation files.

**** external modules path contribution                           :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** model modules path contribution                              :attribute:
     :PROPERTIES:
     :masd.codec.value: as_path_components
     :END:

**** facet path contribution                                      :attribute:
     :PROPERTIES:
     :masd.codec.value: as_directories
     :END:

**** requires relative path                                       :attribute:
     :PROPERTIES:
     :masd.codec.value: false
     :END:

**** directory name                                               :attribute:
     :PROPERTIES:
     :masd.codec.value: src
     :END:

*** public headers                                                  :element:
    :PROPERTIES:
    :custom_id: D35CCD39-748D-F244-910B-6E524CCFE049
    :masd.codec.stereotypes: masd::physical::part
    :masd.codec.plantuml: public_headers o-l- testing
    :END:

Contains the header files that are publicly visible.

**** external modules path contribution                           :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** model modules path contribution                              :attribute:
     :PROPERTIES:
     :masd.codec.value: as_path_components
     :END:

**** facet path contribution                                      :attribute:
     :PROPERTIES:
     :masd.codec.value: as_directories
     :END:

**** requires relative path                                       :attribute:
     :PROPERTIES:
     :masd.codec.value: true
     :END:

**** directory name                                               :attribute:
     :PROPERTIES:
     :masd.codec.value: include
     :END:

*** testing                                                         :element:
    :PROPERTIES:
    :custom_id: 72B4CD0B-94E6-4CC4-A9A3-507E19D91D39
    :masd.codec.stereotypes: masd::physical::part
    :masd.codec.plantuml: testing o-l- standard_header_file
    :END:

Contains the generated test files.

**** external modules path contribution                           :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** model modules path contribution                              :attribute:
     :PROPERTIES:
     :masd.codec.value: as_path_components
     :END:

**** facet path contribution                                      :attribute:
     :PROPERTIES:
     :masd.codec.value: as_directories
     :END:

**** requires relative path                                       :attribute:
     :PROPERTIES:
     :masd.codec.value: false
     :END:

**** directory name                                               :attribute:
     :PROPERTIES:
     :masd.codec.value: generated_tests
     :END:

*** standard header file                                            :element:
    :PROPERTIES:
    :custom_id: 6F00A72E-B1D8-BEE4-CBAB-9CB9FA7B7924
    :masd.codec.stereotypes: masd::physical::archetype_kind
    :END:

Header file generated by Dogen.

**** file extension                                               :attribute:
     :PROPERTIES:
     :masd.codec.value: hpp
     :END:

*** base archetype configuration                                    :element:
    :PROPERTIES:
    :custom_id: 6240D403-325B-67D4-694B-CA32EA24F9ED
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.technical space                                :attribute:
     :PROPERTIES:
     :masd.codec.value: cpp
     :END:

*** tests configuration                                             :element:
    :PROPERTIES:
    :custom_id: 90CDD415-C908-5764-BCD3-0C3CDD8A07E7
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::tests_configuration
    :masd.codec.parent: transforms::cpp::base_archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to most archetypes in tests.

**** masd.physical.part id                                        :attribute:
     :PROPERTIES:
     :masd.codec.value: masd.cpp.testing
     :END:

**** masd.physical.wale template reference                        :attribute:
     :PROPERTIES:
     :masd.codec.value: cpp_artefact_transform_implementation
     :END:

**** masd.physical.relation status                                :attribute:
     :PROPERTIES:
     :masd.codec.value: not_relatable
     :END:

*** header configuration                                            :element:
    :PROPERTIES:
    :custom_id: 5D3B8AF4-A3A7-3854-C183-5B64D55E1E28
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::header_configuration
    :masd.codec.parent: transforms::cpp::base_archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all c++ header archetypes.

**** masd.physical.part id                                        :attribute:
     :PROPERTIES:
     :masd.codec.value: masd.cpp.public_headers
     :END:

**** masd.physical.wale template reference                        :attribute:
     :PROPERTIES:
     :masd.codec.value: cpp_artefact_transform_implementation
     :END:

*** header facet default configuration                              :element:
    :PROPERTIES:
    :custom_id: 7BED6243-7757-4E34-463B-57092DAFF312
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::header_facet_default_configuration
    :masd.codec.parent: transforms::cpp::header_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

**** masd.physical.relation status                                :attribute:
     :PROPERTIES:
     :masd.codec.value: facet_default
     :END:

*** enumeration header configuration                                :element:
    :PROPERTIES:
    :custom_id: 2DDA0542-CC0B-1714-9A2B-9C115255550C
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::enumeration_header_configuration
    :masd.codec.parent: transforms::cpp::header_facet_default_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all enumeration header archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.enumeration
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: enum_header
     :END:

*** object header configuration                                     :element:
    :PROPERTIES:
    :custom_id: 4C80276B-358A-02F4-F0A3-351A369624A1
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::object_header_configuration
    :masd.codec.parent: transforms::cpp::header_facet_default_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all object header archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.object
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: class_header
     :END:

*** primitive header configuration                                  :element:
    :PROPERTIES:
    :custom_id: 9D9FC9B2-0956-16A4-299B-59BA84C8579C
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::primitive_header_configuration
    :masd.codec.parent: transforms::cpp::header_facet_default_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all built header archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.primitive
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: primitive_header
     :END:

*** builtin header configuration                                    :element:
    :PROPERTIES:
    :custom_id: 187B79A3-BAFA-38E4-844B-077BCE5602FE
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::builtin_header_configuration
    :masd.codec.parent: transforms::cpp::header_facet_default_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all built header archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.builtin
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: builtin_header
     :END:

*** implementation configuration                                    :element:
    :PROPERTIES:
    :custom_id: EB745EB4-EBAD-17F4-C05B-4C9C7AE8FABE
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::implementation_configuration
    :masd.codec.parent: transforms::cpp::base_archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all c++ implementation archetypes.

**** masd.physical.part id                                        :attribute:
     :PROPERTIES:
     :masd.codec.value: masd.cpp.implementation
     :END:

**** masd.physical.wale template reference                        :attribute:
     :PROPERTIES:
     :masd.codec.value: cpp_artefact_transform_implementation
     :END:

**** masd.physical.relation status                                :attribute:
     :PROPERTIES:
     :masd.codec.value: not_relatable
     :END:

*** object implementation configuration                             :element:
    :PROPERTIES:
    :custom_id: 697F947B-CC1F-3124-176B-2DFC1B465535
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::object_implementation_configuration
    :masd.codec.parent: transforms::cpp::implementation_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.object
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: class_implementation
     :END:

*** primitive implementation configuration                          :element:
    :PROPERTIES:
    :custom_id: 276ACF17-F7D2-5C04-986B-585EF678F74E
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::primitive_implementation_configuration
    :masd.codec.parent: transforms::cpp::implementation_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.primitive
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: primitive_implementation
     :END:

*** enumeration implementation configuration                        :element:
    :PROPERTIES:
    :custom_id: A9DC0438-815E-C2F4-A303-5AEB66F75A79
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::enumeration_implementation_configuration
    :masd.codec.parent: transforms::cpp::implementation_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.enumeration
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: enum_implementation
     :END:

*** types                                                            :module:
    :PROPERTIES:
    :custom_id: 05FE5231-1263-E074-E5C3-EAE33E60D1AB
    :masd.codec.dia.comment: true
    :masd.label.test: some_label
    :masd.physical.directory_name: types
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the types facet of the
C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 488D3D4B-D645-10A4-93C3-09C03675F34B
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :masd.codec.plantuml: initializer o-d- smart_pointer_helper
     :END:

**** smart pointer helper                                           :element:
     :PROPERTIES:
     :custom_id: 4AC35697-70C5-9304-7473-674F9F15D3A5
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: smart_pointer_helper_transform
     :masd.wale.kvp.helper.family: SmartPointer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.types
     :masd.physical.helpers.family: SmartPointer
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :masd.codec.plantuml: smart_pointer_helper o-d- archetype_class_header_transform
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/smart_pointer_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto qn(d.name_tree_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
#>

inline bool operator==(const <#= qn #>& lhs,
const <#= qn #>& rhs) {
    return (!lhs && !rhs) ||(lhs && rhs && (*lhs == *rhs));
}

<#+
    }
#>

<#+
}

#>
#+end_src

**** archetype class header transform                               :element:
     :PROPERTIES:
     :custom_id: 004CF3C5-2072-F424-5C0B-88577F905525
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
     :masd.wale.kvp.archetype.simple_name: archetype_class_header_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.constant_relation: dogen.text.transforms.model_to_text_transform,archetype:masd.cpp.types.class_header,technical_space:cpp
     :masd.physical.constant_relation: dogen.text.csharp.transforms.model_to_text_transform,archetype:masd.cpp.types.class_header,technical_space:csharp
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :masd.codec.plantuml: archetype_class_header_transform o-d- archetype_class_implementation_transform
     :END:

Generates header files for archetypes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_header_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_class_header_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types archetype class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple() + "_transform");
#>

class <#= sn #> final : public text::transforms::model_to_text_transform {
public:
    static const physical::entities::archetype& static_archetype();
    const physical::entities::archetype& archetype() const override;

public:
void apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e,
    physical::entities::artefact& a) const override;
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>
#+end_src

**** archetype class implementation transform                       :element:
     :PROPERTIES:
     :custom_id: 244D38AF-20E7-6FD4-B733-4EF7F4BDEB77
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
     :masd.wale.kvp.archetype.simple_name: archetype_class_implementation_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :masd.codec.plantuml: archetype_class_implementation_transform o-d- archetype_class_header_factory
     :END:

Generates implementation files for archetypes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_implementation_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_class_implementation_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& arch(ast.as<logical::entities::physical::archetype>(e));
    ast.update_artefact();
    a.content(arch.text_templating().rendered_stitch_template());
    stp.end_transform(a);
}

#>
#+end_src

**** archetype class header factory                                 :element:
     :PROPERTIES:
     :custom_id: 55EE1113-09CE-2FA4-61D3-6559A9E7822F
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
     :masd.wale.kvp.archetype.simple_name: archetype_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.relation_status: relatable
     :masd.label.role: type_declaration
     :masd.physical.constant_relation: dogen.physical.entities.archetype,archetype:masd.cpp.types.class_header
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :masd.codec.plantuml: archetype_class_header_factory o-d- archetype_class_implementation_factory
     :END:

Generates header files for archetype factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types archetype class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the archetype
 * <#= o.name().simple() #>.
 *
 * Archetype documentation: <#= o.documentation() #>
 */
class <#= o.name().simple() #>_factory final {
public:
    /**
     * @brief Makes the archetype.
     */
    static physical::entities::archetype make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>
#+end_src

**** archetype class implementation factory                         :element:
     :PROPERTIES:
     :custom_id: 8C9F759C-B8B5-4454-B9F3-F41A9D0281F0
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype
     :masd.wale.kvp.archetype.simple_name: archetype_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.constant_relation: dogen.physical.helpers.meta_name_factory,archetype:masd.cpp.types.class_header
     :masd.physical.variable_relation: self,archetype:masd.cpp.types.archetype_class_header_factory
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :masd.codec.plantuml: archetype_class_implementation_factory  o-d- facet_class_header_transform
     :END:

Generates implementation files for archetype factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& arch(ast.as<logical::entities::physical::archetype>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(arch));
        {
            const auto ns(ast.make_namespaces(arch.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(arch.name().simple() + "_factory");
#>

physical::entities::archetype <#= sn #>::make() {
    physical::entities::archetype r;
    using pmnf = identification::helpers::physical_meta_name_factory;
    r.meta_name(pmnf::make("<#= arch.backend_name() #>", "<#= arch.facet_name() #>", "<#= arch.name().simple() #>"));
    r.logical_meta_element_id(identification::entities::logical_meta_id("<#= arch.logical_meta_element_id().value() #>"));
    r.technical_space(identification::entities::technical_space::<#= arch.technical_space() #>);
    r.relations().status(physical::entities::relation_status::<#= arch.relations().status() #>);
<#+
            if (!arch.postfix().empty())
#>
    r.postfix("<#= arch.postfix() #>");
<#+
            for(const auto& l : arch.labels()) {
#>
    r.labels().push_back(identification::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }

            for(const auto& cr : arch.relations().constant()) {
#>

    r.relations().constant().push_back(
        physical::entities::constant_relation(
            "<#= cr.original_urn() #>",
            ""/*resolved_urn*/,
<#+
                if (cr.labels().empty()) {
#>
            std::list<identification::entities::label> {},
<#+
                } else {
#>
            std::list<identification::entities::label> {
<#+
                    utility::formatters::sequence_formatter sf(cr.labels().size());
                    // sf.prefix_configuration().first(": ").not_first("  ");
                    sf.postfix_configuration().not_last(",")/*.last("")*/;

                    for(const auto& l : cr.labels()) {
#>
                identification::entities::label("<#= l.key() #>", "<#= l.value() #>")<#= sf.postfix() #>
<#+
                        sf.next();
                    }
#>
            },
<#+
                }
#>
            "<#= cr.logical_model_element_id() #>"
        )
    );
<#+
            }

            for(const auto& vr : arch.relations().variable()) {
#>

    r.relations().variable().push_back(
        physical::entities::variable_relation(
            "<#= vr.original_urn() #>",
            ""/*resolved_urn*/,
            physical::entities::variable_relation_type::<#= vr.type() #>
        )
    );
<#+
            }
#>

    return r;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** facet class header transform                                   :element:
     :PROPERTIES:
     :custom_id: 634DBF58-17C9-2BB4-8A83-AE10DBDD40CB
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
     :masd.wale.kvp.archetype.simple_name: facet_class_header_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.constant_relation: dogen.physical.entities.facet,archetype:masd.cpp.types.class_header
     :masd.physical.constant_relation: dogen.text.transforms.registrar,archetype:masd.cpp.types.class_header,technical_space:cpp
     :masd.physical.constant_relation: dogen.text.csharp.transforms.registrar,archetype:masd.cpp.types.class_header,technical_space:csharp
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :masd.codec.plantuml: facet_class_header_transform o-d- facet_class_implementation_transform
     :END:

Generates header files for facet transforms.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_header_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void facet_class_header_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(e.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(fct.documentation());
#>
class <#= fct.name().simple() #>_facet_chain final {
public:
    static const physical::entities::facet& static_facet();
    const physical::entities::facet& facet() const;

public:
    // static void initialise(registrar& r);
};
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** facet class implementation transform                           :element:
     :PROPERTIES:
     :custom_id: 91D9B3D7-8ECB-1684-C853-1D5544AAC1E9
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
     :masd.wale.kvp.archetype.simple_name: facet_class_implementation_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.variable_relation: self,archetype:masd.cpp.types.class_header
     :masd.physical.variable_relation: transparent,role:type_declaration
     :masd.physical.constant_relation: dogen.physical.helpers.meta_name_builder,archetype:masd.cpp.types.class_header
     :masd.physical.constant_relation: dogen.utility.log.logger,archetype:masd.cpp.types.class_header
     :masd.physical.constant_relation: dogen.text.transforms.transformation_error,archetype:masd.cpp.types.class_header
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :masd.codec.plantuml: facet_class_implementation_transform o-d- facet_class_header_factory
     :END:

Generates implementation files for facet transforms.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/entities/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_implementation_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void facet_class_implementation_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(fct.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(fct.name().simple() + "_facet_chain");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= fct.name().qualified().dot() #>"));

physical::entities::facet make_facet() {
    identification::helpers::physical_meta_name_builder b;
    b.meta_model("<#= fct.meta_model_name() #>");
    b.backend("<#= fct.backend_name() #>");
    b.facet("<#= fct.name().simple() #>");

    physical::entities::facet r;
    r.meta_name(b.build());
    return r;
}

}

const physical::entities::facet& <#= sn #>::static_facet() {
    static const auto r(make_facet());
    return r;
}

const physical::entities::facet& <#= sn #>::facet() const {
    return static_facet();
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** facet class header factory                                     :element:
     :PROPERTIES:
     :custom_id: AC92BA39-39EB-B344-C0DB-F79CDF2FC26E
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
     :masd.wale.kvp.archetype.simple_name: facet_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.role: type_declaration
     :masd.physical.relation_status: relatable
     :masd.physical.constant_relation: dogen.physical.entities.facet,archetype:masd.cpp.types.class_header
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates header files for facet factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void facet_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(e.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the facet
 * <#= fct.name().simple() #>.
 *
 * Facet documentation: <#= fct.documentation() #>
 */
class <#= fct.name().simple() #>_factory final {
public:
    static physical::entities::facet make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** facet class implementation factory                             :element:
     :PROPERTIES:
     :custom_id: 1DC48A72-628E-7094-B9DB-D13860889A93
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_facet
     :masd.wale.kvp.archetype.simple_name: facet_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.variable_relation: self,archetype:masd.cpp.types.facet_class_header_factory
     :masd.physical.variable_relation: transparent,archetype:masd.cpp.types.archetype_class_header_factory
     :masd.physical.constant_relation: dogen.utility.log.logger,archetype:masd.cpp.types.class_header
     :masd.physical.constant_relation: dogen.text.transforms.transformation_error,archetype:masd.cpp.types.class_header
     :masd.physical.constant_relation: dogen.physical.helpers.meta_name_builder,archetype:masd.cpp.types.class_header
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for facet factory.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/types/entities/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/facet.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/facet_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void facet_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "facet class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& fct(ast.as<logical::entities::physical::facet>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(fct));
        {
            const auto ns(ast.make_namespaces(fct.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(fct.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= fct.name().qualified().dot() #>"));

}

physical::entities::facet <#= sn #>::make() {
    identification::helpers::physical_meta_name_builder b;
    b.meta_model("<#= fct.meta_model_name() #>");
    b.backend("<#= fct.backend_name() #>");
    b.facet("<#= fct.name().simple() #>");

    physical::entities::facet r;
    r.meta_name(b.build());
<#+
            if (!fct.directory_name().empty())
#>
    r.directory_name("<#= fct.directory_name() #>");
<#+
            if (!fct.postfix().empty())
#>
    r.postfix("<#= fct.postfix() #>");
<#+
            for(const auto& l : fct.labels()) {
#>
    r.labels().push_back(identification::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }

            if (!fct.archetypes().empty() || !fct.helpers().empty()) {
#>

    const auto lambda([&](auto& container, const auto& element) {
        const auto id(element.meta_name().id());
        const auto pair(std::make_pair(id, element));
        const auto inserted(container.insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_archetype("Duplicate id: ");
            BOOST_LOG_SEV(lg, error) << duplicate_archetype << id;
            BOOST_THROW_EXCEPTION(
                transformation_error(duplicate_archetype + id.value()));
        }
    });

<#+
            }

            for (const auto& n : fct.archetypes()) {
#>
    lambda(r.archetypes(), <#= n.simple() #>_factory::make());
<#+
            }
#>

<#+
            for (const auto& n : fct.helpers()) {
#>
    lambda(r.helpers(), <#= n.simple() #>_factory::make());
<#+
            }

#>
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** backend class header transform                                 :element:
     :PROPERTIES:
     :custom_id: 9F3464ED-0EE0-8004-48FB-2C04C2E422BF
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
     :masd.wale.kvp.archetype.simple_name: backend_class_header_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for archetypes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_header_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void backend_class_header_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(be.documentation());
#>
class <#= be.name().simple() #>_backend_chain final {
public:
    // static const physical::entities::backend& static_backend();
    // const physical::entities::backend& backend() const;

public:
    // static void initialise(transforms::registrar& r);
};
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** backend class implementation transform                         :element:
     :PROPERTIES:
     :custom_id: 96CF2EFA-9C45-0C84-210B-4A3BD63A3F89
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
     :masd.wale.kvp.archetype.simple_name: backend_class_implementation_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for archetypes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_implementation_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void backend_class_implementation_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(be.name().simple() + "_backend_chain");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= be.name().qualified().dot() #>"));

/*
physical::entities::backend make_backend() {
    identification::helpers::physical_meta_name_builder b;
    b.meta_model("<#= be.meta_model_name() #>");
    b.backend("<#= be.backend_name() #>");

    physical::entities::backend r;
    r.meta_name(b.build());

    const auto lambda([&](const auto& fct) {
        const auto id(fct.meta_name().id());
        const auto pair(std::make_pair(id, fct));
        const auto inserted(r.facets().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate facet: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));
        }
    });

<#+
            for (const auto& n : be.facets()) {
#>
    lambda(<#= n.simple() #>::<#= n.simple() #>_facet_chain::static_facet());
<#+
            }
#>
    return r;
}
*/

}
/*
const physical::entities::backend& <#= sn #>::static_backend() {
    static const auto r(make_backend());
    return r;
}

const physical::entities::backend& <#= sn #>::backend() const {
    return static_backend();
}
*/
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}
#>
#+end_src

**** backend class header factory                                   :element:
     :PROPERTIES:
     :custom_id: E25E1986-B544-6884-9B33-EFD99F5FBFFE
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
     :masd.wale.kvp.archetype.simple_name: backend_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.relation_status: relatable
     :masd.label.role: type_declaration
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates header files for backend factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void backend_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the backend
 * <#= be.name().simple() #>.
 *
 * Backend documentation: <#= be.documentation() #>
 */
class <#= be.name().simple() #>_factory final {
public:
    static physical::entities::backend make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** part class header transform                                    :element:
     :PROPERTIES:
     :custom_id: 832DB211-25DA-8664-125B-A0EA87C9C28B
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
     :masd.wale.kvp.archetype.simple_name: part_class_header_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for parts.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_header_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void part_class_header_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::physical::part>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #> final : public model_to_text_transform {
public:
<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** part class header factory                                      :element:
     :PROPERTIES:
     :custom_id: 6E4B7F24-4317-7E94-F50B-29BEA2E7E901
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
     :masd.wale.kvp.archetype.simple_name: part_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.relation_status: relatable
     :masd.label.role: type_declaration
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates header files for part factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void part_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& part(ast.as<logical::entities::physical::part>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(part));
        {
            const auto ns(ast.make_namespaces(part.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the part
 * <#= part.name().simple() #>.
 *
 * Part documentation: <#= part.documentation() #>
 */
 class <#= part.name().simple() #>_factory final {
public:
    static physical::entities::part make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** helper class header transform                                  :element:
     :PROPERTIES:
     :custom_id: 8456BDA2-D995-53D4-163B-B6EEE3BA2908
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_helper
     :masd.wale.kvp.archetype.simple_name: helper_class_header_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for helpers.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_header_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_header_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void helper_class_header_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types helper class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::physical::helper>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple() + "_transform");
#>

class <#= sn #> final : public text::transforms::helper_transform {
public:
    std::string id() const override;
    std::string family() const override;
    std::list<std::string> owning_formatters() const override;
    std::list<std::string> owning_facets() const override;
    std::string helper_name() const override;
    bool is_enabled(const physical::entities::model& m,
        const logical::entities::element& e,
        const physical::entities::artefact& a,
        const logical::entities::helper_properties& hp) const override;
    void apply(std::ostream& os,
        const logical::entities::model& m,
        const logical::entities::helper_properties& hp) const override;
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>
#+end_src

**** helper class header factory                                    :element:
     :PROPERTIES:
     :custom_id: 1472DA51-9A35-48A4-BA9B-7263695C56EC
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_helper
     :masd.wale.kvp.archetype.simple_name: helper_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.relation_status: relatable
     :masd.label.role: type_declaration
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates header files for helper factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void helper_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "types helper class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::physical::helper>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the helper
 * <#= o.name().simple() #>.
 *
 * Helper documentation: <#= o.documentation() #>
 */
class <#= o.name().simple() #>_factory final {
public:
    /**
     * @brief Makes the helper.
     */
    static physical::entities::helper make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>
#+end_src

**** archetype kind class header factory                            :element:
     :PROPERTIES:
     :custom_id: E8567050-91CD-E154-627B-64478FBB24D7
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype_kind
     :masd.wale.kvp.archetype.simple_name: archetype_kind_class_header_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.relation_status: relatable
     :masd.label.role: type_declaration
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates header files for archetype_kind factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype_kind.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_kind_class_header_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_kind_class_header_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_kind_class_header_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype_kind class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& be(ast.as<logical::entities::physical::archetype_kind>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Creates a physical representation for the archetype_kind
 * <#= be.name().simple() #>.
 *
 * Archetype_Kind documentation: <#= be.documentation() #>
 */
class <#= be.name().simple() #>_factory final {
public:
    static physical::entities::archetype_kind make();
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** backend class implementation factory                           :element:
     :PROPERTIES:
     :custom_id: F829032D-F148-4F64-AF43-B4A7F3DF7D14
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_backend
     :masd.wale.kvp.archetype.simple_name: backend_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for backend factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/backend.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/backend_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void backend_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "backend class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& be(ast.as<logical::entities::physical::backend>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(be));
        {
            const auto ns(ast.make_namespaces(be.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(be.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= be.name().qualified().dot() #>"));

}

physical::entities::backend <#= sn #>::make() {
    identification::helpers::physical_meta_name_builder b;
    b.meta_model("<#= be.meta_model_name() #>");
    b.backend("<#= be.backend_name() #>");

    physical::entities::backend r;
    r.meta_name(b.build());
<#+
            if (!be.directory_name().empty())
#>
    r.directory_name("<#= be.directory_name() #>");
<#+
            for(const auto& l : be.labels()) {
#>
    r.labels().push_back(identification::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }

            if (!be.facets().empty()) {
#>

    const auto fct_inserter([&](const auto& fct) {
        const auto id(fct.meta_name().id());
        const auto pair(std::make_pair(id, fct));
        const auto inserted(r.facets().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate facet: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));
        }
    });

<#+
                for (const auto& n : be.facets()) {
                    // Bit of a hack: facets work as namespaces.
#>
    fct_inserter(<#= n.simple() #>::<#= n.simple() #>_factory::make());
<#+
                }
            }

            if (!be.archetype_kinds().empty()) {
#>

    const auto ak_inserter([&](const auto& ak) {
        const auto pair(std::make_pair(ak.id(), ak));
        const auto inserted(r.archetype_kinds().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate archetype kind: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << ak.id();
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + ak.id()));
        }
    });
<#+
                for (const auto& n : be.archetype_kinds()) {
#>
    ak_inserter(<#= n.simple() #>_factory::make());
<#+
                }
            }

            if (!be.parts().empty()) {
#>

    const auto part_inserter([&](const auto& part) {
        const auto id(part.meta_name().id());
        const auto pair(std::make_pair(id, part));
        const auto inserted(r.parts().insert(pair).second);
        if (!inserted) {
            using text::transforms::transformation_error;
            const std::string duplicate_facet("Duplicate part: ");
            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;
            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));
        }
    });
<#+
                for (const auto& n : be.parts()) {
#>
    part_inserter(<#= n.simple() #>_factory::make());
<#+
                }
            }
#>
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}
#>
#+end_src

**** part class implementation transform                            :element:
     :PROPERTIES:
     :custom_id: FB4EFD5B-1CA1-84C4-F063-FD903061883C
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
     :masd.wale.kvp.archetype.simple_name: part_class_implementation_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for parts.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_implementation_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void part_class_implementation_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** part class implementation factory                              :element:
     :PROPERTIES:
     :custom_id: 92C55EBF-4D52-51B4-9763-D4CC48D027E5
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_part
     :masd.wale.kvp.archetype.simple_name: part_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for part factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/part.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/part_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void part_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "part class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& part(ast.as<logical::entities::physical::part>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(part));
        {
            const auto ns(ast.make_namespaces(part.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(part.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= part.name().qualified().dot() #>"));

}

physical::entities::part <#= sn #>::make() {
    identification::helpers::physical_meta_name_builder b;
    b.meta_model("<#= part.meta_model_name() #>");
    b.backend("<#= part.backend_name() #>");
    b.part("<#= part.name().simple() #>");

    physical::entities::part r;
    r.meta_name(b.build());
<#+
             if (!part.directory_name().empty())
#>
    r.directory_name("<#= part.directory_name() #>");
<#+
             for(const auto& l : part.labels()) {
#>
    r.labels().push_back(identification::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }
#>

    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}
#>
#+end_src

**** helper class implementation transform                          :element:
     :PROPERTIES:
     :custom_id: 698179B5-0EAC-C624-D1DB-31BAEE0E65A2
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_helper
     :masd.wale.kvp.archetype.simple_name: helper_class_implementation_transform
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: transform
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for helpers.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_implementation_transform_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_implementation_transform_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void helper_class_implementation_transform_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "helper class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& arch(ast.as<logical::entities::physical::helper>(e));
    ast.update_artefact();
    a.content(arch.text_templating().rendered_stitch_template());
    stp.end_transform(a);
}

#>
#+end_src

**** helper class implementation factory                            :element:
     :PROPERTIES:
     :custom_id: 9ECBFDD4-A58F-3BE4-B023-55147FA313F5
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_helper
     :masd.wale.kvp.archetype.simple_name: helper_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for helper factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/helper_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void helper_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "helper class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& hlp(ast.as<logical::entities::physical::helper>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(hlp));
        {
            const auto ns(ast.make_namespaces(hlp.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(hlp.name().simple() + "_factory");
#>

physical::entities::helper <#= sn #>::make() {
    physical::entities::helper r;
    using pmnf = identification::helpers::physical_meta_name_factory;
    r.meta_name(pmnf::make("<#= hlp.backend_name() #>", "<#= hlp.facet_name() #>", "<#= hlp.name().simple() #>"));
    // r.relations().status(physical::entities::relation_status::<#= hlp.relations().status() #>);
<#+
             if (!hlp.family().empty()) {
#>
    r.family("<#= hlp.family() #>");
<#+
             }

             if (!hlp.owning_formatters().empty() || !hlp.owning_facets().empty()) {
#>
    using identification::entities::physical_meta_id;
<#+
             }

             for (const auto& of : hlp.owning_formatters()) {
#>
    r.owning_formatters().push_back(
        physical_meta_id("<#= of #>"));
<#+
             }



             for (const auto& of : hlp.owning_facets()) {
#>
    r.owning_facets().push_back(
        physical_meta_id("<#= of #>"));
<#+
             }

             for(const auto& l : hlp.labels()) {
#>
    r.labels().push_back(identification::entities::label("<#= l.key() #>", "<#= l.value() #>"));
<#+
            }

            for(const auto& cr : hlp.relations().constant()) {
#>

    r.relations().constant().push_back(
        physical::entities::constant_relation(
            "<#= cr.original_urn() #>",
            ""/*resolved_urn*/,
<#+
                if (cr.labels().empty()) {
#>
            std::list<identification::entities::label> {},
<#+
                } else {
#>
            std::list<identification::entities::label> {
<#+
                    utility::formatters::sequence_formatter sf(cr.labels().size());
                    // sf.prefix_configuration().first(": ").not_first("  ");
                    sf.postfix_configuration().not_last(",")/*.last("")*/;

                    for(const auto& l : cr.labels()) {
#>
                identification::entities::label("<#= l.key() #>", "<#= l.value() #>")<#= sf.postfix() #>
<#+
                        sf.next();
                    }
#>
            },
<#+
                }
#>
            "<#= cr.logical_model_element_id() #>"
        )
    );
<#+
            }

            for(const auto& vr : hlp.relations().variable()) {
#>

    r.relations().variable().push_back(
        physical::entities::variable_relation(
            "<#= vr.original_urn() #>",
            ""/*resolved_urn*/,
            physical::entities::variable_relation_type::<#= vr.type() #>
        )
    );
<#+
            }
#>

    return r;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** archetype kind class implementation factory                    :element:
     :PROPERTIES:
     :custom_id: 72E2DDAD-E915-4CD4-98B3-F3DF41F3B155
     :masd.physical.logical_meta_element_id: dogen.logical.entities.physical_archetype_kind
     :masd.wale.kvp.archetype.simple_name: archetype_kind_class_implementation_factory
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.physical.postfix: factory
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for archetype_kind factories.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/physical/archetype_kind.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_kind_class_implementation_factory_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/archetype_kind_class_implementation_factory_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void archetype_kind_class_implementation_factory_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "archetype_kind class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ak(ast.as<logical::entities::physical::archetype_kind>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(ak));
        {
            const auto ns(ast.make_namespaces(ak.name(),
                    false/*detect_model_name*/));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(ak.name().simple() + "_factory");
#>
namespace {

using namespace dogen::utility::log;
static logger lg(logger_factory("<#= ak.name().qualified().dot() #>"));

}

physical::entities::archetype_kind <#= sn #>::make() {
    physical::entities::archetype_kind r;
    r.id("<#= ak.name().simple() #>");
    r.file_extension("<#= ak.file_extension() #>");
    return r;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);

}

#>
#+end_src

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: 114D2F5C-91BF-BC14-AB9B-BE24495DB993
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.role: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(o.documentation());
            if (o.parents().empty()) {
#>
class <#= sn #> <#= ast.make_final_keyword_text(o) #>{
<#+
            } else {
                const auto& pn(o.parents().front());
                const auto pqn(ast.get_qualified_name(pn));
#>
class <#= sn #> <#= ast.make_final_keyword_text(o) #>: public <#= pqn #> {
<#+
            }

            /*
             * Compiler generated constructors and destructors.
             */
            if (ast.supports_defaulted_functions()) {
#>
public:
<#+
                if (!ast.requires_manual_default_constructor())
#>
    <#= sn #>() = default;
    <#= sn #>(const <#= sn #>&) = default;
<#+
                if (!ast.requires_manual_move_constructor())
#>
    <#= sn #>(<#= sn #>&&) = default;
<#+
                if (!o.in_inheritance_relationship())
#>
    ~<#= sn #>() = default;
<#+
                if (o.is_immutable())
#>
    <#= sn #>& operator=(const <#= sn #>&) = delete;
<#+
                else if (o.all_attributes().empty())
#>
    <#= sn #>& operator=(const <#= sn #>&) = default;

<#+
            }

            /*
             * Manually generated default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>
public:
    <#= sn #>();

<#+
            }

            /*
             * Manually generated destructor.
             *
             * according to MEC++, item 33, base classes should always be
             * abstract. this avoids all sorts of tricky problems with
             * assignment and swap.
             *
             * incidentally, this also fixes some strange clang errors:
             * undefined reference to `vtable.
             */
            if (o.is_parent()) {
#>
    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> = 0;

<#+
            } else if (o.is_child() != 0) {
#>
    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
            }

            /*
             * Manually generated move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>
public:
    <#= sn #>(<#= sn #>&& rhs);

<#+
            }

            /*
             * Manually generated complete constructor.
             */
            if (!o.all_attributes().empty()) {
#>
public:
<#+
                const auto attr_count(o.all_attributes().size());
                if (attr_count == 1) {
                    const auto attr(*o.all_attributes().begin());
#>
    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);
<#+
                } else {
#>
    <#= sn #>(
<#+
                    utility::formatters::sequence_formatter sf(attr_count);
                    sf.postfix_configuration().last(");");
                    for (const auto& attr : o.all_attributes()) {
#>
        const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>
<#+
                        sf.next();
                    }
                }
#>

<#+
            }

            /*
             * Serialisaton Friends
             */
            if (ast.is_serialization_enabled()) {
#>
private:
    template<typename Archive>
    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);

    template<typename Archive>
    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);

<#+
            }

            /*
             * Visitation.
             */
            if (o.is_visitation_root()) {
                const auto vsn(o.base_visitor()->simple());
#>
public:
    virtual void accept(const <#= vsn #>& v) const = 0;
    virtual void accept(<#= vsn #>& v) const = 0;
    virtual void accept(const <#= vsn #>& v) = 0;
    virtual void accept(<#= vsn #>& v) = 0;

<#+
            } else if (o.is_visitation_leaf()) {
                std::string bvn;
                std::string rpn;
                if (o.derived_visitor()) {
                    bvn = ast.get_qualified_name(*o.base_visitor());
                    rpn = ast.get_qualified_name(o.root_parents().front());
                } else {
                    bvn = o.base_visitor()->simple();
                    rpn = o.root_parents().front().simple();
                }
#>
public:
    using <#= rpn #>::accept;

    virtual void accept(const <#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;
    virtual void accept(<#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;
    virtual void accept(const <#= bvn #>& v)<#= ast.make_override_keyword_text() #>;
    virtual void accept(<#= bvn #>& v)<#= ast.make_override_keyword_text() #>;
<#+
            }

            /*
             * Streaming
             */
            if (ast.is_io_enabled()) {
                if (o.is_parent()) {
#>
public:
    virtual void to_stream(std::ostream& s) const;

<#+
                } else if (!o.parents().empty()) {
#>
public:
    void to_stream(std::ostream& s) const<#= ast.make_override_keyword_text() #>;

<#+
                }
            }

            /*
             * Getters and setters.
             */
            if (!o.local_attributes().empty()) {
#>
public:
<#+
                for (const auto& attr : o.local_attributes()) {
                    ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());

                    if (attr.parsed_type().is_current_simple_type()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;
<#+
                        if (attr.is_immutable()) {
#>

<#+
                            continue;
                        }
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                    } else {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;
<#+
                        if (attr.is_immutable()) {
#>

<#+
                            continue;
                        }
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                        if (ast.supports_move_operator()) {
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);
<#+
                        }
                    }
                    ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());
#>

<#+
                }
            }

            /*
             * Equality.
             *
             * Equality is only public in leaf classes - MEC++-33.
             */
            if (o.is_parent()) {
#>
protected:
    bool compare(const <#= sn #>& rhs) const;
<#+
            } else {
#>
public:
    bool operator==(const <#= sn #>& rhs) const;
    bool operator!=(const <#= sn #>& rhs) const {
        return !this->operator==(rhs);
    }

<#+
            }

            if (o.in_inheritance_relationship()) {
#>
public:
<#+
                if (o.is_parent() && !o.is_child()) {
#>
    virtual bool equals(const <#= sn #>& other) const = 0;
<#+
                } else if (o.is_parent()) {
                    const auto rpn(o.root_parents().front());
#>
    virtual bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const = 0;
<#+
                } else if (!o.root_parents().empty()) {
                    const auto rpn(o.root_parents().front());
#>
    bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const<#= ast.make_override_keyword_text() #>;
<#+
                }
#>

<#+
             }

            /*
             * Swap and assignment.
             *
             * Swap and assignment are only public in leaf classes - MEC++-33
             */
            if ((!o.all_attributes().empty() || o.is_parent()) && !o.is_immutable()) {
                if (o.is_parent()) {
#>
protected:
<#+
                } else {
#>
public:
<#+
                }
#>
    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;
<#+
                if (!o.is_parent() && !o.is_immutable()) {
#>
    <#= sn #>& operator=(<#= sn #> other);
<#+
                }
#>

<#+
            }

            /*
             * Member variables.
             */
            if (!o.local_attributes().empty()) {
#>
private:
<#+
                for (const auto& attr : o.local_attributes()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;
<#+
                }
            }
#>
};

<#+
            /*
             * Destructor implementation.
             */
            if (o.is_parent()) {
#>
inline <#= sn #>::~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
            }

            /*
             * Global equality operator implementation.
             */
            if (o.is_parent()) {
#>
inline bool operator==(const <#= sn #>& lhs, const <#= sn #>& rhs) {
    return lhs.equals(rhs);
}

<#+
            }
        }

        if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {
#>

namespace std {

template<>
inline void swap(
    <#= qn #>& lhs,
    <#= qn #>& rhs) {
    lhs.swap(rhs);
}

}
<#+
        }
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** class forward declarations                                     :element:
     :PROPERTIES:
     :custom_id: 46A8F5AF-AED5-2204-FEB3-EBDAE1FD7FF1
     :masd.physical.logical_meta_element_id: dogen.logical.entities.object
     :masd.wale.kvp.archetype.simple_name: class_forward_declarations
     :masd.physical.relation_status: relatable
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: forward declaration
     :masd.physical.postfix: fwd
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates forward declarations for classes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_forward_declarations_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class forward declarations",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** namespace header                                               :element:
     :PROPERTIES:
     :custom_id: A52A460B-30B9-59B4-3023-9740DD2A4450
     :masd.physical.logical_meta_element_id: dogen.logical.entities.module
     :masd.wale.kvp.archetype.simple_name: namespace_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for namespaces.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/module.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/namespace_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/namespace_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void namespace_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "namespace header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& m(ast.as<logical::entities::structural::module>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            if (ast.requires_nested_namespaces()) {
                ast.comment(m.documentation());
                const auto ns(ast.make_namespaces(e.name(),
                        false/*detect_model_name*/));
                auto snf(ast.make_scoped_namespace_formatter(ns));
            } else {
                const auto ns(ast.make_namespaces(m.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
                ast.comment(m.documentation());
#>
namespace <#= m.name().simple() #> {
}

<#+
            }
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** visitor header                                                 :element:
     :PROPERTIES:
     :custom_id: 913BCA28-48E1-6F34-A903-8493892A3C5F
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visitor
     :masd.wale.kvp.archetype.simple_name: visitor_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for visitors.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/visitor.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/visitor_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/visitor_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void visitor_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "visitor header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& v(ast.as<logical::entities::structural::visitor>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(v.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(v.documentation());
            if (!v.parent())
#>
class <#= v.name().simple() #> {
<#+
            else {
                const auto& pn(*v.parent());
                const auto pqn(ast.get_qualified_name(pn));
#>
class <#= v.name().simple() #> : public <#= pqn #> {
<#+
            }
#>
public:
    virtual ~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = 0;

public:
<#+
            if (v.parent()) {
                const auto& pn(*v.parent());
                const auto pqn(ast.get_qualified_name(pn));
#>
    using <#= pqn #>::visit;

<#+
            }

            bool is_first(true);
            for (const auto& t : v.visits()) {
                if (!is_first)
#>

<#+
                const auto qn(ast.get_qualified_name(t));
                const auto doc("Accept visits for type " + qn);
                ast.comment_start_method_group(doc);
#>
    virtual void visit(const <#= qn #>&) const { }
    virtual void visit(const <#= qn #>&) { }
    virtual void visit(<#= qn #>&) const { }
    virtual void visit(<#= qn #>&) { }
<#+
                ast.comment_end_method_group(doc);
                is_first = false;
            }
#>
};

inline <#= v.name().simple() #>::~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> { }

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: 0B93E72D-9D14-4504-78D3-93E7332D4E11
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto attr(p.value_attribute());

            ast.comment(p.documentation());
#>
class <#= sn #> final {
public:
<#+
            /*
             * Compiler generated constructors and destructors.
             */
            if (!ast.requires_manual_default_constructor())
#>
    <#= sn #>() = default;
    <#= sn #>(const <#= sn #>&) = default;
<#+
            if (!ast.requires_manual_move_constructor())
#>
    <#= sn #>(<#= sn #>&&) = default;
    ~<#= sn #>() = default;
<#+
            if (p.is_immutable())
#>
    <#= sn #>& operator=(const <#= sn #>&) = delete;
<#+
            /*
             * Manually generated default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>
public:
    <#= sn #>();

<#+
            }

            /*
             * Manually generated move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>
public:
    <#= sn #>(<#= sn #>&& rhs);

<#+
            }

            /*
             * Manually generated complete constructor.
             */
#>
public:
    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);

<#+
            /*
             * Serialisaton Friends
             */
            if (ast.is_serialization_enabled()) {
#>
private:
    template<typename Archive>
    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);

    template<typename Archive>
    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);

<#+
            }

            /*
             * Getters and setters.
             */
#>
public:
<#+
            ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());
            if (attr.parsed_type().is_current_simple_type()) {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;
<#+
                if (attr.is_immutable()) {
#>

<#+

                } else {
#>
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
<#+
                }
            } else {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;
<#+
                if (attr.is_immutable()) {
#>

<#+
                } else {
#>
    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);
    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);
<#+
                }
            }
            ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());

            /*
             * Explicit cast.
             */
#>

public:
    explicit operator <#= ast.get_qualified_name(attr.parsed_type()) #>() const {
        return <#= attr.member_variable_name() #>;
    }
<#+
            /*
             * Equality.
             */
#>

public:
    bool operator==(const <#= sn #>& rhs) const;
    bool operator!=(const <#= sn #>& rhs) const {
        return !this->operator==(rhs);
    }

<#+
            /*
             * Swap and assignment.
             */
#>
public:
    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;
<#+
            if (!p.is_immutable()) {
#>
    <#= sn #>& operator=(<#= sn #> other);
<#+
            }

            /*
             * Member variables.
             */
#>

private:
    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;
};

<#+
        } // snf

        if (!p.is_immutable()) {
#>

namespace std {

template<>
inline void swap(
    <#= qn #>& lhs,
    <#= qn #>& rhs) {
    lhs.swap(rhs);
}

}
<#+
        }
#>

<#+
    } //ah  sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive forward declarations                                 :element:
     :PROPERTIES:
     :custom_id: C70B6A05-2B3E-B1D4-54AB-39599D831A34
     :masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
     :masd.wale.kvp.archetype.simple_name: primitive_forward_declarations
     :masd.physical.relation_status: relatable
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: forward declaration
     :masd.physical.postfix: fwd
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates forward declarations for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_forward_declarations_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive forward declarations",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(p));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= p.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** feature template bundle header                                 :element:
     :PROPERTIES:
     :custom_id: 1E72459E-EA69-1BA4-123B-BE55F0C1A915
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_template_bundle
     :masd.wale.kvp.archetype.simple_name: feature_template_bundle_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates implementation files for feature template bundles

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_template_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_template_bundle_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_template_bundle_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void feature_template_bundle_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature template bundle header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& fb(ast.as<logical::entities::variability::feature_template_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using utility::string::splitter;
#>

<#+
            ast.comment(fb.documentation());
#>
class <#= sn #> final {
<#+
            if (fb.generate_static_configuration()) {
#>
public:
    struct feature_group {
<#+
                for (const auto& fb_ft : fb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        variability::entities::feature <#= simple_key #>;
<#+
                }
#>
    };

    static feature_group
    make_feature_group(const variability::entities::feature_model& fm);

public:
    struct static_configuration {
<#+
                for (const auto& fb_ft : fb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;
<#+
                }

                if (fb.requires_manual_default_constructor()) {
                    bool is_first(true);
                    std::ostringstream ss;
                    for (const auto& fb_ft : fb.feature_templates()) {
                        if (!fb_ft.parsed_type().is_current_simple_type())
                            continue;

                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());

                        if (!is_first)
                            ss << "," << std::endl << "            ";

                        ss << simple_key << "()";
                        is_first = false;
                    }
#>

        static_configuration() :
            <#= ss.str() #> {}
<#+
                }
#>
    };

    static static_configuration make_static_configuration(
        const feature_group& fg,
        const variability::entities::configuration& cfg);

    template<typename Configurable>
    static static_configuration make_static_configuration(
        const feature_group& fg, const Configurable& c) {
        return make_static_configuration(fg, *c.configuration());
    }
<#+
            }

            if (fb.generate_registration()) {
#>

public:
    static std::list<dogen::variability::entities::feature_template>
    make_templates();
<#+
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** feature bundle header                                          :element:
     :PROPERTIES:
     :custom_id: F10BFE76-C9AB-6BA4-725B-0B47E6EA1F0E
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_bundle
     :masd.wale.kvp.archetype.simple_name: feature_bundle_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for feature bundles.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_bundle_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_bundle_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void feature_bundle_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature bundle header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using utility::string::splitter;
#>

<#+
            ast.comment(fb.documentation());
#>
class <#= sn #> final {
<#+
            if (fb.generate_static_configuration()) {
#>
public:
    struct feature_group {
<#+
                for (const auto& fb_ft : fb.features()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        variability::entities::feature <#= simple_key #>;
<#+
                }
#>
    };

    static feature_group
    make_feature_group(const variability::entities::feature_model& fm);

public:
    struct static_configuration {
<#+
                for (const auto& fb_ft : fb.features()) {
                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());
#>
        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;
<#+
                }

                if (fb.requires_manual_default_constructor()) {
                    bool is_first(true);
                    std::ostringstream ss;
                    for (const auto& fb_ft : fb.features()) {
                        if (!fb_ft.parsed_type().is_current_simple_type())
                            continue;

                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());

                        if (!is_first)
                            ss << "," << std::endl << "            ";

                        ss << simple_key << "()";
                        is_first = false;
                    }
#>

        static_configuration() :
            <#= ss.str() #> {}
<#+
                }
#>
    };

    static static_configuration make_static_configuration(
        const feature_group& fg,
        const variability::entities::configuration& cfg);

    template<typename Configurable>
    static static_configuration make_static_configuration(
        const feature_group& fg, const Configurable& c) {
        return make_static_configuration(fg, *c.configuration());
    }
<#+
            }
#>

<#+
            if (fb.generate_registration()) {
#>
public:
    static std::list<dogen::variability::entities::feature>
    make_features();
<#+
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** variability initializer header                                 :element:
     :PROPERTIES:
     :custom_id: 7971076F-2205-FCE4-602B-F26072C589EA
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_initializer
     :masd.wale.kvp.archetype.simple_name: variability_initializer_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for feature bundles.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/initializer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/variability_initializer_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/variability_initializer_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void variability_initializer_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "variability initializer header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::variability::initializer>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

/**
 * @brief Registers all of the available feature templates with registrar.
 */
class <#= sn #> final {
public:
    static void register_entities(variability::helpers::registrar& rg);
};

<#+
        }
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** main                                                           :element:
     :PROPERTIES:
     :custom_id: C0123EEA-FB49-F054-F313-A37E1FDD134F
     :masd.physical.logical_meta_element_id: dogen.logical.entities.entry_point
     :masd.wale.kvp.archetype.simple_name: main
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation file for entry point.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/entry_point.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/main_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/main_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void main_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "main",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::entry_point>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

int main(int /*argc*/, char* /*argv*/[]) {
    return 0;
}

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 1DC4711B-7863-4024-0B53-A8BD1B1F2B9A
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>

<#= sn #>::<#= sn #>()
<#+
                // FIXME: this was just too hard to hack with a sequence.
                // FIXME: indentation is all off too.
                std::ostringstream ss;
                bool is_first(true);
                bool found(false);
                for (const auto& attr : o.local_attributes()) {
                    if (!attr.parsed_type().is_current_simple_type())
                        continue;

                    found = true;
                    if (!is_first)
                        ss << "," << std::endl << "      ";

                    ss << attr.member_variable_name()
                       << "(static_cast<" << ast.get_qualified_name(attr.parsed_type())
                       << ">(0))";

                    is_first = false;
                }
                ss << " { }";
                const std::string out(ss.str());
#>
    <#= (found ? ": " : "") #><#= out #>
<#+
            }

            /*
             * Move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>

<#= sn #>::<#= sn #>(<#= sn #>&& rhs)
<#+
                const auto size(o.parents().size() + o.local_attributes().size());

                utility::formatters::sequence_formatter sf(size);
                sf.prefix_configuration().first(": ").not_first("  ");
                sf.postfix_configuration().last(" { }");
                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= sf.prefix() #><#= pqn #>(
        std::forward<<#= pqn #>>(rhs))<#= sf.postfix() #>
<#+
                    sf.next();
                }

                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>))<#= sf.postfix() #>
<#+
                    sf.next();
                }
            }

            /*
             * Complete constructor.
             */
            if (!o.all_attributes().empty()) {
                const auto attr_count(o.all_attributes().size());
                if (attr_count == 1) {
                     const auto attr(*o.all_attributes().begin());
#>

<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)
<#+
                } else {
#>

<#= sn #>::<#= sn #>(
<#+

                    utility::formatters::sequence_formatter sf(attr_count);
                    sf.postfix_configuration().last(")");
                    for (const auto& attr : o.all_attributes()) {
#>
    const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>
<#+
                        sf.next();
                    }
                }

                auto sequence_size(o.local_attributes().size() + o.parents().size());
                for (const auto& pair : o.inherited_attributes()) {
                    const auto& pattrs(pair.second);
                    sequence_size += (pattrs.size() > 1 ? pattrs.size() : 0);
                }

                utility::formatters::sequence_formatter sf(sequence_size);
                sf.postfix_configuration().last(" { }");
                sf.prefix_configuration().first(": ").not_first("  ");
                for (const auto& pair : o.inherited_attributes()) {
                    const auto pqn(ast.get_qualified_name(pair.first));
                    const auto& pattrs(pair.second);
                    if (pattrs.size() <= 1) {
#>
    <#= sf.prefix() #><#= pqn #>(<#= (pattrs.empty() ? "" : pattrs.front().name().simple()) #>)<#= sf.postfix() #>
<#+
                        sf.next();
                    } else {
#>
    <#= sf.prefix() #><#= pqn #>(<#= sf.postfix(true/*skip*/) #>
<#+
                        sf.next();
                        utility::formatters::sequence_formatter sf2(pattrs.size());
                        sf2.element_separator("");

                        sf2.prefix_configuration().first("  ").not_first("  ");
                        sf2.postfix_configuration().last(")");
                        for (const auto& attr : pattrs) {
#>
    <#= sf2.prefix() #><#= attr.name().simple() #><#= sf2.postfix() #><#= sf.postfix() #>
<#+
                            sf2.next();
                            sf.next();
                        }
                    }
                }

                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #>(<#= attr.name().simple() #>)<#= sf.postfix() #>
<#+
                    sf.next();
                }
            }

            /*
             * Visitation.
             */
            if (o.is_visitation_leaf()) {
                std::string bvn;
                std::string dvn;
                std::string rpn;
                if (o.derived_visitor()) {
                    bvn = ast.get_qualified_name(*o.base_visitor());
                    dvn = o.derived_visitor()->simple();
                    rpn = ast.get_qualified_name(o.root_parents().front());
                } else {
                    bvn = o.base_visitor()->simple();
                    rpn = o.root_parents().front().simple();
                }
#>

void <#= sn #>::accept(const <#= bvn #>& v) const {
<#+
                if (o.derived_visitor()) {
#>
    typedef const <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}

void <#= sn #>::accept(<#= bvn #>& v) const {
<#+
                if (o.derived_visitor()) {
#>
    typedef <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
    }

void <#= sn #>::accept(const <#= bvn #>& v) {
<#+
                if (o.derived_visitor()) {
#>
    typedef const <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}

void <#= sn #>::accept(<#= bvn #>& v) {
<#+
                if (o.derived_visitor()) {
#>
    typedef <#= dvn #>* derived_ptr;
    const auto dv(dynamic_cast<derived_ptr>(&v));
    if (dv)
        dv->visit(*this);
<#+
                } else {
#>
    v.visit(*this);
<#+
                }
#>
}
<#+
            }

            /*
             * Streaming
             */
            if (ast.is_io_enabled()) {
                if (o.in_inheritance_relationship()) {
#>

void <#= sn #>::to_stream(std::ostream& s) const {
<#+
                io::inserter_implementation_helper(ast, o, true/*inside_class*/);
#>
}
<#+
                }
            }

            /*
             * Swap
             */
            if (!o.is_immutable() && (!o.all_attributes().empty() || o.is_parent())) {
                const bool empty(o.all_attributes().empty() && o.parents().empty());
#>

void <#= sn #>::swap(<#= sn #>&<#= (empty ? "" : " other") #>)<#= ast.make_noexcept_keyword_text() #> {
<#+
               if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= pqn #>::swap(other);

<#+

               }

               if (!o.local_attributes().empty()) {
#>
    using std::swap;
<#+
                   for (const auto& attr : o.local_attributes())
#>
    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);
<#+
               }
#>
}
<#+
            }

            /*
             * Equals method
             */
            // FIXME: looking at root_parent as a hack due to service leafs not
            // FIXME: being processed atm.
            if (!o.is_parent() && !o.parents().empty() && !o.root_parents().empty()) {
                const auto rpn(o.root_parents().front());
#>

bool <#= sn #>::equals(const <#= ast.get_qualified_name(rpn) #>& other) const {
    const <#= sn #>* const p(dynamic_cast<const <#= sn #>* const>(&other));
    if (!p) return false;
    return *this == *p;
}
<#+
            }

            /*
             * Equals operator
             */
            std::string method_name;
            if (o.is_parent())
                method_name = "compare";
            else
                method_name = "operator==";
#>

bool <#= sn #>::<#= method_name #>(const <#= sn #>& <#= (o.all_attributes().empty() ? "/*rhs*/" : "rhs") #>) const {
<#+

            if (o.all_attributes().empty())
#>
    return true;
<#+
            else {
                utility::formatters::sequence_formatter sf(o.parents().size());
                sf.element_separator("");
                sf.prefix_configuration().first("return ").not_first("    ");
                sf.postfix_configuration().not_last(" &&");
                if (o.local_attributes().empty())
                    sf.postfix_configuration().last(";");
                else
                    sf.postfix_configuration().last(" &&");

                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= sf.prefix() #><#= pqn #>::compare(rhs)<#= sf.postfix() #>
<#+
                    sf.next();
                }
                sf.reset(o.local_attributes().size());
                sf.element_separator("");
                if (o.parents().empty())
                   sf.prefix_configuration().first("return ");
                else
                   sf.prefix_configuration().first("    ");
                sf.prefix_configuration().not_first("    ");
                sf.postfix_configuration().last(";").not_last(" &&");
                for (const auto& attr : o.local_attributes()) {
#>
    <#= sf.prefix() #><#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #><#= sf.postfix() #>
<#+
                    sf.next();
                }
            }
#>
}
<#+

            /*
             * Assignment
             */
            if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {
#>

<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {
    using std::swap;
    swap(*this, other);
    return *this;
}
<#+
            }

            /*
             * Getters and setters
             */
             for (const auto& attr : o.local_attributes()) {
                 if (attr.parsed_type().is_current_simple_type()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                    if (!o.is_immutable()) {
#>

<#= (attr.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {
    <#= attr.member_variable_name() #> = v;
<#+
                        if (attr.is_fluent()) {
#>
    return *this;
<#+
                        }
#>
}
<#+
                    }
                } else {
#>

const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                    if (!o.is_immutable()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {
    return <#= attr.member_variable_name() #>;
}

<#= (o.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {
    <#= attr.member_variable_name() #> = v;
<#+
                        if (o.is_fluent()) {
#>
    return *this;
<#+
                        }
#>
}
<#+
                        if (ast.supports_move_operator()) {
#>

<#= (o.is_fluent() ? sn + "&" : "void") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {
    <#= attr.member_variable_name() #> = std::move(v);
<#+
                            if (o.is_fluent()) {
#>
    return *this;
<#+
                            }
#>
}
<#+
                        }
                    }
                }
            }
#>

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** exception header                                               :element:
     :PROPERTIES:
     :custom_id: 81642A63-5B1C-F1E4-D14B-BB6565623745
     :masd.physical.logical_meta_element_id: dogen.logical.entities.exception
     :masd.wale.kvp.archetype.simple_name: exception_header
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for exceptions.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/exception.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/exception_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/exception_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void exception_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "exception header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::exception>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(ye.documentation());
#>
class <#= ye.name().simple() #> : public virtual std::exception, public virtual boost::exception {
public:
<#+
            if (ast.is_cpp_standard_98()) {
#>
    <#= ye.name().simple() #>() {}
    ~<#= ye.name().simple() #>() {}
<#+
            } else {
#>
    <#= ye.name().simple() #>() = default;
    ~<#= ye.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = default;
<#+
            }
#>

public:
    explicit <#= ye.name().simple() #>(const std::string& message) : message_(message) { }

public:
<#+
            if (ast.is_cpp_standard_98()) {
                // Note: we are using BOOST_NOEXCEPT here by design. The problem is
                // users may include this header in a C++ 98 project or in a C++ > 11 project;
                // and we need to have different behaviours. Depending on this inclusion.
                // If we do not, we will cause compilation errors when including C++ 98 code
                // on a C++ 11 project. This is because the standard library will have noexcept
                // but we won't (as we were generated for C++ 98), so we'd be weakening the exception
                // guarantees. By using the boost macro we will do the right thing hopefully.
                // And since we already need boost for exception, we should be ok.
#>
    const char* what() const BOOST_NOEXCEPT { return(message_.c_str()); }
<#+
            } else {
#>
    const char* what() const<#= ast.make_noexcept_keyword_text() #> { return(message_.c_str()); }
<#+
            }
#>

private:
    const std::string message_;
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: B42AAE2F-9E8F-E244-23CB-42EB67EA9989
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#+
            ast.comment(e.documentation());
            if (ast.is_cpp_standard_98()) {
#>
enum <#= ye.name().simple() #> {
<#+
            } else {
                if (ye.use_implementation_defined_underlying_element())
#>
enum class <#= ye.name().simple() #> {
<#+
                else
#>
enum class <#= ye.name().simple() #> : <#= ast.get_qualified_name(ye.underlying_element()) #> {
<#+
            }

            utility::formatters::sequence_formatter sf(ye.enumerators().size());
            for (const auto& en : ye.enumerators()) {
                if (ye.use_implementation_defined_enumerator_values())
#>
    <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                else
#>
    <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                sf.next();
            }
#>
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** visitor forward declarations                                   :element:
     :PROPERTIES:
     :custom_id: E120E29C-0203-80F4-72CB-7E61182E40D4
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visitor
     :masd.wale.kvp.archetype.simple_name: visitor_forward_declarations
     :masd.physical.relation_status: relatable
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: forward declaration
     :masd.physical.postfix: fwd
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates forward declarations for visitors.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/visitor.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/visitor_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/visitor_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void visitor_forward_declarations_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "visitor forward declarations",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::visitor>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= o.name().simple() #>;

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive implementation                                       :element:
     :PROPERTIES:
     :custom_id: 6886A681-8351-4B54-770B-CD6A663495DB
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto attr(p.value_attribute());

            /*
             * Default constructor.
             */
            if (ast.requires_manual_default_constructor()) {
#>

<#= sn #>::<#= sn #>()
    : <#= attr.member_variable_name() #>(static_cast<<#= ast.get_qualified_name(attr.parsed_type()) #>>(0)) { }
<#+
            }

            /*
             * Move constructor.
             */
            if (ast.requires_manual_move_constructor()) {
#>

<#= sn #>::<#= sn #>(<#= sn #>&& rhs)
    : <#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>)) { }
<#+
            }

            /*
             * Complete constructor.
             */
#>

<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)
    : <#= attr.member_variable_name() #>(<#= attr.name().simple() #>) { }

<#+
            /*
             * Getters and setters
             */
             if (attr.parsed_type().is_current_simple_type()) {
#>
<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}

<#+
                if (!p.is_immutable()) {
#>
void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {
    <#= attr.member_variable_name() #> = v;
}

<#+
                }
            } else {
#>
const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {
    return <#= attr.member_variable_name() #>;
}
<#+
                if (!p.is_immutable()) {
#>

<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {
    return <#= attr.member_variable_name() #>;
}

void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {
    <#= attr.member_variable_name() #> = v;
}

void <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {
    <#= attr.member_variable_name() #> = std::move(v);
}

<#+
                }
            }

            /*
             * Equality.
             */
#>
bool <#= sn #>::operator==(const <#= sn #>& rhs) const {
    return <#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #>;
}

<#+
            /*
             * Swap and assignment.
             */
            if (!p.is_immutable()) {
#>
void <#= sn #>::swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #> {
    using std::swap;
    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);
}

<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {
    using std::swap;
    swap(*this, other);
    return *this;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: B8CC048A-C2CF-42D4-695B-3457DC0F882D
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.label.roles: type_declaration
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** feature template bundle implementation                         :element:
     :PROPERTIES:
     :custom_id: FFC4D196-36AC-1F04-23D3-120B441442F4
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_template_bundle
     :masd.wale.kvp.archetype.simple_name: feature_template_bundle_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for feature templates.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.variability/types/helpers/enum_mapper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_template_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_template_bundle_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_template_bundle_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void feature_template_bundle_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature template bundle implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ftb(ast.as<logical::entities::variability::feature_template_bundle>(e));

    {
        const auto sn(ftb.name().simple());
        const auto qn(ast.get_qualified_name(ftb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(ftb));
        ast.add_helper_methods(ftb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(ftb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using namespace variability::helpers;
            using utility::string::splitter;

            if (ftb.generate_registration()) {
#>

namespace {
<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());
                    const bool has_qualified_name(simple_key != ft.key());
#>

dogen::variability::entities::feature_template
make_<#= ft.identifiable_key() #>() {
    using namespace dogen::variability::entities;
    feature_template r;
    r.name().simple("<#= simple_key #>");
<#+
                    if (has_qualified_name) {
#>
    r.name().qualified("<#= ft.key() #>");
<#+
                    }
#>
    r.description(R"(<#= ft.documentation() #>)");
    const auto vt(<#= enum_mapper::from_value_type(ft.value_type()) #>);
    r.value_type(vt);
    r.binding_point(<#= enum_mapper::from_binding_point(*ft.binding_point()) #>);
    r.instantiation_domain_name("<#= ftb.instantiation_domain_name() #>");
<#+

                    if (!ft.default_value().empty()) {
#>
    dogen::variability::helpers::value_factory f;
    r.default_value(f.make(vt, std::list<std::string>{ <#= ft.default_value() #> }));
<#+
                        for (const auto& dvo : ft.default_value_overrides()) {
#>
    r.default_value_overrides().push_back(
        default_value_override("<#= dvo.key_ends_with() #>",
            f.make(vt, std::list<std::string>{ <#= dvo.default_value() #> })));
<#+
                       }
                   }
#>
    return r;
}
<#+
                }
#>

}

<#+
            }

            if (ftb.generate_static_configuration()) {
#>
<#= sn #>::feature_group
<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {
    feature_group r;
    const dogen::variability::helpers::feature_selector s(fm);

<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());
#>
    r.<#= simple_key #> = s.get_by_name("<#= ft.key() #>");
<#+
                }
#>

    return r;
}

<#= sn #>::static_configuration <#= sn #>::make_static_configuration(
    const feature_group& fg,
    const dogen::variability::entities::configuration& cfg) {

    static_configuration r;
    const dogen::variability::helpers::configuration_selector s(cfg);
<#+
                for (const auto& ft : ftb.feature_templates()) {
                    const auto simple_key(splitter::split_scoped(ft.key()).back());

                    const bool has_default_value(!ft.default_value().empty());
                    if (has_default_value) {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);
<#+
                    } else if (ft.is_optional()) {
#>
    if (s.has_configuration_point(fg.<#= simple_key #>))
        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    } else {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    }
                }
#>
    return r;
}
<#+
            }

            if (ftb.generate_registration()) {

#>

std::list<dogen::variability::entities::feature_template>
<#= sn #>::make_templates() {
    using namespace dogen::variability::entities;
    std::list<dogen::variability::entities::feature_template> r;
<#+

                for (const auto& ft : ftb.feature_templates()) {
#>
    r.push_back(make_<#= ft.identifiable_key() #>());
<#+
                }
#>
    return r;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** feature bundle implementation                                  :element:
     :PROPERTIES:
     :custom_id: 6851D044-EFA3-6754-610B-7492838B5459
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_feature_bundle
     :masd.wale.kvp.archetype.simple_name: feature_bundle_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates implementation files for feature bundles.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/string/splitter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.variability/types/helpers/enum_mapper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/feature_bundle.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_bundle_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/feature_bundle_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void feature_bundle_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "feature bundle implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));

    {
        const auto sn(fb.name().simple());
        const auto qn(ast.get_qualified_name(fb.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(fb));
        ast.add_helper_methods(fb.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(fb.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            using namespace variability::helpers;
            using utility::string::splitter;

            if (fb.generate_registration()) {
#>

namespace {
<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());
                    const bool has_qualified_name(simple_key != f.key());
#>

dogen::variability::entities::feature
make_<#= f.identifiable_key() #>() {
    using namespace dogen::variability::entities;
    feature r;
    r.name().simple("<#= simple_key #>");
<#+
                   if (has_qualified_name) {
#>
    r.name().qualified("<#= f.key() #>");
<#+
                   }
#>
    r.description(R"(<#= f.documentation() #>)");
    const auto vt(<#= enum_mapper::from_value_type(f.value_type()) #>);
    r.value_type(vt);
<#+
                   if (f.unparsed_type() == "masd::variability::key_value_pair") {
#>
    r.is_partially_matchable(true);
<#+
                   }
#>
    r.binding_point(<#= enum_mapper::from_binding_point(*f.binding_point()) #>);
<#+
                   if (!f.default_value().empty()) {
#>
    dogen::variability::helpers::value_factory f;
    r.default_value(f.make(vt, std::list<std::string>{ <#= f.default_value() #> }));
<#+
                   }
#>
    return r;
}
<#+
                }
#>

}

<#+
            }

            if (fb.generate_static_configuration()) {
#>
<#= sn #>::feature_group
<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {
    feature_group r;
    const dogen::variability::helpers::feature_selector s(fm);

<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());
#>
    r.<#= simple_key #> = s.get_by_name("<#= f.key() #>");
<#+
                }
#>

    return r;
}

<#= sn #>::static_configuration <#= sn #>::make_static_configuration(
    const feature_group& fg,
    const dogen::variability::entities::configuration& cfg) {

    static_configuration r;
    const dogen::variability::helpers::configuration_selector s(cfg);
<#+
                for (const auto& f : fb.features()) {
                    const auto simple_key(splitter::split_scoped(f.key()).back());

                    const bool has_default_value(!f.default_value().empty());
                    if (has_default_value) {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);
<#+
                    } else if (f.is_optional()) {
#>
    if (s.has_configuration_point(fg.<#= simple_key #>))
        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    } else {
#>
    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);
<#+
                    }
                }
#>
    return r;
}
<#+
            }

            if (fb.generate_registration()) {
#>

std::list<dogen::variability::entities::feature>
<#= sn #>::make_features() {
    using namespace dogen::variability::entities;
    std::list<dogen::variability::entities::feature> r;
<#+

                for (const auto& f : fb.features()) {
#>
    r.push_back(make_<#= f.identifiable_key() #>());
<#+
                }
#>
    return r;
}

<#+
            }
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** variability initializer implementation                         :element:
     :PROPERTIES:
     :custom_id: 5CB6709A-8DB1-1DA4-2DB3-9406AB6581E6
     :masd.physical.logical_meta_element_id: dogen.logical.entities.variability_initializer
     :masd.wale.kvp.archetype.simple_name: variability_initializer_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates header files for feature bundles.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/variability/initializer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/variability_initializer_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/types/variability_initializer_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void variability_initializer_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "variability initializer implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::variability::initializer>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

void <#= sn #>::
register_entities(variability::helpers::registrar& rg) {
<#+
            for (const auto& n : o.feature_template_bundles())
#>
    rg.register_templates(<#= n.qualified().colon() #>::make_templates());
<#+
            if (!o.feature_bundles().empty()) {
                for (const auto& n : o.feature_bundles())
#>
    rg.register_features(<#= n.qualified().colon() #>::make_features());
<#+
            }
#>
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

*** hash                                                             :module:
    :PROPERTIES:
    :custom_id: 5AEC83CC-CF9F-60B4-F083-48F5A44094EC
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: hash
    :masd.physical.postfix: hash
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the hash facet of the
C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: C5B6A95F-5AEB-7D64-5EFB-4345D26A830C
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** date helper                                                    :element:
     :PROPERTIES:
     :custom_id: 0C5B1C9E-B1E5-B694-E2D3-29C191BCB74E
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: date_helper_transform
     :masd.wale.kvp.helper.family: BoostDate
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostDate
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/date_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void date_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    combine(seed, v.modjulian_day());
    return seed;
}
<#+
}
#>
#+end_src

**** ptime helper                                                   :element:
     :PROPERTIES:
     :custom_id: 54E6A7FF-4B4D-AB14-CE3B-4B28DEF9E4CF
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: ptime_helper_transform
     :masd.wale.kvp.helper.family: BoostPTime
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostPTime
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/ptime_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void ptime_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    const boost::posix_time::ptime epoch(boost::gregorian::date(1970, 1, 1));
    boost::posix_time::time_duration d(v - epoch);
    seed = static_cast<std::size_t>(d.total_seconds());
    return seed;
}
<#+
}
#>
#+end_src

**** associative container helper                                   :element:
     :PROPERTIES:
     :custom_id: E910AEA1-F225-A8F4-8DA3-B9D8464DD8A4
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: associative_container_helper_transform
     :masd.wale.kvp.helper.family: AssociativeContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: AssociativeContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/associative_container_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void associative_container_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());

    if (hp.direct_descendants().size() == 2) {
        const auto key(hp.direct_descendants().front());
        const auto value(hp.direct_descendants().back());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    for (const auto& i : v) {
<#+
        if (!key.requires_hashing_helper())
#>
        combine(seed, i.first);
<#+
        else
#>
        combine(seed, hash_<#= key.name_tree_identifiable() #>(i.first));
<#+

        if (!(value.requires_hashing_helper()))
#>
        combine(seed, i.second);
<#+
        else
#>
        combine(seed, hash_<#= value.name_tree_identifiable() #>(i.second));
    }
    return seed;
}
<#+
    } else {
        const auto containee(hp.direct_descendants().front());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    for (const auto& i : v) {
<#+
    if (!containee.requires_hashing_helper())
#>
        combine(seed, i);
<#+
    else
#>
        combine(seed, hash_<#= containee.name_tree_identifiable() #>(i));
    }
    return seed;
}
<#+
    }
}
#>
#+end_src

**** optional helper                                                :element:
     :PROPERTIES:
     :custom_id: B69C8EB2-EBCF-13E4-FB43-E1A24B6C630F
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: optional_helper_transform
     :masd.wale.kvp.helper.family: Optional
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: Optional
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/optional_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void optional_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);

    if (!v)
        return seed;

<#+
    if (!containee.requires_hashing_helper())
#>
    combine(seed, *v);
<#+
    else
#>
    combine(seed, hash_<#= containee.name_tree_identifiable() #>(*v));
    return seed;
}
<#+
}
#>
#+end_src

**** sequence container helper                                      :element:
     :PROPERTIES:
     :custom_id: 2E332E7C-1D53-9D04-8CFB-E79AC1B91FFF
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: sequence_container_helper_transform
     :masd.wale.kvp.helper.family: SequenceContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: SequenceContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/sequence_container_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void sequence_container_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    for (const auto& i : v) {
<#+
    if (!containee.requires_hashing_helper())
#>
        combine(seed, i);
<#+
    else
#>
        combine(seed, hash_<#= containee.name_tree_identifiable() #>(i));
    }
    return seed;
}
<#+
}
#>
#+end_src

**** variant helper                                                 :element:
     :PROPERTIES:
     :custom_id: BD6C2DA3-250A-1964-9543-27937EAAD328
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: variant_helper_transform
     :masd.wale.kvp.helper.family: BoostVariant
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostVariant
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/variant_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void variant_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto key(hp.direct_descendants().front());
    const auto value(hp.direct_descendants().back());
#>

struct <#= ident #>_visitor : public boost::static_visitor<> {
    <#= ident #>_visitor() : hash(0) {}
<#+
    for (const auto& dd : hp.direct_descendants()) {
#>
    void operator()(const <#= dd.name_qualified() #><#= (dd.is_simple_type() ? "" : "&") #> v) const {
<#+
        if (!dd.requires_hashing_helper())
#>
        combine(hash, v);
<#+
        else
#>
        combine(hash, hash_<#= dd.name_tree_identifiable() #>(v));
    }

<#+
    }
#>
    mutable std::size_t hash;
};

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    <#= ident #>_visitor vis;
    boost::apply_visitor(vis, v);
    return vis.hash;
}
<#+
}
#>
#+end_src

**** time duration helper                                           :element:
     :PROPERTIES:
     :custom_id: 3E8CE8A1-06D7-55C4-CF6B-D6085648F4A6
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: time_duration_helper_transform
     :masd.wale.kvp.helper.family: BoostTimeDuration
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostTimeDuration
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/time_duration_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void time_duration_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    seed = static_cast<std::size_t>(v.total_seconds());
    return seed;
}
<#+
}
#>
#+end_src

**** ptree helper                                                   :element:
     :PROPERTIES:
     :custom_id: 252795F1-3481-8294-F643-3017CCF08F8E
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: ptree_helper_transform
     :masd.wale.kvp.helper.family: BoostPTree
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostPTree
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/ptree_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void ptree_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    for (const auto& node : v) {
        combine(seed, node.first);
        combine(seed, node.second.data());
        combine(seed, hash_<#= ident #>(node.second));
    }

    return seed;
}
<#+
}
#>
#+end_src

**** pair helper                                                    :element:
     :PROPERTIES:
     :custom_id: 1F53F997-DD5F-5244-BD6B-478FBCAFBA9D
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: pair_helper_transform
     :masd.wale.kvp.helper.family: Pair
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: Pair
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/pair_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void pair_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto first(hp.direct_descendants().front());
    const auto second(hp.direct_descendants().back());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);

<#+
    if (!first.requires_hashing_helper())
#>
    combine(seed, v.first);
<#+
    else
#>
    combine(seed, hash_<#= first.name_tree_identifiable() #>(v.first));
<#+

    if (!second.requires_hashing_helper())
#>
    combine(seed, v.second);
<#+
    else
#>
    combine(seed, hash_<#= second.name_tree_identifiable() #>(v.second));
    return seed;
}
<#+
}
#>
#+end_src

**** smart pointer helper                                           :element:
     :PROPERTIES:
     :custom_id: 213560F4-B85A-7944-D0AB-929C2F0D8CFC
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: smart_pointer_helper_transform
     :masd.wale.kvp.helper.family: SmartPointer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: SmartPointer
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/smart_pointer_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void smart_pointer_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
<#+
    if (!containee.requires_hashing_helper())
#>
    combine(seed, *v);
<#+
    else
#>
    combine(seed, hash_<#= containee.name_tree_identifiable() #>(*v));
    return seed;
}
<#+
}
#>
#+end_src

**** path helper                                                    :element:
     :PROPERTIES:
     :custom_id: 59C24D28-17B2-E574-01E3-3EB863D1F920
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: path_helper_transform
     :masd.wale.kvp.helper.family: BoostPath
     :masd.wale.kvp.facet.qualified_name: masd.cpp.hash
     :masd.physical.helpers.family: BoostPath
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.hash.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.hash
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/path_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void path_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

inline std::size_t hash_<#= ident #>(const <#= qn #>& v) {
    std::size_t seed(0);
    combine(seed, v.generic_string());
    return seed;
}
<#+
}
#>
#+end_src

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: F430474F-7022-D1D4-4BC3-4A221DBFEFB4
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    const auto sn(o.name().simple());
    const auto qn(ast.get_qualified_name(o.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

struct <#= sn #>_hasher {
public:
    static std::size_t hash(const <#= sn #>& v);
};

<#+
        } // snf
#>

namespace std {

template<>
struct hash<<#= qn #>> {
public:
    size_t operator()(const <#= qn #>& v) const {
        return <#= qn #>_hasher::hash(v);
    }
};

}
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 5A4E8341-804A-3A24-9BF3-3537CB1C91BF
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace {

<#+
        if (!o.local_attributes().empty() || !o.parents().empty()) {
#>
template <typename HashableType>
inline void combine(std::size_t& seed, const HashableType& value) {
    std::hash<HashableType> hasher;
    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
<#+
        }

        ast.add_helper_methods(o.name().qualified().dot());
#>

}

<#+
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));

#>

std::size_t <#= sn #>_hasher::hash(const <#= sn #>&<#= ((o.local_attributes().empty() && o.parents().empty()) ? "" : " v") #>) {
    std::size_t seed(0);
<#+
            if (!o.parents().empty()) {
#>

<#+
                const auto& pn(o.parents().front());
                const auto pqn(ast.get_qualified_name(pn));
#>
    combine(seed, dynamic_cast<const <#= pqn #>&>(v));
<#+
            }

            if (!o.local_attributes().empty()) {
#>

<#+
                for (const auto& attr : o.local_attributes()) {
                    if (ast.requires_hashing_helper_method(attr))
#>
    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));
<#+
                    else
#>
    combine(seed, v.<#= attr.name().simple() #>());
<#+
                }

                if (o.local_attributes().size() > 1)
#>

<#+
            }
#>
    return seed;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: F2245764-7133-55D4-84AB-A718C66777E0
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace std {

template<>
struct hash<<#= ast.get_qualified_name(ye.name()) #>> {
public:
    size_t operator()(const <#= ast.get_qualified_name(ye.name()) #>& v) const {
        return std::hash<unsigned int>()(static_cast<unsigned int>(v));
    }
};

}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: ED36860B-162A-BB54-7A4B-4B157F8F7846
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: DFC72979-ACC9-2554-5BFB-E230353F034F
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

struct <#= sn #>_hasher {
public:
    static std::size_t hash(const <#= sn #>& v);
};

<#+
        } // snf
#>

namespace std {

template<>
struct hash<<#= qn #>> {
public:
    size_t operator()(const <#= qn #>& v) const {
        return <#= qn #>_hasher::hash(v);
    }
};

}
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** primitive implementation                                       :element:
     :PROPERTIES:
     :custom_id: 768FFDA7-223E-6304-0C0B-6C5F05DB87B8
     :masd.wale.kvp.containing_namespace: text.transforms.hash
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/hash/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

namespace {

template <typename HashableType>
inline void combine(std::size_t& seed, const HashableType& value) {
    std::hash<HashableType> hasher;
    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
<#+

        ast.add_helper_methods(p.name().qualified().dot());
#>

}

<#+
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(p.name().simple());
            const auto qn(ast.get_qualified_name(p.name()));
            const auto attr(p.value_attribute());
#>

std::size_t <#= sn #>_hasher::hash(const <#= sn #>& v) {
    std::size_t seed(0);
<#+
            if (ast.requires_hashing_helper_method(attr))
#>
    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));
<#+
            else
#>
    combine(seed, v.<#= attr.name().simple() #>());
    return seed;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** build                                                            :module:
    :PROPERTIES:
    :custom_id: 2586B163-9DB4-D954-D43B-D3E8DCF8A30D
    :masd.codec.dia.comment: true
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms related to build files.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: C55A8866-F497-7BA4-EBD3-80AFEABB4ADE
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** include cmakelists                                             :element:
     :PROPERTIES:
     :custom_id: A728BCC6-0507-D0E4-098B-A8161062B93F
     :masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
     :masd.wale.kvp.archetype.simple_name: include_cmakelists
     :masd.wale.kvp.meta_element: build_cmakelists
     :masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
     :masd.physical.part_id: masd.cpp.project
     :masd.wale.kvp.locator_function: make_full_path_for_include_cmakelists
     :masd.wale.kvp.containing_namespace: text.transforms.build
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: cmake
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates cmakelists for tests.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::build #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/build/include_cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/build/include_cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void include_cmakelists_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "include cmakelists",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {
        const auto ts(identification::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
#>
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.source_directory_name() #>)
<#+
       if (ast.is_tests_enabled()) {
#>
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.tests_directory_name() #>)
<#+
       }
#>

install(
    DIRECTORY <#= c.include_directory_path() #>/
    DESTINATION <#= c.include_directory_path() #>/
    COMPONENT headers
    FILES_MATCHING PATTERN "*.<#= c.header_file_extension() #>")
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** source cmakelists                                              :element:
     :PROPERTIES:
     :custom_id: 9C01482A-BCB5-4494-CD73-921AEFCA40F4
     :masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
     :masd.wale.kvp.archetype.simple_name: source_cmakelists
     :masd.wale.kvp.meta_element: build_cmakelists
     :masd.wale.kvp.meta_name_factory: logical::helpers::meta_name_factory
     :masd.physical.part_id: masd.cpp.project
     :masd.wale.kvp.locator_function: make_full_path_for_source_cmakelists
     :masd.wale.kvp.containing_namespace: text.transforms.build
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: cmake
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates cmakelists for tests.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::build #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/build/source_cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/build/source_cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void source_cmakelists_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "source cmakelists",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {
        const auto ts(identification::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_dot_separated_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
#>
set(name "<#= model_name #>")
set(lib_binary_name ${name})
set(lib_target_name ${name}.lib)

set(files "")
file(GLOB_RECURSE files RELATIVE
    "${CMAKE_CURRENT_SOURCE_DIR}/"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>")

<#+
        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {
#>
set(odb_files "")
file(GLOB_RECURSE odb_files RELATIVE
   "${CMAKE_CURRENT_SOURCE_DIR}/"
   "${CMAKE_CURRENT_SOURCE_DIR}/*.cxx")
set(files ${files} ${odb_files})

<#+
        }
#>
set(lib_files ${files})
add_library(${lib_target_name} ${lib_files})
set_target_properties(${lib_target_name} PROPERTIES
<#+
        if (ast.is_cpp_standard_98()) {
#>
    CXX_STANDARD 98
<#+
        }
#>
    OUTPUT_NAME ${lib_binary_name})

install(TARGETS ${lib_target_name}
    ARCHIVE DESTINATION lib
    LIBRARY DESTINATION lib
    COMPONENT libraries)
<#+
        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {
            const auto targets(c.odb_targets());
#>

#
# ODB Executable Targets
#
if (ODB_EXECUTABLE)
    # Top-level targets
    add_custom_target(<#= targets.main_target_name() #>)
    add_dependencies(odb_all <#= targets.main_target_name() #>)

    if (NOT ODB_EXECUTABLE_GLOBAL_ARGS)
        message(WARNING "ODB_EXECUTABLE_GLOBAL_ARGS not defined. Inclusion errors likely when running ODB targets.")
    endif()

<#+
            for (const auto& target : targets.targets()) {
#>

    add_custom_target(<#= target.name() #>
        COMMENT "<#= target.comment() #>"
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMAND ${ODB_EXECUTABLE}
            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= targets.common_odb_options() #>
            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.object_odb_options() #>
            --output-dir ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.output_directory() #>
            ${ODB_EXECUTABLE_GLOBAL_ARGS}
            ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.types_file() #>
<#+
                for (const auto& pair : target.move_parameters())
#>
        COMMAND mv ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.first #> ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.second #>
        VERBATIM
    )
    add_dependencies(<#= targets.main_target_name() #> <#= target.name() #>)
<#+
            }
#>
endif()
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** io                                                               :module:
    :PROPERTIES:
    :custom_id: 4F96B661-47B4-5314-52DB-68D7AE7BE7BA
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: io
    :masd.physical.postfix: io
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the io facet of the
C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 05AECAA8-804A-6FA4-6403-E31272C8261D
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** optional helper                                                :element:
     :PROPERTIES:
     :custom_id: 66560911-AC99-9DF4-8FBB-38D0E9D23323
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: optional_helper_transform
     :masd.wale.kvp.helper.family: Optional
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: Optional
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/optional_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void optional_helper_transform::
apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
        const auto n_qn(d.name_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
        const auto containee(hp.direct_descendants().front());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {
    s << "{ " << "\"__type__\": " << "\"<#= n_qn #>\"" << ", ";

    if (v)
        s << "\"data\": " << <#= streaming_for_type(containee, "*v") #>;
    else
        s << "\"data\": ""\"<null>\"";
    s << " }";
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** pair helper                                                    :element:
     :PROPERTIES:
     :custom_id: DE63EA7B-CDD9-2EA4-130B-3C9751C55B6E
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: pair_helper_transform
     :masd.wale.kvp.helper.family: Pair
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: Pair
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/pair_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void pair_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
        const auto n_qn(d.name_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
        const auto first(hp.direct_descendants().front());
        const auto second(hp.direct_descendants().back());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {
    s << "{ " << "\"__type__\": " << "\"<#= n_qn #>\"" << ", ";

    s << "\"first\": " << <#= streaming_for_type(first, "v.first") #> << ", ";
    s << "\"second\": " << <#= streaming_for_type(second, "v.second") #>;
    s << " }";
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** string helper                                                  :element:
     :PROPERTIES:
     :custom_id: 21377A0B-8715-71C4-797B-243DC6D936D9
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: string_helper_transform
     :masd.wale.kvp.helper.family: String
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: String
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/string_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void string_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& /*hp*/) const {
#>
inline std::string tidy_up_string(std::string s) {
    boost::replace_all(s, "\r\n", "<new_line>");
    boost::replace_all(s, "\n", "<new_line>");
    boost::replace_all(s, "\"", "<quote>");
    boost::replace_all(s, "\\", "<backslash>");
    return s;
}

<#+
}
#>
#+end_src

**** ptree helper                                                   :element:
     :PROPERTIES:
     :custom_id: 6C6A4D7B-195A-8094-9BD3-5BFFD4D85A7A
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: ptree_helper_transform
     :masd.wale.kvp.helper.family: BoostPTree
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: BoostPTree
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/ptree_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void ptree_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
#>

inline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {
    std::ostringstream ss;
    boost::property_tree::write_json(ss, v);

    std::string content(ss.str());
    boost::replace_all(content, "\r\n", "");
    boost::replace_all(content, "\n", "");

    s << content;
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** associative container helper                                   :element:
     :PROPERTIES:
     :custom_id: 39BC24EC-1CE5-E774-DED3-42AFECF1BE81
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: associative_container_helper_transform
     :masd.wale.kvp.helper.family: AssociativeContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: AssociativeContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/associative_container_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void associative_container_helper_transform::
apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto qn(d.name_tree_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));

        if (hp.direct_descendants().size() == 2) {
            const auto key(hp.direct_descendants().front());
            const auto value(hp.direct_descendants().back());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {
    s << "[";
    for (auto i(v.begin()); i != v.end(); ++i) {
        if (i != v.begin()) s << ", ";
        s << "[ { " << "\"__type__\": " << "\"key\"" << ", " << "\"data\": ";
        s << <#= streaming_for_type(key, "i->first") #>;
        s << " }, { " << "\"__type__\": " << "\"value\"" << ", " << "\"data\": ";
        s << <#= streaming_for_type(value, "i->second") #>;
        s << " } ]";
    }
    s << " ] ";
    return s;
}

<#+
        } else {
        const auto containee(hp.direct_descendants().front());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {
    s << "[ ";
    for (auto i(v.begin()); i != v.end(); ++i) {
        if (i != v.begin()) s << ", ";
        s << <#= streaming_for_type(containee, "*i") #>;
    }
    s << "] ";
    return s;
}

<#+
        }
    }
#>

<#+
}
#>
#+end_src

**** sequence container helper                                      :element:
     :PROPERTIES:
     :custom_id: DC70C1D2-2AB8-53B4-0BCB-6D18487F4D05
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: sequence_container_helper_transform
     :masd.wale.kvp.helper.family: SequenceContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: SequenceContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/sequence_container_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void sequence_container_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto qn(d.name_tree_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
        const auto containee(hp.direct_descendants().front());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {
    s << "[ ";
    for (auto i(v.begin()); i != v.end(); ++i) {
        if (i != v.begin()) s << ", ";
        s << <#= streaming_for_type(containee, "*i") #>;
    }
    s << "] ";
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** smart pointer helper                                           :element:
     :PROPERTIES:
     :custom_id: AC4D995E-1226-EF54-D0A3-97C6065EE1A3
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: smart_pointer_helper_transform
     :masd.wale.kvp.helper.family: SmartPointer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: SmartPointer
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/smart_pointer_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
        const auto n_qn(d.name_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
        const auto containee(hp.direct_descendants().front());
#>

inline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {
    s << "{ " << "\"__type__\": " << "\"<#= n_qn #>\"" << ", "
      << "\"memory\": " << "\"" << static_cast<void*>(v.get()) << "\"" << ", ";

    if (v)
        s << "\"data\": " << <#= streaming_for_type(containee, "*v") #>;
    else
        s << "\"data\": ""\"<null>\"";
    s << " }";
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** variant helper                                                 :element:
     :PROPERTIES:
     :custom_id: 9839D445-DA03-9554-F1A3-3AC243CD5431
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: variant_helper_transform
     :masd.wale.kvp.helper.family: BoostVariant
     :masd.wale.kvp.facet.qualified_name: masd.cpp.io
     :masd.physical.helpers.family: BoostVariant
     :masd.physical.helpers.owning_formatters: masd.cpp.io.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.io.primitive_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.types.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.io
     :masd.physical.helpers.owning_facets: masd.cpp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/variant_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void variant_helper_transform::apply(std::ostream& os, const logical::entities::model& m,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
        const auto n_qn(d.name_qualified());
        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));
#>

struct <#= d.name_tree_identifiable() #>_visitor : public boost::static_visitor<> {
    <#= d.name_tree_identifiable() #>_visitor(std::ostream& s) : stream_(s) {
        s << "{ " << "\"__type__\": " << "\"<#= d.name_qualified() #>\"" << ", ";
        s << "\"data\": ";
    }

    ~<#= d.name_tree_identifiable() #>_visitor() { stream_ << " }"; }
<#+
        for (const auto& dd : hp.direct_descendants()) {
#>

    void operator()(const <#= dd.name_qualified() #><#= (dd.is_simple_type() ? "" : "&") #> v) const {
<#+
            if (dd.is_simple_type()) {
#>
        stream_ << "{ " << "\"__type__\": " << "\"<#= dd.name_qualified() #>\"" << ", ";
        stream_ << "\"value\": ";
        stream_ << <#= streaming_for_type(dd, "v") #>;
        stream_ << " }";
<#+
            } else
#>
        stream_ << <#= streaming_for_type(dd, "v") #>;
    }
<#+
        }
#>

private:
    std::ostream& stream_;
};

inline std::ostream& operator<<(std::ostream& s, const <#= d.name_tree_qualified() #>& v) {
    boost::apply_visitor(<#= d.name_tree_identifiable() #>_visitor(s), v);
    return s;
}

<#+
    }
#>

<#+
}
#>
#+end_src

**** inserter implementation helper                                 :element:
     :PROPERTIES:
     :custom_id: 6B1C4B88-0741-4BB4-0F83-9309968C5F7E
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: 5A43F1A0-4F72-D984-A2C3-3E8F2BC96EDB
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto qn(ast.get_qualified_name(o.name()));
#>

std::ostream&
operator<<(std::ostream& s,
     const <#= qn #>& v);

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 58806A7B-3282-5DA4-712B-127189FCDDDE
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));
            const bool no_arg(!o.is_parent() && o.parents().empty() &&
                o.local_attributes().empty());
#>

std::ostream& operator<<(std::ostream& s, const <#= sn #>&<#= (no_arg ? "" : " v")  #>) {
<#+
            if (o.is_parent() || !o.parents().empty()) {
#>
    v.to_stream(s);
    return(s);
<#+
            } else
                io::inserter_implementation_helper(ast, o, false/*inside_class*/);
#>
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: 384E70E4-9598-8A74-FC83-4F75C48E41C6
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

std::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v);

<#+
         } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** enum implementation                                            :element:
     :PROPERTIES:
     :custom_id: 8F73636A-71E0-F5A4-176B-57901FBC9808
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_implementation_configuration
     :END:

Generates implementation files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

std::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v) {
    s << "{ " << "\"__type__\": " << "\"<#= ye.name().simple() #>\", " << "\"value\": ";

    std::string attr;
    switch (v) {
<#+
            for (const auto& en : ye.enumerators()) {
                if (ast.is_cpp_standard_98())
#>
    case <#= en.name().simple() #>:
<#+
                else
#>
    case <#= ye.name().simple() #>::<#= en.name().simple() #>:
        attr = "\"<#= en.name().simple() #>\"";
        break;
<#+
            }
#>
    default:
        throw std::invalid_argument("Invalid value for <#= ye.name().simple() #>");
    }
    s << attr << " }";
    return s;
}

<#+
         } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: 6F6E253B-1414-FA24-149B-3C771586E2C3
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto qn(ast.get_qualified_name(p.name()));
#>

std::ostream&
operator<<(std::ostream& s, const <#= qn #>& v);

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: 65A37337-3520-1154-31CB-0DED245D92EB
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** primitive implementation                                       :element:
     :PROPERTIES:
     :custom_id: 924A3F47-7566-2664-66DB-2730D0D2D2A7
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/io/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(p.name().qualified().dot());

        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(p.name().simple());
            const auto qn(ast.get_qualified_name(p.name()));
            const auto attr(p.value_attribute());
#>

std::ostream& operator<<(std::ostream& s, const <#= sn #>& v) {
<#+
            if (ast.requires_stream_manipulators()) {
#>
    boost::io::ios_flags_saver ifs(s);
    s.setf(std::ios_base::boolalpha);
    s.setf(std::ios::fixed, std::ios::floatfield);
    s.precision(6);
    s.setf(std::ios::showpoint);
<#+
            }

            const std::string variable_name = "v." + attr.getter_setter_name() + "()";
#>

    s << " { "
      << "\"__type__\": " << "\"<#= qn #>\"" << ", "
      << "\"<#= attr.name().simple() #>\": " << <#= ast.streaming_for_type(attr.parsed_type().current(), variable_name) #>
      << " }";

    return s;
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** visual studio                                                    :module:
    :PROPERTIES:
    :custom_id: 158F19B9-C59E-68B4-A283-F7CFBC9CCBE2
    :masd.codec.dia.comment: true
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms related to Visual Studio
support.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 95B6D190-0906-7C44-2D43-A76A1C024E0C
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** solution                                                       :element:
     :PROPERTIES:
     :custom_id: 3794E2E7-CA26-0E34-8A0B-D0FF163C6DD9
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_solution
     :masd.wale.kvp.archetype.simple_name: solution
     :masd.physical.part_id: masd.cpp.project
     :masd.wale.kvp.containing_namespace: text.transforms.visual_studio
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: sln
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates visual studio solutions.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/solution.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/solution_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/solution_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void solution_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "solution",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::visual_studio::solution;
    const auto& sln(ast.as<solution>(e));
#>
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
Project("{<#= ppb.type_guid() #>}") = "<#= ppb.name() #>", "<#= ppb.name() #>.csproj", "{<#= ppb.guid() #>}"
EndProject
<#+
    }
#>
Global
    GlobalSection(SolutionConfigurationPlatforms) = preSolution
        Debug|Any CPU = Debug|Any CPU
        Release|Any CPU = Release|Any CPU
    EndGlobalSection
    GlobalSection(ProjectConfigurationPlatforms) = postSolution
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU
<#+
    }
#>
    EndGlobalSection
    GlobalSection(MonoDevelopProperties) = preSolution
        StartupItem = CppModel.vcxroj
    EndGlobalSection
EndGlobal
<#+
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** msbuild targets                                                :element:
     :PROPERTIES:
     :custom_id: CC24D5F5-B24E-BF74-AD7B-4263788D417A
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_msbuild_targets
     :masd.wale.kvp.archetype.simple_name: msbuild_targets
     :masd.physical.part_id: masd.cpp.project
     :masd.wale.kvp.containing_namespace: text.transforms.visual_studio
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: xml
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates msbuild targets.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/msbuild_targets.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/msbuild_targets_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/msbuild_targets_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void msbuild_targets_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "msbuild targets",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::visual_studio::msbuild_targets;
    const auto& c(ast.as<msbuild_targets>(e));

    {
        const auto ts(identification::entities::technical_space::xml);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_identifiable_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
        const auto targets(c.odb_targets());
#>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">

    <!--[
        .NAME: odb.targets

        .SYNOPSIS:
            Generates all of the ODB files for this project.

        .DESCRIPTION:
            Calls the ODB compiler against each of the files in this Dogen model that require
            ODB compilation. Also moves the generated files to their correct location.

        .INPUTS:

        .OUTPUTS:
    ]-->
    <Target Name="<#= targets.main_target_name() #>"
<#+
            utility::formatters::sequence_formatter sf(targets.targets().size());
            sf.prefix_configuration().first("          DependsOnTargets=\"")
                                     .not_first("                            ");
            sf.postfix_configuration().last("\">");
            sf.element_separator(";");
            for (const auto& target : targets.targets()) {
#>
<#= sf.prefix() #><#= target.name() #><#= sf.postfix() #>
<#+
                sf.next();
            }
#>
        <Message Importance="high" Text="ODB <#= model_name #> "/>
    </Target>

<#+
            for (const auto& target : targets.targets()) {
#>
    <Target Name="<#= target.name() #>">
        <Message Importance="high" Text="<#= target.comment() #>"/>
        <Exec WorkingDirectory="$(OutputDirectory)" Command="&quot;$(OdbPath)&quot; -D_SECURE_SCL=0 $(OdbIncludeDirectories) --options-file $(MSBuildThisFileDirectory)<#= targets.common_odb_options() #> --options-file $(MSBuildThisFileDirectory)<#= target.object_odb_options() #> --output-dir $(MSBuildThisFileDirectory)<#= target.output_directory() #> $(MSBuildThisFileDirectory)<#= target.types_file() #>" />
<#+
                for (const auto& pair : target.move_parameters()) {
#>
        <Move
            SourceFiles="$(MSBuildThisFileDirectory)<#= pair.first #>"
            DestinationFolder="$(MSBuildThisFileDirectory)<#= pair.second #>" />
<#+
                }
#>
    </Target>
<#+
            }
#>
</Project>
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** project                                                        :element:
     :PROPERTIES:
     :custom_id: 0DCD4A35-540A-98F4-ECCB-45C6E94B3882
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_project
     :masd.wale.kvp.archetype.simple_name: project
     :masd.physical.part_id: masd.cpp.project
     :masd.wale.kvp.containing_namespace: text.transforms.visual_studio
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: xml
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates visual studio project.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/project.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/project_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/visual_studio/project_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void project_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "project",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::visual_studio::project;
    const auto& proj(ast.as<project>(e));

#>
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>
    <OutputType>Library</OutputType>
    <RootNamespace><#= proj.project_name() #></RootNamespace>
    <AssemblyName><#= proj.project_name() #></AssemblyName>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug</OutputPath>
    <DefineConstants>DEBUG;</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <ConsolePause>false</ConsolePause>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>full</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release</OutputPath>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <ConsolePause>false</ConsolePause>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
  </ItemGroup>
<#+
        for (const auto& ig : proj.item_groups()) {
#>
  <ItemGroup>
<#+
            for (const auto& i : ig.items())
#>
    <<#= i.name() #> Include="<#= i.include() #>" />
  </ItemGroup>
<#+
        }
#>
  <Import Project="$(MSBuildBinPath)\Microsoft.Cpp.targets" />
</Project>
<#+
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** serialization                                                    :module:
    :PROPERTIES:
    :custom_id: E2DA3C94-CBD0-7494-4A73-A53476F4AA1D
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: serialization
    :masd.physical.postfix: ser
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the boost serialisation
facet of the C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 301D982E-DEA9-84D4-B773-5B2799818290
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** path helper                                                    :element:
     :PROPERTIES:
     :custom_id: C9F290DB-5DC8-8984-60EB-EFC765AAE14F
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: path_helper_transform
     :masd.wale.kvp.helper.family: BoostPath
     :masd.wale.kvp.facet.qualified_name: masd.cpp.serialization
     :masd.physical.helpers.family: BoostPath
     :masd.physical.helpers.owning_formatters: masd.cpp.serialization.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.serialization.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.serialization
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/path_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void path_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    {
        const auto d(hp.current());
        const auto nt_qn(d.name_tree_qualified());
#>
namespace boost {
namespace serialization {

template<class Archive>
void serialize(Archive& ar, boost::filesystem::path& p, const unsigned int/*v*/)
{
    std::string s;
    if(Archive::is_saving::value)
        s = p.generic_string();
    ar & boost::serialization::make_nvp("path", s);
    if(Archive::is_loading::value)
        p = s;
}

} }
<#+
    }
}
#>
#+end_src

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: 14EA10DA-7092-50D4-EB4B-B19A0F5407C0
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));

        if (!o.is_parent() && !o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
namespace boost {

template<>struct
is_virtual_base_of<
    <#= pqn #>,
    <#= qn #>
> : public mpl::true_ {};

}
<#+
        }
#>

BOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)
<#+
        if (o.is_parent()) {
#>
BOOST_SERIALIZATION_ASSUME_ABSTRACT(<#= qn #>)

<#+
        }
#>
namespace boost {
namespace serialization {

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<typename Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** class forward declarations                                     :element:
     :PROPERTIES:
     :custom_id: 4627106A-B3CA-08C4-236B-A944E773CECD
     :masd.physical.logical_meta_element_id: dogen.logical.entities.object
     :masd.wale.kvp.archetype.simple_name: class_forward_declarations
     :masd.physical.relation_status: relatable
     :masd.wale.kvp.meta_element: object
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.physical.postfix: fwd
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates forward declarations for classes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_forward_declarations_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class forward declarations",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        const auto qn(ast.get_qualified_name(o.name()));
#>

namespace boost {
namespace serialization {

template<class Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<class Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: 519A2A39-EC61-EE64-A89B-21483070E9D2
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>
BOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)

namespace boost {
namespace serialization {

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<typename Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive forward declarations                                 :element:
     :PROPERTIES:
     :custom_id: CEC8D7D3-6678-0EC4-1FD3-19007B4C04F9
     :masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
     :masd.wale.kvp.archetype.simple_name: primitive_forward_declarations
     :masd.physical.relation_status: relatable
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.physical.postfix: fwd
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_configuration
     :END:

Generates forward declarations for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_forward_declarations_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_forward_declarations_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_forward_declarations_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive forward declarations",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(p));
        const auto qn(ast.get_qualified_name(p.name()));
#>

namespace boost {
namespace serialization {

template<class Archive>
void save(Archive& ar, const <#= qn #>& v, unsigned int version);

template<class Archive>
void load(Archive& ar, <#= qn #>& v, unsigned int version);

} }

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** type registrar header                                          :element:
     :PROPERTIES:
     :custom_id: 5C6EAE92-B565-0564-F493-7ABD99636550
     :masd.physical.logical_meta_element_id: dogen.logical.entities.serialization_type_registrar
     :masd.wale.kvp.archetype.simple_name: type_registrar_header
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::header_facet_default_configuration
     :END:

Generates header files for type registrars.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/serialization/type_registrar.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/type_registrar_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/type_registrar_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void type_registrar_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "type registrar header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(rg.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto sn(e.name().simple());
#>

class <#= sn #> {
public:

template<typename Archive>
static void register_types(Archive& ar);

};
<#+
        } // snf
#>

<#+

    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 66D29EEA-B1AE-39F4-5283-F1FAE04F01A2
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        ast.add_helper_methods(o.name().qualified().dot());

        const auto qn(ast.get_qualified_name(o.name()));
        const bool has_attributes(!o.local_attributes().empty());
        const bool has_parent(!o.parents().empty());
        const bool has_attributes_or_parent(has_attributes || has_parent);

        if (o.is_parent() || !o.parents().empty()) {
#>

BOOST_CLASS_TRACKING(
    <#= qn #>,
    boost::serialization::track_selectively)
<#+
        }
#>

namespace boost {
namespace serialization {
<#+

        /*
         * Save function
         */
#>

template<typename Archive>
void save(Archive& <#= (has_attributes_or_parent ? "ar" : "/*ar*/") #>,
    const <#= qn #>& <#= (has_attributes_or_parent ? "v" : "/*v*/") #>,
    const unsigned int /*version*/) {
<#+
        if (!o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
    ar << make_nvp("<#= pn.simple() #>", base_object<<#= pqn #>>(v));
<#+
        }

        if (has_attributes && has_parent)
#>

<#+
        for (const auto& attr : o.local_attributes()) {
#>
    ar << make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
<#+
        }
#>
}

<#+
        /*
         * Load function
         */
#>
template<typename Archive>
void load(Archive& <#= (has_attributes_or_parent ? "ar," : "/*ar*/,") #>
    <#= qn #>& <#= (has_attributes_or_parent ? "v" : "/*v*/") #>,
    const unsigned int /*version*/) {
<#+
        if (!o.parents().empty()) {
            const auto& pn(o.parents().front());
            const auto pqn(ast.get_qualified_name(pn));
#>
    ar >> make_nvp("<#= pn.simple() #>", base_object<<#= pqn #>>(v));
<#+
            if (has_attributes && has_parent)
#>

<#+
        }

        for (const auto& attr : o.local_attributes()) {
#>
    ar >> make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
<#+
        }
#>
}

} }

namespace boost {
namespace serialization {

template void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);

} }
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: DE7F2AFA-B7D5-8F34-F34B-EF209306DB8E
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** primitive implementation                                       :element:
     :PROPERTIES:
     :custom_id: 8ABE9397-0440-B8D4-64B3-962FA0444557
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto attr(p.value_attribute());
#>

namespace boost {
namespace serialization {
<#+

        /*
         * Save function
         */
#>

template<typename Archive>
void save(Archive& ar, const <#= qn #>& v, const unsigned int /*version*/) {
    ar << make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
}

<#+
        /*
         * Load function
         */
#>
template<typename Archive>
void load(Archive& ar, <#= qn #>& v, const unsigned int /*version*/) {
    ar >> make_nvp("<#= attr.name().simple() #>", v.<#= attr.member_variable_name() #>);
}

} }

namespace boost {
namespace serialization {

template void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);

template void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);
template void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);

} }
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: 73A58D46-6DE4-8164-FDEB-97E56A940E31
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>

template<class Archive>
void serialize(Archive& ar, <#= ast.get_qualified_name(ye.name()) #>& v, unsigned int /*version*/){
    using boost::serialization::make_nvp;
    ar & make_nvp("<#= ye.name().simple() #>", v);
}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** type registrar implementation                                  :element:
     :PROPERTIES:
     :custom_id: 42067B99-0668-0BA4-38BB-E7BFF7A3D04A
     :masd.physical.logical_meta_element_id: dogen.logical.entities.serialization_type_registrar
     :masd.wale.kvp.archetype.simple_name: type_registrar_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.serialization
     :masd.codec.stereotypes: masd::physical::archetype, dogen::implementation_configuration
     :END:

Generates header files for feature bundles.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/serialization/type_registrar.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/type_registrar_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/serialization/type_registrar_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void type_registrar_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
   tracing::scoped_transform_tracer stp(lg, "type registrar implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(rg.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const auto deps(rg.registrar_dependencies());
            const identification::entities::physical_meta_id carch("masd.cpp.types.canonical_archetype");
            const auto leaves(ast.names_with_enabled_archetype(carch, rg.leaves()));
            const bool has_types(!deps.empty() || !leaves.empty());
            const std::string arg_name(has_types ? " ar" : "");
            const auto sn(e.name().simple());
#>

template<typename Archive>
void <#= sn #>::register_types(Archive&<#= arg_name #>) {
<#+
            if (has_types) {
                for (const auto& d : deps) {
                    const auto dqn(ast.get_qualified_name(d));
#>
    <#= dqn #>::register_types(ar);
<#+
                }

                if (!deps.empty() && !leaves.empty())
#>

<#+
                for (const auto& l : leaves) {
                    const auto lqn(ast.get_qualified_name(l));
#>
    ar.template register_type<<#= lqn #>>();
<#+
                }
            }
#>
}

template void <#= sn #>::register_types(boost::archive::polymorphic_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::polymorphic_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::text_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::text_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::binary_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::binary_iarchive&<#= arg_name #>);

template void <#= sn #>::register_types(boost::archive::xml_oarchive&<#= arg_name #>);
template void <#= sn #>::register_types(boost::archive::xml_iarchive&<#= arg_name #>);

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

*** test data                                                        :module:
    :PROPERTIES:
    :custom_id: 3ABBA6C8-17B8-7084-F04B-A7CBD96CCA73
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: test_data
    :masd.physical.postfix: td
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the test data facet
of the C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: A409003A-107E-15B4-35DB-59CD290C3ED0
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** date helper                                                    :element:
     :PROPERTIES:
     :custom_id: 4DD5ACD8-89EE-3FF4-75CB-3030019BFA61
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: date_helper_transform
     :masd.wale.kvp.helper.family: BoostDate
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostDate
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/date_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void date_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(const unsigned int position) {
    const auto day(static_cast<unsigned short>(1 + (position % 27)));
    boost::gregorian::date r(2002, 2, day);
    return r;
}
<#+
}
#>
#+end_src

**** bool helper                                                    :element:
     :PROPERTIES:
     :custom_id: BF061380-B72D-21D4-C653-0CE3EE653ECC
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: bool_helper_transform
     :masd.wale.kvp.helper.family: Boolean
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Boolean
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/bool_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void bool_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& /*hp*/) const {
#>

bool create_bool(const unsigned int position) {
    return (position % 2) != 0;
}
<#+
}
#>
#+end_src

**** char helper                                                    :element:
     :PROPERTIES:
     :custom_id: B89D25C2-D780-2044-08A3-A2DF5EB8A235
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: char_helper_transform
     :masd.wale.kvp.helper.family: Character
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Character
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/char_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void char_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #> create_<#= ident #>(const unsigned int position) {
    const auto num(((position % 95) + 32) == 34 ? 35 : ((position % 95) + 32));
    return static_cast<<#= qn #>>(num);
}
<#+
}
#>
#+end_src

**** ptree helper                                                   :element:
     :PROPERTIES:
     :custom_id: 79DC90E2-9EE7-4094-658B-F20B90C7BC48
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: ptree_helper_transform
     :masd.wale.kvp.helper.family: BoostPTree
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostPTree
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/ptree_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void ptree_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(const unsigned int position) {
    using boost::property_tree::ptree;
    ptree c;
    c.put("key_2", position);
    ptree r;
    r.push_back(ptree::value_type("key_1", c));
    return r;
}
<#+
}
#>
#+end_src

**** associative container helper                                   :element:
     :PROPERTIES:
     :custom_id: 9C3FEE9B-E6D5-6F34-1C9B-A9D9208BC9AB
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: associative_container_helper_transform
     :masd.wale.kvp.helper.family: AssociativeContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: AssociativeContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/associative_container_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void associative_container_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #> create_<#= ident #>(unsigned int position) {
    <#= qn #> r;
    for (unsigned int i(0); i < 4; ++i) {
<#+
    if (hp.direct_descendants().size() == 1) {
        const auto containee(hp.direct_descendants().front());
#>
        r.insert(create_<#= containee.name_tree_identifiable() #>(position + i));
<#+
    } else if (hp.direct_descendants().size() == 2) {
        const auto key(hp.direct_descendants().front());
        const auto value(hp.direct_descendants().back());
#>
        r.insert(std::make_pair(create_<#= key.name_tree_identifiable() #>(position + i), create_<#= value.name_tree_identifiable() #>(position + i)));
<#+
    }
#>
    }
    return r;
}
<#+
}
#>
#+end_src

**** pair helper                                                    :element:
     :PROPERTIES:
     :custom_id: 1AF1F3EB-4C96-5B44-4E3B-66F7312A044A
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: pair_helper_transform
     :masd.wale.kvp.helper.family: Pair
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Pair
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/pair_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void pair_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto first(hp.direct_descendants().front());
    const auto second(hp.direct_descendants().back());
#>

<#= qn #>
create_<#= ident #>(unsigned int position) {
    <#= qn #> r(
        create_<#= first.name_tree_identifiable() #>(position),
        create_<#= second.name_tree_identifiable() #>(position));
    return r;
}
<#+
}
#>
#+end_src

**** number helper                                                  :element:
     :PROPERTIES:
     :custom_id: EBFB86D0-9D22-1FB4-6A7B-67BDA6C6BE21
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: number_helper_transform
     :masd.wale.kvp.helper.family: Number
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Number
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/number_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void number_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #> create_<#= ident #>(const unsigned int position) {
    return static_cast<<#= qn #>>(position);
}
<#+
}
#>
#+end_src

**** variant helper                                                 :element:
     :PROPERTIES:
     :custom_id: 419C8D20-4B57-7A64-3E13-2DABD164C4BB
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: variant_helper_transform
     :masd.wale.kvp.helper.family: BoostVariant
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostVariant
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/variant_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void variant_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(unsigned int position) {
    <#= qn #> r;

<#+
    unsigned int i(0);
    const auto size(hp.direct_descendants().size());
    for (const auto& dd : hp.direct_descendants()) {
        if (i == 0)
#>
    if (position == 0 || ((position % <#= size #>) == 0))
<#+
        else if (i == 1)
#>
    else if (position == 1 || ((position % <#= size + 1 #>) == 0))
<#+
        else
#>
    else if ((position % <#= i #>) == 0)
        r = create_<#= dd.name_tree_identifiable() #>(position);
<#+
        ++i;
    }
#>

    return r;
}
<#+
}
#>
#+end_src

**** path helper                                                    :element:
     :PROPERTIES:
     :custom_id: A922D7C0-573F-CC04-1CA3-AE2308CC5A6F
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: path_helper_transform
     :masd.wale.kvp.helper.family: BoostPath
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostPath
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/path_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void path_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(const unsigned int position) {
    std::ostringstream s;
    s << "/a/path/number_" << position;
    return <#= qn #>(s.str());
}
<#+
}
#>
#+end_src

**** ptime helper                                                   :element:
     :PROPERTIES:
     :custom_id: 22EBE07A-50E6-9004-1203-63EC48CFFFBD
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: ptime_helper_transform
     :masd.wale.kvp.helper.family: BoostPTime
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostPTime
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/ptime_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void ptime_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(const unsigned int position) {
    const auto day(static_cast<unsigned short>(1 + (position % 27)));
    using boost::gregorian::date;
    using boost::posix_time::ptime;
    using boost::posix_time::time_duration;
    date d(2002, 2, day);
    ptime r(d, time_duration(1,2,3));
    return r;
}
<#+
}
#>
#+end_src

**** optional helper                                                :element:
     :PROPERTIES:
     :custom_id: A1570E16-C8B3-D3B4-2C4B-E36B781BCBEB
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: optional_helper_transform
     :masd.wale.kvp.helper.family: Optional
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Optional
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/optional_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void optional_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

<#= qn #>
create_<#= ident #>(unsigned int position) {
    <#= qn #> r(
        create_<#= containee.name_tree_identifiable() #>(position));
    return r;
}
<#+
}
#>
#+end_src

**** smart pointer helper                                           :element:
     :PROPERTIES:
     :custom_id: 57E7E242-E222-A7C4-2F33-35A89A12758B
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: smart_pointer_helper_transform
     :masd.wale.kvp.helper.family: SmartPointer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: SmartPointer
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/smart_pointer_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

<#= qn #>
create_<#= ident #>(unsigned int position) {
    <#= qn #> r(
        create_<#= containee.name_tree_identifiable() #>(position));
    return r;
}
<#+
}
#>
#+end_src

**** sequence container helper                                      :element:
     :PROPERTIES:
     :custom_id: 89AB256C-6B9F-0974-9293-02C7BF757557
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: sequence_container_helper_transform
     :masd.wale.kvp.helper.family: SequenceContainer
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: SequenceContainer
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/sequence_container_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void sequence_container_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const auto containee(hp.direct_descendants().front());
#>

<#= qn #> create_<#= ident #>(unsigned int position) {
    <#= qn #> r;
    for (unsigned int i(0); i < 4; ++i) {
        r.push_back(create_<#= containee.name_tree_identifiable() #>(position + i));
    }
    return r;
}
<#+
}
#>
#+end_src

**** string helper                                                  :element:
     :PROPERTIES:
     :custom_id: 6B395CE8-A8A3-9584-A313-5378CA6A9EB2
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: string_helper_transform
     :masd.wale.kvp.helper.family: String
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: String
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/string_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void string_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& /*hp*/) const {
#>

std::string create_std_string(const unsigned int position) {
    std::ostringstream s;
    s << "a_string_" << position;
    return s.str();
}
<#+
}
#>
#+end_src

**** domain type helper                                             :element:
     :PROPERTIES:
     :custom_id: AFE63692-B6C8-00D4-73EB-86A0F60F07C0
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: domain_type_helper_transform
     :masd.wale.kvp.helper.family: Default
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: Default
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/domain_type_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void domain_type_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
    const bool is_pointer(d.is_pointer());
    const bool is_recursive(d.is_circular_dependency());

    if (is_recursive) {
#>

<#= qn #><#= (is_pointer ? "*" : "") #>
create_<#= ident #>(const unsigned int) {
<#+
        if (is_pointer) {
#>
    return nullptr;
<#+
        } else {
#>
    return <#= qn #>();
<#+
        }
#>
}
<#+
    } else {
#>

<#= qn #><#= (is_pointer ? "*" : "") #>
create_<#= ident #>(const unsigned int position) {
    return <#= qn #>_generator::create<#= (is_pointer ? "_ptr" : "") #>(position);
}
<#+
    }
}
#>
#+end_src

**** time duration helper                                           :element:
     :PROPERTIES:
     :custom_id: 05B316B0-3E42-0BD4-C683-32B0E8EA03B5
     :masd.physical.wale_template_reference: cpp_helper_transform_implementation_enabled
     :masd.wale.kvp.class.simple_name: time_duration_helper_transform
     :masd.wale.kvp.helper.family: BoostTimeDuration
     :masd.wale.kvp.facet.qualified_name: masd.cpp.test_data
     :masd.physical.helpers.family: BoostTimeDuration
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.class_implementation
     :masd.physical.helpers.owning_formatters: masd.cpp.test_data.primitive_implementation
     :masd.physical.helpers.owning_facets: masd.cpp.test_data
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/time_duration_helper_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void time_duration_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
    const auto ident(d.name_tree_identifiable());
#>

<#= qn #>
create_<#= ident #>(const unsigned int position) {
    unsigned int hour(position % 55);
    using boost::posix_time::time_duration;
    time_duration r(hour, 2, 3);
    return r;
}
<#+
}
#>
#+end_src

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: 72B12CA0-2D57-2474-5473-15D8E7AF0E0E
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto sn(o.name().simple());
            const auto qn(ast.get_qualified_name(o.name()));
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= sn #>_generator {
<#+
            if (!o.is_parent()) {
#>
public:
    <#= sn #>_generator();

<#+
            }
#>
public:
    typedef <#= qn #> result_type;

public:
<#+
            if (!o.is_immutable())
#>
    static void populate(const unsigned int position, result_type& v);
<#+
            if (!o.is_parent()) {
#>
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;
<#+
            }
#>
public:
    static result_type* create_ptr(const unsigned int position);
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: 18EBDD18-544C-7BF4-AD73-7FDC2D4E26B8
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= ye.name().simple() #>_generator {
public:
    <#= ye.name().simple() #>_generator();

public:
    typedef <#= ast.get_qualified_name(ye.name()) #> result_type;

public:
    static void populate(const unsigned int position, result_type& v);
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;
};

<#+
         } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: 23142B13-92D1-1534-E273-573876BCBBE3
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

class <#= sn #>_generator {
public:
    <#= sn #>_generator();

public:
    typedef <#= qn #> result_type;

public:
<#+
            if (!p.is_immutable())
#>
    static void populate(const unsigned int position, result_type& v);
    static result_type create(const unsigned int position);
    result_type operator()();

private:
    unsigned int position_;

public:
    static result_type* create_ptr(const unsigned int position);
};

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: 79604080-08CA-4304-8F83-601A18B74059
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 21CBEC01-8A80-3404-FF0B-2F3E30B508BE
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_implementation_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        if (!o.local_attributes().empty()) {
#>
namespace {
<#+
        ast.add_helper_methods(o.name().qualified().dot());
#>

}

<#+
        }

        {
            const auto ns(ast.make_namespaces(o.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
            if (!o.is_parent()) {
#>

<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }
<#+
            }

            /*
             * Populate method.
             */
            if (!o.is_immutable()) {
                bool no_args(o.local_attributes().empty() && o.parents().empty());
                if (no_args) {
#>

void <#= sn #>_generator::
populate(const unsigned int /*position*/, result_type& /*v*/) {
<#+
                } else {
#>

void <#= sn #>_generator::
populate(const unsigned int position, result_type& v) {
<#+
                }

                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
    <#= pqn #>_generator::populate(position, v);
<#+
                }
                unsigned int i(0);
                for (const auto& attr : o.local_attributes()) {
#>
    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= i #>));
<#+
                    ++i;
                }
#>
}
<#+
            }

            /*
             * Create method.
             */
            if (!o.is_parent()) {
                 const bool no_arg(o.all_attributes().empty());
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::create(const unsigned int<#= (no_arg ? "/*position*/" : " position") #>) {
<#+
                if (o.is_immutable()) {
#>
    return <#= sn #>(
<#+
                    if (o.local_attributes().empty())
#>

<#+
                    else {
                        utility::formatters::sequence_formatter sf(o.local_attributes().size());
                        for (const auto& attr : o.local_attributes()) {
#>
        create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= sf.current_position() #>)<#= sf.postfix() #>
<#+
                            sf.next();
                        }
                    }
#>
        );
<#+
                } else {
#>
    <#= sn #> r;
<#+
                    if (!o.all_attributes().empty())
#>
    <#= sn #>_generator::populate(position, r);
    return r;
<#+
                }
#>
}
<#+
            }

            /*
             * Create method ptr.
             */
#>

<#= sn #>_generator::result_type*
<#= sn #>_generator::create_ptr(const unsigned int position) {
<#+
            if (o.leaves().empty()) {
                if (o.is_immutable())
#>
    return new <#= sn #>(create(position));
<#+
                else {
#>
    <#= sn #>* p = new <#= sn #>();
    <#= sn #>_generator::populate(position, *p);
    return p;
<#+
                }
            } else {
                auto leaves(o.leaves());
                const auto front(leaves.front());
                leaves.pop_front();
                unsigned int i(0);
                const auto total(static_cast<unsigned int>(leaves.size()));
                for (const auto& l : leaves) {
#>
    if ((position % <#= total #>) == <#= i++ #>)
        return <#= ast.get_qualified_name(l) #>_generator::create_ptr(position);
<#+
                }
#>
    return <#= ast.get_qualified_name(front) #>_generator::create_ptr(position);
<#+
            }
#>
}
<#+
            /*
             * Function operator
             */
             if (!o.is_parent()) {
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::operator()() {
    return create(position_++);
}
<#+
            }
#>

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum implementation                                            :element:
     :PROPERTIES:
     :custom_id: 9A077B7A-CC3A-7264-E423-9A5E4D43B18C
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_implementation_configuration
     :END:

Generates implementation files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

<#= ye.name().simple() #>_generator::<#= ye.name().simple() #>_generator() : position_(0) { }
void <#= ye.name().simple() #>_generator::
populate(const unsigned int position, result_type& v) {
    v = static_cast<<#= ye.name().simple() #>>(position % <#= ye.enumerators().size() #>);
}

<#= ye.name().simple() #>_generator::result_type
<#= ye.name().simple() #>_generator::create(const unsigned int  position) {
    result_type r;
    <#= ye.name().simple() #>_generator::populate(position, r);
    return r;
}

<#= ye.name().simple() #>_generator::result_type
<#= ye.name().simple() #>_generator::operator()() {
    return create(position_++);
}

<#+
         } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive implementation                                       :element:
     :PROPERTIES:
     :custom_id: 3676A818-FE12-1F94-3FAB-172422F1AAA0
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_implementation_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/primitive_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/test_data/primitive_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    const auto sn(p.name().simple());
    const auto qn(ast.get_qualified_name(p.name()));
    {

        auto sbf(ast.make_scoped_boilerplate_formatter(e));
#>
namespace {
<#+
        ast.add_helper_methods(p.name().qualified().dot());
#>

}

<#+
        {
            const auto attr(p.value_attribute());
            const auto ns(ast.make_namespaces(p.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

            /*
             * Default constructor.
             */
#>

<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }
<#+
            /*
             * Populate method.
             */
            if (!p.is_immutable()) {
#>

void <#= sn #>_generator::
populate(const unsigned int position, result_type& v) {
    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));
}
<#+
            }

            /*
             * Create method.
             */
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::create(const unsigned int position) {
<#+
            if (p.is_immutable()) {
#>
    return <#= sn #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));
<#+
            } else {
#>
    <#= sn #> r;
    <#= sn #>_generator::populate(position, r);
    return r;
<#+
            }
#>
}
<#+
            /*
             * Create method ptr.
             */
#>

<#= sn #>_generator::result_type*
<#= sn #>_generator::create_ptr(const unsigned int position) {
<#+
            if (p.is_immutable())
#>
    return new <#= sn #>(create(position));
<#+
            else {
#>
    <#= sn #>* r = new <#= sn #>();
    <#= sn #>_generator::populate(position, *r);
    return r;
<#+
            }
#>
}
<#+
            /*
             * Function operator
             */
#>

<#= sn #>_generator::result_type
<#= sn #>_generator::operator()() {
    return create(position_++);
}

<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** tests                                                            :module:
    :PROPERTIES:
    :custom_id: 9F721FFB-3CC3-E214-66F3-6A891A2E7EAE
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: generated_tests
    :masd.physical.postfix: tests
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms that generate tests for
generated code, in the C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: B8FCE780-E14F-7344-38B3-8EB864C88942
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** class implementation                                           :element:
     :PROPERTIES:
     :custom_id: 96AF7AF0-AB84-DB04-FEEB-2B1FF9C00717
     :masd.physical.logical_meta_element_id: dogen.logical.entities.object
     :masd.wale.kvp.archetype.simple_name: class_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.tests
     :masd.codec.stereotypes: masd::physical::archetype, dogen::tests_configuration
     :END:

Generates tests for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/class_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/class_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(o));
        const auto qn(ast.get_qualified_name(o.name()));
        auto list(e.name().location().internal_modules());
        list.push_back(o.name().simple());
        const std::string test_suite_name(boost::join(list, "_"));

        std::string type_name("auto");
        if (ast.is_cpp_standard_98())
            type_name = qn;

#>
BOOST_AUTO_TEST_SUITE(<#= test_suite_name #>_tests)

<#+
        /*
         * If we have no attributes at all, we cannot test this
         * type. Similarly, if test data is not enabled, none of the
         * tests can be generated. In either case, we need to insert a
         * fake test for now. The real solution will be to filter
         * based on element state.
         */
        if (o.all_attributes().empty() || !ast.is_test_data_enabled()) {
            /*
             * No tests.
             */
#>
BOOST_AUTO_TEST_CASE(fake_test) {
    BOOST_CHECK(true);
}

<#+
        } else {
            /*
             * Types tests. These cannot be performed to parents as
             * they are abstract.
             */
            if (!o.is_parent()) {
#>
BOOST_AUTO_TEST_CASE(identical_objects_are_equal) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    BOOST_CHECK(a == b);
    BOOST_CHECK(b == a);
    BOOST_CHECK(!(a != b));
}

BOOST_AUTO_TEST_CASE(an_object_is_equal_to_itself) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    BOOST_CHECK(a == a);
    BOOST_CHECK(!(a != a));
}

BOOST_AUTO_TEST_CASE(distinct_objects_are_unequal) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    BOOST_CHECK(!(a == b));
    BOOST_CHECK(a != b);
}

<#+
                if (!o.is_immutable()) {
#>
BOOST_AUTO_TEST_CASE(assigning_an_object_to_itself_results_in_the_same_object) {
#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wself-assign-overloaded"
#endif
    <#= qn #>_generator g;
    <#= type_name #> a(g());
    const <#= type_name #> b(a);
    const <#= type_name #> c(g());

    a = a;
    BOOST_CHECK(a == b);
    BOOST_CHECK(a != c);
#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)
#pragma clang diagnostic pop
#endif
}

<#+
                }

                // FIXME: should be 11 or greater.
                if (!ast.is_cpp_standard_98()) {
#>
BOOST_AUTO_TEST_CASE(moved_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    <#= type_name #> a(g());
    const <#= type_name #> b = <#= qn #>();
    const <#= type_name #> c(a);
    BOOST_CHECK(a != b);
    BOOST_CHECK(a == c);

    const <#= type_name #> d = std::move(a);
    BOOST_CHECK(d == c);
    BOOST_CHECK(d != b);
}

<#+
                }

                if (!o.is_immutable()) {
#>
BOOST_AUTO_TEST_CASE(assigned_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    <#= qn #> b;
    BOOST_CHECK(a != b);

    b = a;
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(copy_constructed_objects_are_equal) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    <#= type_name #> b(a);
    BOOST_CHECK(a == b);

    b = <#= qn #>();
    BOOST_CHECK(a != b);
}

BOOST_AUTO_TEST_CASE(swapping_objects_results_in_the_expected_state) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    <#= type_name #> c(a);
    <#= type_name #> d(b);
    BOOST_CHECK(c == a);
    BOOST_CHECK(d == b);

    std::swap(c, d);
    BOOST_CHECK(c == b);
    BOOST_CHECK(d == a);
}

<#+
                }
            }

            if (ast.is_io_enabled()) {
                /*
                 * IO tests.
                 */
#>
BOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {
<#+
                if (o.is_parent()) {
#>
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));
    std::stringstream s;
    s << *a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
<#+
                } else {
#>
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    std::stringstream s;
    s << a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
<#+
                }
#>
}

<#+
            }

            if (ast.is_serialization_enabled()) {
                /*
                 * Serialization tests.
                 */
                 const auto registrar_qn(o.type_registrar() ?
                     ast.get_qualified_name(*o.type_registrar()) : std::string());

                if (o.is_parent()) {
#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_oarchive>(oa);
<#+
                    }
#>

        oa << BOOST_SERIALIZATION_NVP(a);
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_iarchive>(ia);
<#+
                    }
#>
        ia >> BOOST_SERIALIZATION_NVP(b);
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));

    using namespace boost::archive;
    std::ostringstream os;
    {
        binary_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    boost::shared_ptr<<#= qn #>> b;
    std::istringstream is(os.str());
    {
        binary_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_REQUIRE(a);
    BOOST_REQUIRE(b);
    BOOST_CHECK(*a == *b);
}

<#+
                } else {

#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_oarchive>(oa);
<#+
                    }
#>
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<xml_iarchive>(ia);
<#+
                    }
#>
        ia >> BOOST_SERIALIZATION_NVP(b);
    }

    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<text_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        binary_oarchive oa(os);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_oarchive>(oa);
<#+
                    }
#>
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        binary_iarchive ia(is);
<#+
                    if (o.type_registrar()) {
#>
        <#= registrar_qn #>::register_types<binary_iarchive>(ia);
<#+
                    }
#>
        ia >> b;
    }

    BOOST_CHECK(a == b);
}
<#+
                }
            }

            if (ast.is_hash_enabled() && !o.is_parent()) {
                /*
                 * hash tests.
                 */
#>
BOOST_AUTO_TEST_CASE(equal_objects_generate_the_same_hash) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) == hasher(b));
}

BOOST_AUTO_TEST_CASE(different_objects_generate_different_hashes) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) != hasher(b));
}

<#+
            }
        }
#>
BOOST_AUTO_TEST_SUITE_END()
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** main                                                           :element:
     :PROPERTIES:
     :custom_id: F2B04283-24B7-9284-4143-9157FBDB2986
     :masd.physical.logical_meta_element_id: dogen.logical.entities.entry_point
     :masd.wale.kvp.archetype.simple_name: main
     :masd.wale.kvp.containing_namespace: text.transforms.tests
     :masd.codec.stereotypes: masd::physical::archetype, dogen::tests_configuration
     :END:

Generates entry point for tests.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/entry_point.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/main_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/main_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void main_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "main",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::structural::entry_point;
    const auto& ep(ast.as<entry_point>(e));
    const auto qn(ast.get_qualified_name(ep.name()));
#>
#define BOOST_TEST_MODULE <#= qn #>

<#+
    {
        auto sbf(ast.make_scoped_boilerplate_formatter(ep));
#>

namespace  {

const std::string error_msg("Error during test.");

inline void translate(const boost::exception& e) {
    std::cerr << std::endl << boost::diagnostic_information(e);
    throw std::runtime_error(error_msg);
}

struct exception_fixture {
    exception_fixture() {
        using boost::exception;
        using boost::unit_test::unit_test_monitor;
        unit_test_monitor.register_exception_translator<exception>(&translate);
    }
};

}

BOOST_GLOBAL_FIXTURE(exception_fixture);
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum implementation                                            :element:
     :PROPERTIES:
     :custom_id: 02E1425A-82A1-3B24-F38B-B855EE6BE761
     :masd.physical.logical_meta_element_id: dogen.logical.entities.enumeration
     :masd.wale.kvp.archetype.simple_name: enum_implementation
     :masd.wale.kvp.containing_namespace: text.transforms.tests
     :masd.codec.stereotypes: masd::physical::archetype, dogen::tests_configuration
     :END:

Generates tests for enumeration.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/predef.h>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/enum_implementation_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/enum_implementation_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_implementation_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum implementation",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto qn(ast.get_qualified_name(e.name()));
        const auto sn(e.name().simple());
        std::string type_name("auto");
        if (ast.is_cpp_standard_98())
            type_name = qn;
#>
BOOST_AUTO_TEST_SUITE(<#= e.name().simple() #>_tests)

<#+
        /*
         * If test data is not enabled, none of the tests can be
         * generated. We need to insert a fake test for now. The real
         * solution will be to filter based on element state.
         */
        if (!ast.is_test_data_enabled()) {
            /*
             * No tests.
             */
#>
BOOST_AUTO_TEST_CASE(fake_test) {
    BOOST_CHECK(true);
}

<#+
        } else {
            if (ast.is_io_enabled()) {
                /*
                 * IO tests.
                 */
#>
BOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());
    std::stringstream s;
    s << a;

    boost::property_tree::ptree pt;
    BOOST_REQUIRE_NO_THROW(read_json(s, pt));
}

<#+
            }

            if (ast.is_lexical_cast_enabled()) {
                /*
                 * Lexical cast tests.
                 */
#>
BOOST_AUTO_TEST_CASE(casting_valid_strings_produces_expected_enumeration) {
    using <#= qn #>;
    <#= sn #> r;
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;
#>

    r = boost::lexical_cast<<#= sn #>>(std::string("<#= enu_sn #>"));
    BOOST_CHECK(r == <#= enu_qn #>);
    r = boost::lexical_cast<<#= sn #>>(std::string("<#= sn + "::" + enu_sn #>"));
    BOOST_CHECK(r == <#= enu_qn #>);
<#+
        }
#>
}

BOOST_AUTO_TEST_CASE(casting_invalid_string_throws) {
    using <#= qn #>;
    BOOST_CHECK_THROW(boost::lexical_cast<<#= sn #>>(std::string("DOGEN_THIS_IS_INVALID_DOGEN")),
        boost::bad_lexical_cast);
}

BOOST_AUTO_TEST_CASE(casting_valid_enumerations_produces_expected_strings) {
    using <#= qn #>;
    std::string r;
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;

#>

    r = boost::lexical_cast<std::string>(<#= enu_qn #>);
    BOOST_CHECK(r == "<#= sn + "::" + enu_sn #>");
<#+
        }
#>
}

BOOST_AUTO_TEST_CASE(casting_invalid_enumeration_throws) {
#if BOOST_COMP_GNUC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    using <#= qn #>;
    const <#= sn #> r(static_cast<<#= sn #>>(<#= enm.enumerators().size() + 10 #>));
#if BOOST_COMP_GNUC
#pragma GCC diagnostic pop
#endif
    BOOST_CHECK_THROW(boost::lexical_cast<std::string>(r),
        boost::bad_lexical_cast);
}

<#+
            }

            if (ast.is_serialization_enabled()) {
                /*
                 * Serialization tests.
                 */
#>
BOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
        ia >> BOOST_SERIALIZATION_NVP(b);
    }
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        xml_oarchive oa(os);
        oa << BOOST_SERIALIZATION_NVP(a);
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        xml_iarchive ia(is);
        ia >> BOOST_SERIALIZATION_NVP(b);
    }
    BOOST_CHECK(a == b);
}

BOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {
    <#= qn #>_generator g;
    const <#= type_name #> a(g());

    using namespace boost::archive;
    std::ostringstream os;
    {
        text_oarchive oa(os);
        oa << a;
    }

    <#= qn #> b = <#= qn #>();
    std::istringstream is(os.str());
    {
        text_iarchive ia(is);
        ia >> b;
    }
    BOOST_CHECK(a == b);
}

<#+
            }

             if (ast.is_hash_enabled()) {
                 /*
                  * hash tests.
                  */
#>
BOOST_AUTO_TEST_CASE(equal_enums_generate_the_same_hash) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(a);

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) == hasher(b));
}

BOOST_AUTO_TEST_CASE(different_enums_generate_different_hashes) {
    <#= qn #>_generator g;
    g();
    const <#= type_name #> a(g());
    const <#= type_name #> b(g());

    std::hash<<#= qn #>> hasher;
    BOOST_CHECK(hasher(a) != hasher(b));
}

<#+
            }
        }
#>
BOOST_AUTO_TEST_SUITE_END()
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** cmakelists                                                     :element:
     :PROPERTIES:
     :custom_id: 50DEDC82-A8E0-EEF4-4F5B-53F0CDEFEC7A
     :masd.physical.logical_meta_element_id: dogen.logical.entities.build_cmakelists
     :masd.wale.kvp.archetype.simple_name: cmakelists
     :masd.physical.part_id: masd.cpp.testing
     :masd.wale.kvp.containing_namespace: text.transforms.tests
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: cmake
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates cmakelists for tests.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/build/cmakelists.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/cmakelists_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/tests/cmakelists_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void cmakelists_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "cmakelists",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::build::cmakelists;
    const auto& c(ast.as<cmakelists>(e));

    {

        const auto ts(identification::entities::technical_space::cmake);
        ast.make_decoration_preamble(e, ts);
        const auto model_name(ast.get_dot_separated_model_name(c.name()));
        const auto product_name(ast.get_product_name(c.name()));
#>
set(name "<#= model_name #>")
set(lib_target_name ${name}.lib)
set(tests_binary_name ${name}.<#= c.tests_directory_name() #>)
set(tests_target_name ${name}.<#= c.tests_directory_name() #>)

set(files "")
file(GLOB_RECURSE files RELATIVE
    "${CMAKE_CURRENT_SOURCE_DIR}/"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>")

add_executable(${tests_target_name} ${files})

set_target_properties(${tests_target_name} PROPERTIES
<#+
        if (ast.is_cpp_standard_98()) {
#>
    CXX_STANDARD 98
<#+
        }
#>
    OUTPUT_NAME ${tests_binary_name})

<#+
        if (ast.is_cpp_standard_98()) {
#>
target_compile_options(${tests_target_name} PRIVATE
    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
    -Wno-c99-extensions>)
<#+
        }
#>

target_link_libraries(${tests_target_name}
    ${lib_target_name}
    ${CMAKE_REQUIRED_LIBRARIES}
    ${CMAKE_THREAD_LIBS_INIT}
    ${Boost_LIBRARIES})

set(command $<TARGET_FILE:${tests_target_name}> ${boost_test_parameters})

add_custom_target(run_${tests_target_name}
    COMMENT "Running ${tests_target_name}" VERBATIM
    COMMAND ${command}
    WORKING_DIRECTORY ${stage_bin_dir}
    DEPENDS ${tests_target_name})

add_dependencies(run_all_tests run_${tests_target_name})

add_boost_tests(${tests_binary_name} ${files})

install(TARGETS ${tests_target_name} RUNTIME DESTINATION bin COMPONENT tests)
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** odb                                                              :module:
    :PROPERTIES:
    :custom_id: A8E60B77-8030-4484-9BA3-69D01D3FE916
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: odb
    :masd.physical.postfix: odb
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the ODB facet of the
C++ technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 0306B879-5E7F-2B54-797B-4EAF9285CCFE
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** class header                                                   :element:
     :PROPERTIES:
     :custom_id: BCB90826-BB6B-6084-B113-27E3FB004F0D
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_header_configuration
     :END:

Generates header files for archetypes.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/class_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/class_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto sn(o.name().simple());
        const auto qn(ast.get_qualified_name(o.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));

        if (!o.orm_properties() || o.orm_properties()->odb_pragmas().empty()) {
#>
// class has no ODB pragmas defined.

<#+
        } else {
            {
                const auto ns(ast.make_namespaces(o.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

<#+
                for (const auto& pg : o.orm_properties()->odb_pragmas())
#>
<#= pg #>
<#+

                bool is_first(true);
                for (const auto& attr : o.local_attributes()) {
                    if (!attr.orm_properties() ||
                        attr.orm_properties()->odb_pragmas().empty())
                        continue;

                    const auto attr_level_pragmas(attr.orm_properties()->odb_pragmas());
                    for (const auto& pg : attr_level_pragmas) {
                        if (is_first)
#>

<#+
                        is_first = false;
#>
<#= pg #>
<#+
                    }
                }
#>

#endif

<#+
            }
#>

<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** builtin header                                                 :element:
     :PROPERTIES:
     :custom_id: F80A3BA0-1579-BB64-0CB3-2DA8B481F022
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_header_configuration
     :END:

Generates header files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/builtin_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/builtin_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: 0985EE3A-E08D-8034-757B-D45280810631
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(ye.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

#endif

<#+
        } // snf
#>

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive header                                               :element:
     :PROPERTIES:
     :custom_id: EC25BDBD-8EB7-1994-06CB-24C6A9517507
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_header_configuration
     :END:

Generates header files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/primitive_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/primitive_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        const auto sn(p.name().simple());
        const auto qn(ast.get_qualified_name(p.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        const auto attr(p.value_attribute());

        if (!p.orm_properties() || p.orm_properties()->odb_pragmas().empty()) {
#>
// class has no ODB pragmas defined.

<#+
        } else {
            {
                const auto ns(ast.make_namespaces(p.name()));
                auto snf(ast.make_scoped_namespace_formatter(ns));
#>

#ifdef ODB_COMPILER

<#+
                for (const auto& pg : p.orm_properties()->odb_pragmas())
#>
<#= pg #>
<#+

                bool is_first(true);
                if (p.value_attribute().orm_properties() &&
                    !p.value_attribute().orm_properties()->odb_pragmas().empty()) {
                    for (const auto& pg : p.value_attribute().orm_properties()->odb_pragmas()) {
                        if (is_first)
#>

<#+
                            is_first = false;
#>
<#= pg #>
<#+
                    }
#>

#endif

<#+
                }
            }
#>

<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** object odb options                                             :element:
     :PROPERTIES:
     :custom_id: BA100D4D-AE39-C854-9D3B-7A636DABB65E
     :masd.physical.logical_meta_element_id: dogen.logical.entities.object
     :masd.wale.kvp.class.simple_name: object_odb_options_transform
     :masd.wale.kvp.archetype.simple_name: object_odb_options
     :masd.physical.part_id: masd.cpp.implementation
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: odb
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates object options for odb.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/object_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/object_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void object_odb_options_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "object odb options",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));

    {
        const auto ts(identification::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!o.orm_properties()) {
#>

#
# class has no ODB options defined.
#
<#+
        } else {
            const auto ooo(o.orm_properties()->odb_options());
#>
# epilogue
--odb-epilogue <#= ooo.epilogue() #>

<#+
            if (!ooo.include_regexes().empty()) {
#>
# regexes
<#+
                for (const auto& regex : ooo.include_regexes())
#>
--include-regex <#= regex #>

# debug regexes
# --include-regex-trace

# make the header guards similar to dogen ones
--guard-prefix <#= ooo.header_guard_prefix() #>
<#+
            }
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** primitive odb options                                          :element:
     :PROPERTIES:
     :custom_id: 2EDD1174-8F58-8594-C35B-D90FC1E3D81C
     :masd.physical.logical_meta_element_id: dogen.logical.entities.primitive
     :masd.wale.kvp.archetype.simple_name: primitive_odb_options
     :masd.wale.kvp.meta_element: primitive
     :masd.physical.part_id: masd.cpp.implementation
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: odb
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates object options for odb.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/primitive_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/primitive_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_odb_options_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive odb options",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));

    {
        const auto ts(identification::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!p.orm_properties()) {
#>

#
# class has no ODB options defined.
#
<#+
        } else {
            const auto ooo(p.orm_properties()->odb_options());
#>
# epilogue
--odb-epilogue <#= ooo.epilogue() #>

<#+
            if (!ooo.include_regexes().empty()) {
#>
# regexes
<#+
                for (const auto& regex : ooo.include_regexes())
#>
--include-regex <#= regex #>

# debug regexes
# --include-regex-trace

# make the header guards similar to dogen ones
--guard-prefix <#= ooo.header_guard_prefix() #>
<#+
            }
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

**** common odb options                                             :element:
     :PROPERTIES:
     :custom_id: A4800066-492A-CA64-FB8B-5193606AC88C
     :masd.physical.logical_meta_element_id: dogen.logical.entities.orm_common_odb_options
     :masd.wale.kvp.archetype.simple_name: common_odb_options
     :masd.physical.part_id: masd.cpp.implementation
     :masd.wale.kvp.containing_namespace: text.transforms.odb
     :masd.physical.wale_template_reference: cpp_artefact_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: odb
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates object options for odb.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/orm/common_odb_options.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/common_odb_options_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/odb/common_odb_options_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void common_odb_options_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "common odb options",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::orm::common_odb_options;
    const auto& o(ast.as<common_odb_options>(e));

    {
        const auto ts(identification::entities::technical_space::odb);
        ast.make_decoration_preamble(e, ts);

        if (!ast.is_cpp_standard_98()) {
#>
# enable C++11
--std c++11

<#+
        }

        if (!o.sql_name_case().empty()) {
#>
# casing
--sql-name-case <#= o.sql_name_case() #>

<#+
        }

        if (o.databases().size() > 1) {
#>
# enable multi-database support
--multi-database static

<#+
        }

        if (!o.databases().empty()) {
#>
# target databases
<#+

            for (const auto& d : o.databases())
#>
--database <#= d #>

<#+
        }
#>
# use the boost profile
--profile boost

# generate queries and embedded schemas
--generate-query
--generate-schema
--schema-format embedded

# force odb extensions to be different from dogen ones just in case.
--ixx-suffix .ixx
--hxx-suffix .hxx
--cxx-suffix .cxx

# debug regexes
# --include-regex-trace
<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

*** lexical cast                                                     :module:
    :PROPERTIES:
    :custom_id: 45E30B3D-A7CC-7E94-176B-4EE77E3E8A13
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: lexical_cast
    :masd.physical.postfix: lx
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms related to conversions from
and to string.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 47DF87D1-E225-BA14-C023-D1619BB8A0A7
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** enum header                                                    :element:
     :PROPERTIES:
     :custom_id: 383345E3-A1F5-B8E4-EBB3-F1066639B701
     :masd.wale.kvp.containing_namespace: text.transforms.lexical_cast
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_header_configuration
     :END:

Generates header files for enumerations.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::lexical_cast #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/transformation_error.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/lexical_cast/enum_header_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/cpp/lexical_cast/enum_header_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_header_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum header",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));

    {
        auto sbf(ast.make_scoped_boilerplate_formatter(enm));
        const auto qn(ast.get_qualified_name(enm.name()));
        const auto sn(enm.name().simple());
#>

namespace boost {

template<>
inline std::string lexical_cast(const <#= qn #>& v) {
<#+
        if (!ast.is_cpp_standard_98()) {
#>
    using <#= qn #>;

<#+
        }
#>
    switch (v) {
<#+
        for (const auto& enu : enm.enumerators()) {
            const auto enu_sn(enu.name().simple());
            std::string enu_qn;
            if (ast.is_cpp_standard_98())
                enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
            else
                enu_qn = sn + "::" + enu_sn;
#>
    case <#= enu_qn #>:
        return "<#= sn + "::" + enu_sn #>";
<#+
        }
#>
    default:
        throw boost::bad_lexical_cast();
    }
}

template<>
inline <#= qn #> lexical_cast(const std::string & s) {
<#+
        if (!ast.is_cpp_standard_98()) {
#>
    using <#= qn #>;

<#+
        }

        for (const auto& enu : enm.enumerators()) {
           const auto enu_sn(enu.name().simple());
           std::string enu_qn;
           if (ast.is_cpp_standard_98())
               enu_qn = ast.get_qualified_namespace(enm.name()) + "::" + enu_sn;
           else
               enu_qn = sn + "::" + enu_sn;
#>
    if (s == "<#= enu_sn #>" || s == "<#= sn + "::" + enu_sn #>")
        return <#= enu_qn #>;
<#+
        }
#>
    throw boost::bad_lexical_cast();
}

}

<#+
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}

#>
#+end_src

*** initializer                                                     :element:
    :PROPERTIES:
    :custom_id: C3FBC246-A8D0-68F4-15CB-BFB879EF7E48
    :masd.codec.stereotypes: dogen::handcrafted::typeable
    :END:

*** project                                                         :element:
    :PROPERTIES:
    :custom_id: C6C50EA6-3FE7-F624-B253-4F43F7A8633A
    :masd.codec.stereotypes: masd::physical::part
    :END:

FIXME: to be removed.

**** external modules path contribution                           :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** model modules path contribution                              :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** facet path contribution                                      :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** requires relative path                                       :attribute:
     :PROPERTIES:
     :masd.codec.value: false
     :END:

** csharp                                                            :module:
   :PROPERTIES:
   :custom_id: 03427E17-29FA-83F4-849B-18A4A3FC83DF
   :masd.codec.dia.comment: true
   :masd.physical.backend_name: csharp
   :masd.physical.directory_name: cs
   :masd.physical.major_technical_space: csharp
   :masd.physical.technical_space: csharp
   :masd.codec.stereotypes: masd::physical::backend
   :END:

M2T transforms for the C# technical space.

Takes types in the logical model and creates text
representations of the these types according to the grammar
of the C# technical space.

*** archetype configuration                                         :element:
    :PROPERTIES:
    :custom_id: 01823B5B-0D53-4724-3323-F9745E339888
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.part id                                        :attribute:
     :PROPERTIES:
     :masd.codec.value: masd.csharp.implementation
     :END:

**** masd.physical.wale template reference                        :attribute:
     :PROPERTIES:
     :masd.codec.value: csharp_transform_implementation
     :END:

**** masd.physical.relation status                                :attribute:
     :PROPERTIES:
     :masd.codec.value: facet_default
     :END:

**** masd.physical.technical space                                :attribute:
     :PROPERTIES:
     :masd.codec.value: csharp
     :END:

*** primitive configuration                                         :element:
    :PROPERTIES:
    :custom_id: 4BE99BF7-2DCF-9434-7613-4ECA3565CADA
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::primitive_configuration
    :masd.codec.parent: transforms::csharp::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.primitive
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: primitive
     :END:

*** enumeration configuration                                       :element:
    :PROPERTIES:
    :custom_id: 6E2DF457-E7E9-1EE4-284B-B2C51F6DE61F
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::enumeration_configuration
    :masd.codec.parent: transforms::csharp::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.enumeration
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: enum
     :END:

*** object configuration                                            :element:
    :PROPERTIES:
    :custom_id: FCB0A43D-E70D-9854-E51B-3411DE1A4FA3
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::object_configuration
    :masd.codec.parent: transforms::csharp::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.object
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: class
     :END:

*** exception configuration                                         :element:
    :PROPERTIES:
    :custom_id: 11D3FFF2-317D-DEE4-50B3-F5A0A692DF35
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::exception_configuration
    :masd.codec.parent: transforms::csharp::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.exception
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: exception
     :END:

*** builtin configuration                                           :element:
    :PROPERTIES:
    :custom_id: CC5A3116-B9D1-1164-070B-75AB9FF14BED
    :masd.variability.binding_point: entity
    :masd.variability.stereotype: dogen::builtin_configuration
    :masd.codec.parent: transforms::csharp::archetype_configuration
    :masd.codec.stereotypes: masd::variability::profile
    :END:

Contains the configuration common to all archetypes.

**** masd.physical.logical meta element id                        :attribute:
     :PROPERTIES:
     :masd.codec.value: dogen.logical.entities.builtin
     :END:

**** masd.wale.kvp.archetype.simple name                          :attribute:
     :PROPERTIES:
     :masd.codec.value: builtin
     :END:

*** implementation                                                  :element:
    :PROPERTIES:
    :custom_id: 149E529B-6CA2-BFB4-8DB3-5A703C3D5181
    :masd.codec.stereotypes: masd::physical::part
    :END:

Contains the implementation files.

**** external modules path contribution                           :attribute:
     :PROPERTIES:
     :masd.codec.value: none
     :END:

**** model modules path contribution                              :attribute:
     :PROPERTIES:
     :masd.codec.value: as_path_components
     :END:

**** facet path contribution                                      :attribute:
     :PROPERTIES:
     :masd.codec.value: as_directories
     :END:

**** requires relative path                                       :attribute:
     :PROPERTIES:
     :masd.codec.value: false
     :END:

*** types                                                            :module:
    :PROPERTIES:
    :custom_id: FA24318D-DBCC-91C4-4543-5213A0E9D381
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: Types
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the types facet of
the C# technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 148B0A2A-4185-FF94-B24B-9A37385A9FEB
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** floating point number helper                                   :element:
     :PROPERTIES:
     :custom_id: DC7BAF9B-0757-48A4-8B13-4612872000F5
     :masd.physical.wale_template_reference: csharp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: floating_point_number_helper_transform
     :masd.wale.kvp.helper.family: FloatingPointNumber
     :masd.wale.kvp.facet.qualified_name: masd.csharp.types
     :masd.physical.helpers.family: FloatingPointNumber
     :masd.physical.helpers.owning_formatters: masd.csharp.types.class
     :masd.physical.helpers.owning_formatters: masd.csharp.types.primitive
     :masd.physical.helpers.owning_facets: masd.csharp.types
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/floating_point_number_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void floating_point_number_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
#>
        /// <summary>
        /// Compare floating point numbers, taking precision into account (<#= qn #> version).
        /// </summary>
        static private bool NearlyEqual(<#= qn #> lhs, <#= qn #> rhs)
        {
            <#= qn #> epsilon = Math.Max(Math.Abs(lhs), Math.Abs(rhs)) * <#= qn #>.Epsilon;
            return Math.Abs(lhs - rhs) <= epsilon;
        }
<#+
}
#>
#+end_src

**** class                                                          :element:
     :PROPERTIES:
     :custom_id: 5180B86B-F11A-A224-C69B-AAAABAC5F0A2
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/class_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/class_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    const auto id(e.name().qualified().dot());
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));
    {
        const auto sn(e.name().simple());
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            ast.comment(e.documentation(), 1/*indent*/);
            if (!o.in_inheritance_relationship() || !o.is_child()) {
#>
    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #>
<#+
            } else {
                const auto& pn(o.parents().front());
                const auto pqn(ast.get_qualified_name(pn));
#>
    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #> : <#= pqn #>
<#+
            }
#>
    {
<#+
            if (!o.local_attributes().empty()) {
                if (!o.helper_properties().empty())
                    ast.add_helper_methods(id);

                /*
                * Properties
                */
#>
        #region Properties
<#+
                for (const auto& attr : o.local_attributes()) {
                    ast.comment(attr.documentation(), 2/*indent*/);
#>
        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (o.is_immutable() ? "internal " : "") #>set; }
<#+
                }
#>
        #endregion

<#+
            }

            /*
             * Constructors.
             */
#>
        #region Constructors
        public <#= sn #>() { }
<#+
            if (!o.all_attributes().empty()) {
                const auto attr_count(o.all_attributes().size());
                if (attr_count == 1) {
                     const auto attr(*o.all_attributes().begin());
#>
        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)
<#+
                } else {
#>

        public <#= sn #>(
<#+
                    utility::formatters::sequence_formatter sf(attr_count);
                    sf.postfix_configuration().last(")");
                    for (const auto& attr : o.all_attributes()) {
#>
            <#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #><#= sf.postfix() #>
<#+
                        sf.next();
                    }
                }

                if (!o.parents().empty()) {
                    const auto& pair(*o.inherited_attributes().begin());
                    const auto& pattrs(pair.second);
                    const auto size(pattrs.size());

                    if (size == 0) {
#>
            : base()
<#+
                    } else if (size == 1) {
#>
            : base(<#= ast.make_argument_name(pattrs.front()) #>)
<#+
                    } else {
                        utility::formatters::sequence_formatter sf(size);
                        sf.postfix_configuration().last(")");
                        sf.prefix_configuration().first(",").not_first(",");
#>
            : base(
<#+
                        for (const auto& pattr : pattrs) {
#>
                <#= ast.make_argument_name(pattr) #><#= sf.postfix() #>
<#+
                            sf.next();
                        }
                    }
                }
#>
        {
<#+
                if (o.local_attributes().empty()) {
#>
            // no properties
<#+
                } else {
                    for (const auto& attr : o.local_attributes()) {
#>
            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;
<#+
                    }
                }
#>
        }
<#+
            }
#>
        #endregion

<#+
            /*
             * Equals
             */
#>
        #region Equality
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != GetType()) return false;

            var value = obj as <#= sn #>;
<#+
            if (o.local_attributes().empty()) {
                if (!o.parents().empty()) {
#>
            return (value != null && base.Equals(value));
<#+
                } else {
#>
            return value != null;
<#+
                }
            } else {
                if (!o.parents().empty()) {
#>
            if (value == null || !base.Equals(value)) return false;
<#+
                } else {
#>
            if (value == null) return false;
<#+
                }
#>

            return
<#+
                utility::formatters::sequence_formatter sf(o.local_attributes().size());
                sf.element_separator("");
                sf.postfix_configuration().not_last(" &&");
                sf.postfix_configuration().last(";");
                for (const auto& attr : o.local_attributes()) {
                    if (attr.parsed_type().is_current_simple_type()) {
                        if (attr.parsed_type().is_floating_point()) {
#>
                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>)<#= sf.postfix() #>
<#+
                        } else {
#>
                <#= attr.name().simple() #> == value.<#= attr.name().simple() #><#= sf.postfix() #>
<#+
                        }
                    } else {
#>
                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&
                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>)<#= sf.postfix() #>
<#+
                    }
                    sf.next();
                }
            }
#>
        }

        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)
        {
            if (Object.ReferenceEquals(lhs, rhs))
                return true;

            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);
        }

        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)
        {
            return !(lhs == rhs);
        }

        public override int GetHashCode()
        {
<#+
            if (o.local_attributes().empty()) {
#>
            return 0;
<#+
            } else {
#>
            unchecked
            {
                // Choose large primes to avoid hashing collisions
                const int HashingBase = (int) 2166136261;
                const int HashingMultiplier = 16777619;

                int hash = HashingBase;
<#+
                for (const auto& attr : o.local_attributes()) {
                    if (attr.parsed_type().is_current_simple_type()) {
#>
                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();
<#+
                    } else {
#>
                hash = (hash * HashingMultiplier) ^
                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);
<#+
                    }
                }
#>
                return hash;
            }
<#+
            }
#>
        }
        #endregion
<#+
            if (o.in_inheritance_relationship())
            {
#>

        #region Dumpers
<#+
                if (o.is_parent() && !o.is_child()) {
#>
        internal abstract string Dump();
<#+
                } else if (o.is_leaf()) {
#>
        internal override string Dump()
        {
            return <#= sn #>Dumper.Dump(this);
        }
<#+
                }
#>
        #endregion
<#+
        }
#>
    }
<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** exception                                                      :element:
     :PROPERTIES:
     :custom_id: 81020767-5D30-A484-C443-1420461E23B8
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::exception_configuration
     :END:

Generates implementation files for exceptions.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/exception.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/exception_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/exception_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void exception_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "exception",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            ast.comment(e.documentation(), 1/*indent*/);
#>
    public class <#= sn #>  : Exception
    {
        public <#= sn #>() { }
        public <#= sn #>(string message) : base(message) { }
        public <#= sn #>(string message, Exception inner) : base(message, inner) { }
    }
<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** builtin                                                        :element:
     :PROPERTIES:
     :custom_id: 38CBE7D4-2FB3-35C4-65AB-0366C9EE366F
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::builtin_configuration
     :END:

Generates implementation files for builtins.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/builtin.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/builtin_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/builtin_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void builtin_transform::
apply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "builtin",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    stp.end_transform(a);
}

#>
#+end_src

**** enum                                                           :element:
     :PROPERTIES:
     :custom_id: 7D8B2E7F-48CF-5F14-459B-54653C6ECF1E
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_configuration
     :END:

Generates implementation files for enums.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/enum_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/enum_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            ast.comment(e.documentation(), 1/*indent*/);
            if (ye.use_implementation_defined_underlying_element())
#>
    public enum <#= sn #>
<#+
            else
#>
    public enum <#= sn #> : <#= ast.get_qualified_name(ye.underlying_element()) #>
    {
<#+
            utility::formatters::sequence_formatter sf(ye.enumerators().size());
            for (const auto& en : ye.enumerators()) {
                if (ye.use_implementation_defined_enumerator_values())
#>
        <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                else
#>
        <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>
<#+
                sf.next();
            }
#>
    }
<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** primitive                                                      :element:
     :PROPERTIES:
     :custom_id: E178210E-AE62-FF34-BC5B-550987101A4F
     :masd.wale.kvp.containing_namespace: text.transforms.types
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<iostream> #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/primitive_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/types/primitive_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    const auto id(e.name().qualified().dot());
    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));
    {
        const auto sn(e.name().simple());
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            ast.comment(e.documentation(), 1/*indent*/);
#>
    public sealed class <#= sn #>
    {
<#+
            if (!p.helper_properties().empty())
                ast.add_helper_methods(id);

            /*
             * Properties
             */
#>
        #region Properties
<#+
            const auto& attr(p.value_attribute());
            ast.comment(attr.documentation(), 2/*indent*/);
#>
        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (p.is_immutable() ? "internal " : "") #>set; }
        #endregion

<#+
            /*
             * Constructors.
             */
#>
        #region Constructors
        public <#= sn #>() { }
        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)
        {
            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;
        }
        #endregion

<#+
            /*
             * Equals
             */
#>
        #region Equality
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != GetType()) return false;

            var value = obj as <#= sn #>;
            if (value == null) return false;
            return
<#+
             if (attr.parsed_type().is_current_simple_type()) {
                if (attr.parsed_type().is_floating_point()) {
#>
                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>);
<#+
                } else {
#>
                <#= attr.name().simple() #> == value.<#= attr.name().simple() #>;
<#+
                }
           } else {
#>
                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&
                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>);
<#+
            }
#>
        }

        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)
        {
            if (Object.ReferenceEquals(lhs, rhs))
                return true;

            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);
        }

        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)
        {
            return !(lhs == rhs);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                // Choose large primes to avoid hashing collisions
                const int HashingBase = (int) 2166136261;
                const int HashingMultiplier = 16777619;

                int hash = HashingBase;
<#+
                if (attr.parsed_type().is_current_simple_type()) {
#>
                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();
<#+
                } else {
#>
                hash = (hash * HashingMultiplier) ^
                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);
<#+
                }
#>
                return hash;
            }
        }
        #endregion
    }
<#+
        } // snf
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** io                                                               :module:
    :PROPERTIES:
    :custom_id: C1B8A64F-631E-C934-1B93-E300FBC8949A
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: Dumpers
    :masd.physical.postfix: Dumper
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the io facet of the
C# technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 72578C26-2D5E-5024-917B-69AC2FC25370
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** enumerable helper                                              :element:
     :PROPERTIES:
     :custom_id: 416CFB3F-4AC7-E024-CD0B-2E047D8BBF93
     :masd.physical.wale_template_reference: csharp_helper_transform_implementation
     :masd.wale.kvp.class.simple_name: enumerable_helper_transform
     :masd.wale.kvp.helper.family: Enumerable
     :masd.wale.kvp.facet.qualified_name: masd.csharp.io
     :masd.physical.helpers.family: Enumerable
     :masd.physical.helpers.owning_formatters: masd.io.types.class
     :masd.physical.helpers.owning_formatters: masd.io.types.primitive
     :masd.physical.helpers.owning_facets: masd.csharp.io
     :masd.codec.stereotypes: masd::physical::helper
     :END:

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=os #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/helper_properties.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/enumerable_helper_transform.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enumerable_helper_transform::
apply(std::ostream& os, const logical::entities::model& /*m*/,
    const logical::entities::helper_properties& hp) const {
    const auto d(hp.current());
    const auto qn(d.name_tree_qualified());
#>
        /// <summary>
        /// </summary>
        static private bool NearlyEqual(<#= qn #> lhs, <#= qn #> rhs)
        {
            <#= qn #> epsilon = Math.Max(Math.Abs(lhs), Math.Abs(rhs)) * <#= qn #>.Epsilon;
            return Math.Abs(lhs - rhs) <= epsilon;
        }
<#+
}
#>
#+end_src

**** class                                                          :element:
     :PROPERTIES:
     :custom_id: 1B722C42-2F64-2DD4-9373-C1829FEC8DBB
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/class_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/class_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "class",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const bool has_attributes(!o.local_attributes().empty());
#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>Dumper
    {
        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)
        {
            assistant.IncrementDepth();
            if (assistant.MaximumDepthExceeded())
                return;

            assistant.AddStartObject();
            assistant.AddType("<#= qn #>", true/*withSeparator*/);
            if (value == null)
            {
                assistant.Add("data", "<null>");
                assistant.AddEndObject();
                return;
            }

            assistant.AddKey("data");
            assistant.AddPairSeparator();
            assistant.AddStartObject();
<#+
                if (!o.parents().empty()) {
                    const auto& pn(o.parents().front());
                    const auto pqn(ast.get_qualified_name(pn));
#>
            assistant.AddKey("__parent_0__");
            assistant.AddPairSeparator();
            <#= pqn #>Dumper.Dump(assistant, value<#= (has_attributes ? ", true/*withSeparator*/" : "") #>);
<#+
                }

                utility::formatters::sequence_formatter sf(o.local_attributes().size());
                sf.element_separator("");
                sf.postfix_configuration().not_last(", true/*withSeparator*/");
                sf.postfix_configuration().last("");

                for (const auto& attr : o.local_attributes()) {
                    const auto oap(ast.get_assistant_properties(attr));
                    if (oap && oap->requires_assistance()) {
#>
            assistant.Add("<#= attr.name().simple() #>", value.<#= attr.name().simple() #><#= sf.postfix() #>);
<#+
                    } else {
                        const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));
#>
            assistant.AddKey("<#= attr.name().simple() #>");
            assistant.AddPairSeparator();
            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #><#= sf.postfix() #>);
<#+
                    }

                    sf.next();
                }
#>
            assistant.AddEndObject(); // data
            assistant.AddEndObject(); // main object
            assistant.HandleMemberSeparator(withSeparator);

            assistant.DecrementDepth();
        }

        public static string Dump(<#= sn #> value)
        {
<#+
                if (o.is_parent()) {
#>
            return value.Dump();
<#+
                } else {
#>
            var assistant = new AssistantDumper();
            Dump(assistant, value);
            return assistant.ToString();
<#+
                }
#>
        }
    }
<#+
        }
    } // sbf

    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum                                                           :element:
     :PROPERTIES:
     :custom_id: FB368656-F30D-D664-E6AB-3EE0D250A62D
     :masd.wale.kvp.containing_namespace: text.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_configuration
     :END:

Generates implementation files for enums.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/enum_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/enum_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
   tracing::scoped_transform_tracer stp(lg, "enum",
       transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>Dumper
    {
        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)
        {
            assistant.IncrementDepth();
            if (assistant.MaximumDepthExceeded())
                return;

            assistant.AddStartObject();
            assistant.AddType("<#= qn #>", true/*withSeparator*/);
            string valueAsString = "Unsupported Value";
            switch (value)
            {
<#+
            for (const auto& en : ye.enumerators()) {
#>
                case <#= ye.name().simple() #>.<#= en.name().simple() #>:
                    valueAsString = "<#= en.name().simple() #>";
                    break;
<#+
            }
#>
            }

            assistant.Add("value", valueAsString);
            assistant.AddEndObject();

            assistant.DecrementDepth();
        }

        public static string Dump(<#= sn #> value)
        {
            var assistant = new AssistantDumper();
            Dump(assistant, value);
            return assistant.ToString();
        }
    }
<#+
        }
    } // sbf

    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** primitive                                                      :element:
     :PROPERTIES:
     :custom_id: C6BA95A9-E8C0-EFA4-F543-37C06693827B
     :masd.wale.kvp.containing_namespace: text.csharp.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/primitive_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/primitive_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>Dumper
    {
        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)
        {
            assistant.IncrementDepth();
            if (assistant.MaximumDepthExceeded())
                return;

            assistant.AddStartObject();
            assistant.AddType("<#= qn #>", true/*withSeparator*/);
            if (value == null)
            {
                assistant.Add("data", "<null>");
                assistant.AddEndObject();
                return;
            }

            assistant.AddKey("data");
            assistant.AddPairSeparator();
            assistant.AddStartObject();
<#+
            const auto attr(p.value_attribute());
            const auto oap(ast.get_assistant_properties(attr));
            if (oap && oap->requires_assistance()) {
#>
            assistant.Add("<#= attr.name().simple() #>", value.<#= attr.name().simple() #>);
<#+
            } else {
                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));
#>
            assistant.AddKey("<#= attr.name().simple() #>");
            assistant.AddPairSeparator();
            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #>;
<#+
            }
#>
            assistant.AddEndObject(); // data
            assistant.AddEndObject(); // main object
            assistant.HandleMemberSeparator(withSeparator);

            assistant.DecrementDepth();
        }

        public static string Dump(<#= sn #> value)
        {
            var assistant = new AssistantDumper();
            Dump(assistant, value);
            return assistant.ToString();
        }
    }
<#+
        }
    } // sbf

    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** assistant                                                      :element:
     :PROPERTIES:
     :custom_id: F1F650EA-1B54-7194-9F4B-B78154AA2DAD
     :masd.physical.logical_meta_element_id: dogen.logical.entities.assistant
     :masd.wale.kvp.archetype.simple_name: assistant
     :masd.wale.kvp.containing_namespace: text.csharp.transforms.io
     :masd.codec.stereotypes: masd::physical::archetype, dogen::archetype_configuration
     :END:

Generates implementation files for assistants.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/assistant_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/io/assistant_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void assistant_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "assistant",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;
using System.Text;
using System.Collections;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>
    class <#= sn #>Dumper
    {
        #region Properties
        private readonly StringBuilder _stringBuilder;
        private int _currentDepth;

        private const uint MaxDepth = 1000;
        private const string HashCode = "HashCode";
        private const string Type = "__type__";
        private const string StringType = "string";
        private const string ByteType = "byte";
        private const string SByteType = "sbyte";
        private const string IntType = "int";
        private const string UIntType = "uint";
        private const string LongType = "long";
        private const string ULongType = "ulong";
        private const string FloatType = "float";
        private const string DoubleType = "double";
        private const string CharType = "char";
        private const string DecimalType = "decimal";
        private const string BoolType = "bool";
        private const string NullValue = "<null>";
        private const string SystemObjectType = "System.Object";
        private const string KeyType = "key";
        private const string ValueType = "value";
        private const string DataKey = "data";
        #endregion

        #region Depth management
        public void IncrementDepth()
        {
            ++_currentDepth;
        }

        public void DecrementDepth()
        {
            ++_currentDepth;
        }

        public bool MaximumDepthExceeded()
        {
            return _currentDepth > MaxDepth;
        }
        #endregion

        #region Adds for JSON syntax
        public void AddStartObject()
        {
            _stringBuilder.Append("{ ");
        }

        public void AddEndObject()
        {
            _stringBuilder.Append(" }");
        }

        public void AddStartArray()
        {
            _stringBuilder.Append("[ ");
        }

        public void AddEndArray()
        {
            _stringBuilder.Append(" ]");
        }

        public void AddPairSeparator()
        {
            _stringBuilder.Append(" : ");
        }

        public void AddMemberSeparator()
        {
            _stringBuilder.Append(", ");
        }

        public void AddQuoted(string value)
        {
            if (value == null)
                _stringBuilder.Append("\"<null>\"");
            else
                _stringBuilder.Append("\"" + value + "\"");
        }

        public void AddNonQuoted(int value)
        {
            _stringBuilder.Append(Convert.ToString(value));
        }

        public void AddKey(string k)
        {
            AddQuoted(k);
        }

        public void AddType(string typeName, bool withSeparator = false)
        {
            AddKey(Type);
            AddPairSeparator();
            AddQuoted(typeName);
            HandleMemberSeparator(withSeparator);
        }

        private void AddKeyWithSeparator(string key)
        {
            AddKey(key);
            AddPairSeparator();
        }

        public void HandleMemberSeparator(bool withSeparator)
        {
            if (withSeparator)
                AddMemberSeparator();
        }
        #endregion

        #region Add value for well known types
        private bool HandleBoxedPrimitives(object value)
        {
            var type = value.GetType();
            if (type == typeof(string))
            {
                AddStartObject();
                AddType(StringType, true/*withSeparator*/);
                Add(DataKey, value as string);
                AddEndObject();
                return true;
            }

            if (type == typeof(byte))
            {
                AddStartObject();
                AddType(ByteType, true/*withSeparator*/);
                Add(DataKey, (byte)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(sbyte))
            {
                AddStartObject();
                AddType(SByteType, true/*withSeparator*/);
                Add(DataKey, (sbyte)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(int))
            {
                AddStartObject();
                AddType(IntType, true/*withSeparator*/);
                Add(DataKey, (int)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(uint))
            {
                AddStartObject();
                AddType(UIntType, true/*withSeparator*/);
                Add(DataKey, (uint)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(long))
            {
                AddStartObject();
                AddType(LongType, true/*withSeparator*/);
                Add(DataKey, (long)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(ulong))
            {
                AddStartObject();
                AddType(ULongType, true/*withSeparator*/);
                Add(DataKey, (ulong)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(float))
            {
                AddStartObject();
                AddType(FloatType, true/*withSeparator*/);
                Add(DataKey, (float)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(double))
            {
                AddStartObject();
                AddType(DoubleType, true/*withSeparator*/);
                Add(DataKey, (double)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(char))
            {
                AddStartObject();
                AddType(CharType, true/*withSeparator*/);
                Add(DataKey, (char)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(decimal))
            {
                AddStartObject();
                AddType(DecimalType, true/*withSeparator*/);
                Add(DataKey, (decimal)value);
                AddEndObject();
                return true;
            }

            if (type == typeof(bool))
            {
                AddStartObject();
                AddType(BoolType, true/*withSeparator*/);
                Add(DataKey, (bool)value);
                AddEndObject();
                return true;
            }

            return false;
        }

        private void AddValue(object value, bool withSeparator = false)
        {
            AddStartObject();
            AddType(SystemObjectType, true/*withSeparator*/);

            if (value == null)
            {
                Add(DataKey, NullValue);
                AddEndObject();
                HandleMemberSeparator(withSeparator);
                return;
            }

            AddKey(DataKey);
            AddPairSeparator();
            if (HandleBoxedPrimitives(value))
            {
                AddEndObject();
                HandleMemberSeparator(withSeparator);
                return;
            }

            AddStartObject();
            AddKey(HashCode);
            AddPairSeparator();
            AddNonQuoted(value.GetHashCode());

            AddEndObject(); // data
            AddEndObject();
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(string value, bool withSeparator = false)
        {
            AddQuoted(value);
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(byte value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(sbyte value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(int value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(uint value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(long value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(ulong value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(float value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(double value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(char value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(Convert.ToInt16(value)));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(decimal value, bool withSeparator = false)
        {
            _stringBuilder.Append(Convert.ToString(value));
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(bool value, bool withSeparator = false)
        {
            if (value)
                _stringBuilder.Append("true");
            else
                _stringBuilder.Append("false");

            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(IEnumerable value, bool withSeparator = false)
        {
            AddStartArray();
            bool isFirst = true;
            foreach (var item in value)
            {
                if (!isFirst)
                    AddMemberSeparator();

                AddValue(item);
                isFirst = false;
            }
            AddEndArray();
            HandleMemberSeparator(withSeparator);
        }

        private void AddValue(IDictionary value, bool withSeparator = false)
        {
            AddStartArray();
            bool isFirst = true;
            foreach (DictionaryEntry item in value)
            {
                if (!isFirst)
                    AddMemberSeparator();

                AddStartArray();

                AddStartObject();
                AddType(KeyType, true/*withSeparator*/);
                Add(DataKey, item.Key);
                AddEndObject();

                AddMemberSeparator();

                AddStartObject();
                AddType(ValueType, true/*withSeparator*/);
                Add(DataKey, item.Value);
                AddEndObject();

                AddEndArray();
                isFirst = false;
            }
            AddEndArray();
            HandleMemberSeparator(withSeparator);
        }
        #endregion

        #region Add for well known types
        public void Add(string key, object value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, string value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, byte value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, sbyte value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, int value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, uint value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, long value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, ulong value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, float value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, double value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, char value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, decimal value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, bool value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, IEnumerable value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }

        public void Add(string key, IDictionary value, bool withSeparator = false)
        {
            AddKeyWithSeparator(key);
            AddValue(value, withSeparator);
        }
        #endregion

        public AssistantDumper()
        {
            _stringBuilder = new StringBuilder();
        }

        public override string ToString()
        {
            return _stringBuilder.ToString();
        }
    }
<#+
        }
    } // sbf

    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** test data                                                        :module:
    :PROPERTIES:
    :custom_id: FA9517C1-E9BB-5B04-B973-49713B58F1BF
    :masd.codec.dia.comment: true
    :masd.physical.directory_name: SequenceGenerators
    :masd.physical.postfix: SequenceGenerator
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the test data facet of
the C# technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: DE5D0AB7-3B68-85C4-4ED3-3D79C106B5A2
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** class                                                          :element:
     :PROPERTIES:
     :custom_id: BF14D9AD-BAE9-E1A4-307B-CA81EF25EC83
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::object_configuration
     :END:

Generates implementation files for objects.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/object.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/class_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/class_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void class_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "FIXME",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& o(ast.as<logical::entities::structural::object>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;
using System.Collections;
using System.Collections.Generic;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
            const bool has_attributes(!o.all_attributes().empty());
            const bool is_parent_or_has_attributes(
                !o.parents().empty() || has_attributes);
#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>SequenceGenerator
    {
        static internal void Populate(<#= sn #> value, uint position)
        {
<#+
                if (!is_parent_or_has_attributes) {
#>
            // nothing to populate
<#+
                } else {
                    unsigned int count(0);
                    if (!o.parents().empty()) {
                        const auto& pn(o.parents().front());
                        const auto pqn(ast.get_qualified_name(pn));
#>
            <#= pqn #>SequenceGenerator.Populate(value, position);
<#+
                    }

                    for (const auto& attr : o.local_attributes()) {
                        const auto oap(ast.get_assistant_properties(attr));
                        if (oap && oap->requires_assistance()) {
#>
            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position + <#= count++ #>);
<#+
                        } else {
                            const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));
#>
            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position + <#= count++ #>);
<#+
                        }
                    }
                }
#>
        }

        static internal <#= sn #> Create(uint position)
        {
<#+
            if (!o.is_parent()) {
#>
            var result = new <#= sn #>();
<#+
                if (has_attributes) {
#>
            Populate(result, position);
<#+
                }
#>
            return result;
<#+
            } else {
                auto leaves(o.leaves());
                const auto front(leaves.front());
                leaves.pop_front();
                unsigned int i(0);
                const auto total(static_cast<unsigned int>(leaves.size()));
                for (const auto& l : leaves) {
#>
            if ((position % <#= total #>) == <#= i++ #>)
                return <#= ast.get_qualified_name(l) #>SequenceGenerator.Create(position);
<#+
                }
#>
            return <#= ast.get_qualified_name(front) #>SequenceGenerator.Create(position);
<#+
            }
#>
        }

        #region Enumerator
        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable
        {
            #region Properties
            private uint _position;
            private <#= sn #> _current;
            #endregion

            private void PopulateCurrent()
            {
                _current = <#= sn #>SequenceGenerator.Create(_position);
            }

            #region IDisposable
            public void Dispose()
            {
            }
            #endregion

            #region IEnumerator implementation
            public bool MoveNext()
            {
                ++_position;
                PopulateCurrent();
                return true;
            }

            public void Reset()
            {
                _position = 0;
                PopulateCurrent();
            }

            public object Current {
                get
                {
                    return _current;
                }
            }

            <#= sn #> IEnumerator<<#= sn #>>.Current
            {
                get
                {
                    return _current;
                }
            }
            #endregion

            public <#= sn #>Enumerator()
            {
                PopulateCurrent();
            }
        }
        #endregion

        #region Enumerable
        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>
        {
            #region IEnumerable implementation
            public IEnumerator GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }

            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }
            #endregion
        }
        #endregion

        static public IEnumerable<<#= sn #>> Sequence()
        {
            return new <#= sn #>Enumerable();
        }
    }
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** assistant                                                      :element:
     :PROPERTIES:
     :custom_id: 4E31216A-F998-C964-4223-A1F12B7AD3CC
     :masd.physical.logical_meta_element_id: dogen.logical.entities.assistant
     :masd.wale.kvp.archetype.simple_name: assistant
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::archetype_configuration
     :END:

Generates implementation files for assistants.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/assistant_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/assistant_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void assistant_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "assistant",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    {
        const auto sn(e.name().simple());
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;
using System.Collections;
using System.Collections.Specialized;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>
    /// <summary>
    /// Provides helper methods for the sequence generators.
    /// </summary>
    static class <#= sn #>SequenceGenerator
    {
        private const int SequenceSize = 10;

        public static object CreateObject(uint position)
        {
            return "this is an object: " + Convert.ToString(position);
        }

        public static string CreateString(uint position)
        {
            return "this is a string: " + Convert.ToString(position);
        }

        public static byte CreateByte(uint position)
        {
            return Convert.ToByte(position);
        }

        public static sbyte CreateShortByte(uint position)
        {
            return Convert.ToSByte(position);
        }

        public static int CreateInt(uint position)
        {
            return Convert.ToInt32(position);
        }

        public static uint CreateUInt(uint position)
        {
            return position;
        }

        public static short CreateShort(uint position)
        {
            return Convert.ToInt16(position);
        }

        public static ushort CreateUShort(uint position)
        {
            return Convert.ToUInt16(position);
        }

        public static long CreateLong(uint position)
        {
            return Convert.ToInt64(position);
        }

        public static ulong CreateULong(uint position)
        {
            return Convert.ToUInt64(position);
        }

        public static float CreateFloat(uint position)
        {
            return Convert.ToSingle(position);
        }

        public static double CreateDouble(uint position)
        {
            return Convert.ToDouble(position);
        }

        public static char CreateChar(uint position)
        {
            return Convert.ToChar(position);
        }

        public static bool CreateBool(uint position)
        {
            return position % 2 == 0;
        }

        public static decimal CreateDecimal(uint position)
        {
            return Convert.ToDecimal(position);
        }

        public static IEnumerable CreateIEnumerable(uint position)
        {
            return CreateArrayList(position);
        }

        public static ICollection CreateICollection(uint position)
        {
            return CreateArrayList(position);
        }

        public static IList CreateIList(uint position)
        {
            return CreateArrayList(position);
        }

        public static ArrayList CreateArrayList(uint position)
        {
            var result = new ArrayList();
            for (uint i = 0; i < SequenceSize; i++)
            {
                switch((position + i) % 5)
                {
                case 0: result.Add(CreateString(position + i)); break;
                case 1: result.Add(CreateByte(position + i)); break;
                case 2: result.Add(CreateInt(position + i)); break;
                case 3: result.Add(CreateLong(position + i)); break;
                case 4: result.Add(CreateFloat(position + i)); break;
                case 5: result.Add(CreateDecimal(position + i)); break;
                default: result.Add(CreateBool(position + i)); break;
                }
            }
            return result;
        }

        public static IDictionary CreateIDictionary(uint position)
        {
            return CreateHashtable(position);
        }

        public static Hashtable CreateHashtable(uint position)
        {
            var result = new Hashtable();
            for (uint i = 0; i < SequenceSize; i++)
            {
                result.Add("key_" + position + i, "value_" + position + i);
            }
            return result;
        }

        public static HybridDictionary CreateHybridDictionary(uint position)
        {
            var result = new HybridDictionary();
            for (uint i = 0; i < SequenceSize; i++)
            {
                result.Add("key_" + position + i, "value_" + position + i);
            }
            return result;
        }

        public static NameValueCollection CreateNameValueCollection(uint position)
        {
            var result = new NameValueCollection();
            for (uint i = 0; i < SequenceSize; i++)
            {
                result.Add("key_" + position + i, "value_" + position + i);
            }
            return result;
        }

        public static BitArray CreateBitArray(uint position)
        {
            var result = new BitArray(SequenceSize);
            for (int i = 0; i < SequenceSize; i++)
            {
                result[i] = position % 2 == 0;
            }
            return result;
        }

        public static Queue CreateQueue(uint position)
        {
            var result = new Queue();
            for (int i = 0; i < SequenceSize; i++)
            {
                result.Enqueue("value_" + position + i);
            }
            return result;
        }

        public static Stack CreateStack(uint position)
        {
            var result = new Stack();
            for (int i = 0; i < SequenceSize; i++)
            {
                result.Push("value_" + position + i);
            }
            return result;
        }

        public static SortedList CreateSortedList(uint position)
        {
            var result = new SortedList();
            for (int i = 0; i < SequenceSize; i++)
            {
                result.Add("key_" + position + i, "value_" + position + i);
            }
            return result;
        }
    }
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** enum                                                           :element:
     :PROPERTIES:
     :custom_id: 4AC2C49F-9059-87D4-A9AB-D1C43151D310
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::enumeration_configuration
     :END:

Generates implementation files for enums.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/enumeration.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/enum_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/enum_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void enum_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "enum",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));
    {
        const auto sn(e.name().simple());
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;
using System.Collections;
using System.Collections.Generic;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));
#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>SequenceGenerator
    {
        static internal <#= sn #> Create(uint position)
        {
            var result = (<#= sn #>)(position % <#= ye.enumerators().size() #>);
            return result;
        }

        #region Enumerator
        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable
        {
            #region Properties
            private uint _position;
            private <#= sn #> _current;
            #endregion

            private void PopulateCurrent()
            {
                _current = <#= sn #>SequenceGenerator.Create(_position);
            }

            #region IDisposable
            public void Dispose()
            {
            }
            #endregion

            #region IEnumerator implementation
            public bool MoveNext()
            {
                ++_position;
                PopulateCurrent();
                return true;
            }

            public void Reset()
            {
                _position = 0;
                PopulateCurrent();
            }

            public object Current {
                get
                {
                    return _current;
                }
            }

            <#= sn #> IEnumerator<<#= sn #>>.Current
            {
                get
                {
                    return _current;
                }
            }
            #endregion

            public <#= sn #>Enumerator()
            {
                PopulateCurrent();
            }
        }
        #endregion

        #region Enumerable
        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>
        {
            #region IEnumerable implementation
            public IEnumerator GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }

            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }
            #endregion
        }
        #endregion

        static public IEnumerable<<#= sn #>> Sequence()
        {
            return new <#= sn #>Enumerable();
        }
    }
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

**** primitive                                                      :element:
     :PROPERTIES:
     :custom_id: CE91CCC5-BF4E-66B4-834B-8A185D78DDAF
     :masd.wale.kvp.containing_namespace: text.transforms.test_data
     :masd.codec.stereotypes: masd::physical::archetype, dogen::primitive_configuration
     :END:

Generates implementation files for primitives.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/structural/primitive.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/primitive_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/test_data/primitive_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void primitive_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "primitive",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    const auto& p(ast.as<logical::entities::structural::primitive>(e));
    {
        const auto sn(e.name().simple());
        const auto qn(ast.get_qualified_name(e.name()));
        auto sbf(ast.make_scoped_boilerplate_formatter(e));
        {
#>
using System;
using System.Collections;
using System.Collections.Generic;

<#+
            const auto ns(ast.make_namespaces(e.name()));
            auto snf(ast.make_scoped_namespace_formatter(ns));

#>
    /// <summary>
    /// Generates sequences of <#= sn #>.
    /// </summary>
    public static class <#= sn #>SequenceGenerator
    {
        static internal void Populate(<#= sn #> value, uint position)
        {
<#+
            const auto attr(p.value_attribute());
            const auto oap(ast.get_assistant_properties(attr));
            if (oap && oap->requires_assistance()) {
#>
            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position);
<#+
            } else {
                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));
#>
            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position);
<#+
            }
#>
        }

        static internal <#= sn #> Create(uint position)
        {
            var result = new <#= sn #>();
            Populate(result, position);
            return result;
        }

        #region Enumerator
        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable
        {
            #region Properties
            private uint _position;
            private <#= sn #> _current;
            #endregion

            private void PopulateCurrent()
            {
                _current = <#= sn #>SequenceGenerator.Create(_position);
            }

            #region IDisposable
            public void Dispose()
            {
            }
            #endregion

            #region IEnumerator implementation
            public bool MoveNext()
            {
                ++_position;
                PopulateCurrent();
                return true;
            }

            public void Reset()
            {
                _position = 0;
                PopulateCurrent();
            }

            public object Current {
                get
                {
                    return _current;
                }
            }

            <#= sn #> IEnumerator<<#= sn #>>.Current
            {
                get
                {
                    return _current;
                }
            }
            #endregion

            public <#= sn #>Enumerator()
            {
                PopulateCurrent();
            }
        }
        #endregion

        #region Enumerable
        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>
        {
            #region IEnumerable implementation
            public IEnumerator GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }

            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()
            {
                return new <#= sn #>Enumerator();
            }
            #endregion
        }
        #endregion

        static public IEnumerable<<#= sn #>> Sequence()
        {
            return new <#= sn #>Enumerable();
        }
    }
<#+
        }
    } // sbf
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** visual studio                                                    :module:
    :PROPERTIES:
    :custom_id: 82F38408-9366-A8C4-CDB3-C89FF9BF1DF6
    :masd.codec.dia.comment: true
    :masd.codec.stereotypes: masd::physical::facet
    :END:

M2T transforms for the visual studio
facet of the C# technical space.

**** initializer                                                    :element:
     :PROPERTIES:
     :custom_id: 80EFFA4B-D6B2-09A4-6223-EA86EF048F43
     :masd.codec.stereotypes: dogen::handcrafted::typeable
     :END:

**** project                                                        :element:
     :PROPERTIES:
     :custom_id: 4869929F-2A8B-0FD4-B543-59A885694199
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_project
     :masd.wale.kvp.archetype.simple_name: project
     :masd.physical.part_id: masd.csharp.implementation
     :masd.wale.kvp.containing_namespace: text.transforms.visual_studio
     :masd.physical.wale_template_reference: csharp_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: xml
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates visual studio project.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/project.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/visual_studio/project_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/visual_studio/project_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void project_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "project",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::visual_studio::project;
#>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>
</Project>
<#+
    ast.update_artefact();
    stp.end_transform(a);

}
#>
#+end_src

**** solution                                                       :element:
     :PROPERTIES:
     :custom_id: A59E52E0-5B86-C704-C483-9CD6CBBA8078
     :masd.physical.logical_meta_element_id: dogen.logical.entities.visual_studio_solution
     :masd.wale.kvp.archetype.simple_name: solution
     :masd.physical.part_id: masd.csharp.implementation
     :masd.wale.kvp.containing_namespace: text.transforms.visual_studio
     :masd.physical.wale_template_reference: csharp_transform_implementation
     :masd.physical.relation_status: not_relatable
     :masd.physical.technical_space: sln
     :masd.codec.stereotypes: masd::physical::archetype
     :END:

Generates visual studio solutions.

***** stitch template content                                     :attribute:

#+begin_src fundamental
<#@ masd.stitch.stream_variable_name=ast.stream() #>
<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::visual_studio #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/io/shared_ptr_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/log/logger.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.tracing/types/scoped_tracer.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/io/entities/element_io.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.physical/io/entities/artefact_io.hpp" #>
<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>
<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>
<#@ masd.stitch.inclusion_dependency="dogen.utility/types/formatters/sequence_formatter.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/physical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.identification/types/helpers/logical_meta_name_factory.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.logical/types/entities/visual_studio/solution.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/formatters/assistant.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/visual_studio/solution_transform.hpp" #>
<#@ masd.stitch.inclusion_dependency="dogen.text/types/transforms/csharp/visual_studio/solution_factory.hpp" #>
<#$ stitch.wale.template_instantiation_result #>
<#+

void solution_transform::
apply(const text::transforms::context& ctx, const text::entities::model& lps,
    const logical::entities::element& e, physical::entities::artefact& a) const {
    tracing::scoped_transform_tracer stp(lg, "solution",
        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);

    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);
    using logical::entities::visual_studio::solution;
    const auto& sln(ast.as<solution>(e));
#>
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
Project("{<#= ppb.type_guid() #>}") = "<#= ppb.name() #>", "<#= ppb.name() #>.csproj", "{<#= ppb.guid() #>}"
EndProject
<#+
    }
#>
Global
    GlobalSection(SolutionConfigurationPlatforms) = preSolution
        Debug|Any CPU = Debug|Any CPU
        Release|Any CPU = Release|Any CPU
    EndGlobalSection
    GlobalSection(ProjectConfigurationPlatforms) = postSolution
<#+
    for (const auto& ppb : sln.project_persistence_blocks()) {
#>
        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU
        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU
<#+
    }
#>
    EndGlobalSection
    GlobalSection(MonoDevelopProperties) = preSolution
        StartupItem = CSharpModel.csproj
    EndGlobalSection
EndGlobal
<#+
    ast.update_artefact();
    stp.end_transform(a);
}
#>
#+end_src

*** initializer                                                     :element:
    :PROPERTIES:
    :custom_id: 62958957-417D-1EB4-4A3B-73765B76B37F
    :masd.codec.stereotypes: dogen::handcrafted::typeable
    :END:

* formatters                                                         :module:
  :PROPERTIES:
  :custom_id: 1ED921D8-3C3C-4684-6E33-55B9E9D451CC
  :END:

** formatting error                                                 :element:
   :PROPERTIES:
   :custom_id: 1CDB2042-B63D-2934-7B0B-F1C60BA2E1D8
   :masd.codec.stereotypes: masd::exception
   :END:

An error has occurred while formatting.

** namespace formatter                                              :element:
   :PROPERTIES:
   :custom_id: 05A17E19-6300-CA24-FA63-A37D483E12F0
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** scoped namespace formatter                                       :element:
   :PROPERTIES:
   :custom_id: 981ABDA9-AAD3-C0D4-22E3-533273E3F168
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** boilerplate formatter                                            :element:
   :PROPERTIES:
   :custom_id: 7C039855-B516-8214-E9F3-53A733AD4028
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** scoped boilerplate formatter                                     :element:
   :PROPERTIES:
   :custom_id: 06C83768-A5E3-45A4-BB83-1EEBA3770737
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** dependencies formatter                                           :element:
   :PROPERTIES:
   :custom_id: EEF1DF7C-9A09-F754-0DF3-C51246C46414
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** header guard formatter                                           :element:
   :PROPERTIES:
   :custom_id: 9CE6EB89-205C-DDF4-4B9B-DDB013B80948
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:

** boilerplate properties                                           :element:
   :PROPERTIES:
   :custom_id: EE21D1AE-1CD2-D0E4-1903-F556B0BB09E6
   :END:

*** preamble                                                      :attribute:
    :PROPERTIES:
    :masd.codec.type: std::string
    :END:

*** postamble                                                     :attribute:
    :PROPERTIES:
    :masd.codec.type: std::string
    :END:

*** dependencies                                                  :attribute:
    :PROPERTIES:
    :masd.codec.type: std::list<std::string>
    :END:

*** header guard                                                  :attribute:
    :PROPERTIES:
    :masd.codec.type: std::string
    :END:

*** technical space                                               :attribute:
    :PROPERTIES:
    :masd.codec.type: identification::entities::technical_space
    :END:

*** generate preamble                                             :attribute:
    :PROPERTIES:
    :masd.codec.type: bool
    :END:

*** generate header guards                                        :attribute:
    :PROPERTIES:
    :masd.codec.type: bool
    :END:

** assistant                                                        :element:
   :PROPERTIES:
   :custom_id: 64406C36-46C7-82D4-111B-690062F6E4A3
   :masd.codec.stereotypes: dogen::handcrafted::typeable
   :END:
