#+title: Sprint Backlog 70
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) spike(p) }

* Mission Statement

- Finish implementing all formatters using the new cpp architecture.
- Remove legacy cpp architecture.
- Remove unused features.
- Start SML refactor.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75
#+CAPTION: Clock summary at [2015-07-13 Mon 14:17]
| <75>                                                                        |         |       |      |
| Headline                                                                    | Time    |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| *Total time*                                                                | *27:17* |       |      |
|-----------------------------------------------------------------------------+---------+-------+------|
| Stories                                                                     | 27:17   |       |      |
| Active                                                                      |         | 27:17 |      |
| STARTED Sprint and product backlog grooming                                 |         |       | 1:34 |
| COMPLETED Rename top-level registrars to avoid clashes with serialisation   |         |       | 0:10 |
| COMPLETED Implement serialisation registrar implementation formatter        |         |       | 4:20 |
| COMPLETED Add boilerplate for cmakelists formatters                         |         |       | 0:52 |
| COMPLETED Implement include cmakelists formatter                            |         |       | 0:54 |
| COMPLETED Implement source cmakelists formatter                             |         |       | 0:46 |
| COMPLETED Implement includer formatter                                      |         |       | 3:35 |
| COMPLETED Implement serialisation formatter for enumerations                |         |       | 0:47 |
| COMPLETED Implement odb pragma formatter for enumerations                   |         |       | 0:28 |
| COMPLETED Generate empty files for non-generatable types                    |         |       | 0:56 |
| COMPLETED Switch off overrides for legacy formatters                        |         |       | 0:45 |
| COMPLETED Switch off SML to CPP transformation                              |         |       | 0:07 |
| COMPLETED Remove knit backends and use backend model instead                |         |       | 1:42 |
| COMPLETED Managed directories is not correct in new world                   |         |       | 0:06 |
| COMPLETED Remove unused command line options                                |         |       | 0:58 |
| COMPLETED Remove unused classes in cpp model                                |         |       | 0:05 |
| COMPLETED Remove support for empty model name                               |         |       | 0:28 |
| COMPLETED Remove ability to output to stdout                                |         |       | 0:20 |
| COMPLETED Remove unused stereotypes and object types                        |         |       | 1:48 |
| COMPLETED Remove is comparable from SML                                     |         |       | 0:15 |
| COMPLETED Add forward declarations to visitor                               |         |       | 0:06 |
| COMPLETED Remove unused properties in CPP model                             |         |       | 0:22 |
| COMPLETED Remove default values in SML                                      |         |       | 0:15 |
| COMPLETED Consider removing =number_of_type_arguments= in SML               |         |       | 0:33 |
| COMPLETED Consider removing =module_types= in SML                           |         |       | 0:11 |
| COMPLETED Remove unused relationship types in SML                           |         |       | 0:06 |
| CANCELLED Remove inherited properties in SML                                |         |       | 0:09 |
| COMPLETED Remove all types traversal from SML                               |         |       | 0:05 |
| COMPLETED Remove operations in SML                                          |         |       | 0:17 |
| COMPLETED Remove generation failure exception in knit                       |         |       | 0:13 |
| COMPLETED Remove opaque parameters from cpp properties                      |         |       | 0:06 |
| STARTED Define end to end terminology given all refactoring stories         |         |       | 1:43 |
| STARTED Thoughts on cpp refactoring                                         |         |       | 0:26 |
| STARTED Setup pgannon to develop dogen site                                 |         |       | 1:49 |
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2015-07-12 Sun 00:05]--[2015-07-12 Sun 00:13] =>  0:08
    CLOCK: [2015-07-11 Sat 23:55]--[2015-07-12 Sun 00:05] =>  0:10
    CLOCK: [2015-07-10 Fri 23:03]--[2015-07-10 Fri 23:11] =>  0:08
    CLOCK: [2015-07-10 Fri 15:27]--[2015-07-10 Fri 15:49] =>  0:22
    CLOCK: [2015-07-09 Thu 21:21]--[2015-07-09 Thu 21:49] =>  0:28
    CLOCK: [2015-07-07 Tue 23:15]--[2015-07-07 Tue 23:21] =>  0:06
    CLOCK: [2015-07-06 Mon 15:01]--[2015-07-06 Mon 15:13] =>  0:12


Updates to sprint and product backlog.

*** COMPLETED Rename top-level registrars to avoid clashes with serialisation :story:
    CLOSED: [2015-07-07 Tue 16:11]
    CLOCK: [2015-07-07 Tue 16:01]--[2015-07-07 Tue 16:11] =>  0:10

Due to the hacks we put in that generate serialisation registrar's
qnames, we now are no longer able to have domain types called
=registrar= in the top-level namespace. For now we can just rename
these and fix it properly later.

*** COMPLETED Implement serialisation registrar implementation formatter :story:
    CLOSED: [2015-07-07 Tue 16:13]
    CLOCK: [2015-07-07 Tue 15:51]--[2015-07-07 Tue 16:00] =>  0:09
    CLOCK: [2015-07-07 Tue 13:31]--[2015-07-07 Tue 15:00] =>  1:29
    CLOCK: [2015-07-06 Mon 17:30]--[2015-07-06 Mon 17:57] =>  0:27
    CLOCK: [2015-07-06 Mon 15:14]--[2015-07-06 Mon 17:29] =>  2:15

Create the formatter, stitch template and all associated
machinery. Fix all differences.

Problems:

- references are not handled correctly.

Problems solved:

- includes for leaves are missing. We need to somehow get the include
  generation to work for registrar and also the aspect settings
  generation. Lots of hackery required to achieved this.
- arguments passed in to eos serialisation were hard coded in legacy.
- no newline at the end of the file.
- missing includes. Factory not populating includes either.
- eos check is not yielding expected result.

*** COMPLETED Add boilerplate for cmakelists formatters               :story:
    CLOSED: [2015-07-07 Tue 17:04]
    CLOCK: [2015-07-07 Tue 16:12]--[2015-07-07 Tue 17:04] =>  0:52

Add skeletons for interfaces, stitch templates, etc and hook it all
together with the initialiser.

*** COMPLETED Implement include cmakelists formatter                  :story:
    CLOSED: [2015-07-07 Tue 17:55]
    CLOCK: [2015-07-07 Tue 17:05]--[2015-07-07 Tue 17:59] =>  0:54

Create the formatter, stitch template and all associated
machinery. Fix all differences.

*** COMPLETED Implement source cmakelists formatter                   :story:
    CLOSED: [2015-07-07 Tue 22:26]
    CLOCK: [2015-07-07 Tue 21:40]--[2015-07-07 Tue 22:26] =>  0:46

Create the formatter, stitch template and all associated
machinery. Fix all differences.

*** COMPLETED Implement includer formatter                            :story:
    CLOSED: [2015-07-08 Wed 16:08]
    CLOCK: [2015-07-08 Wed 16:09]--[2015-07-08 Wed 16:31] =>  0:22
    CLOCK: [2015-07-08 Wed 14:29]--[2015-07-08 Wed 16:08] =>  1:39
    CLOCK: [2015-07-08 Wed 14:03]--[2015-07-08 Wed 14:28] =>  0:25
    CLOCK: [2015-07-08 Wed 13:39]--[2015-07-08 Wed 14:02] =>  0:23
    CLOCK: [2015-07-07 Tue 22:28]--[2015-07-07 Tue 23:14] =>  0:46

Create the formatter, stitch template and all associated
machinery. Fix all differences.

Problems:

- no includes.
- need to add guard to legacy.

Problems Solved:

- no general settings.
- missing machinery to hookup includers.
- generating includers for disabled facets.

*** COMPLETED Implement serialisation formatter for enumerations      :story:
    CLOSED: [2015-07-08 Wed 17:48]
    CLOCK: [2015-07-08 Wed 17:34]--[2015-07-08 Wed 17:48] =>  0:14
    CLOCK: [2015-07-08 Wed 16:57]--[2015-07-08 Wed 17:30] =>  0:33

Create the formatter, stitch template and all associated
machinery. Fix all differences.

*** COMPLETED Implement odb pragma formatter for enumerations         :story:
    CLOSED: [2015-07-08 Wed 20:45]
    CLOCK: [2015-07-08 Wed 20:33]--[2015-07-08 Wed 20:45] =>  0:12
    CLOCK: [2015-07-08 Wed 17:49]--[2015-07-08 Wed 18:05] =>  0:16

Create the formatter, stitch template and all associated
machinery. Fix all differences.

*** COMPLETED Generate empty files for non-generatable types          :story:
    CLOSED: [2015-07-08 Wed 21:43]
    CLOCK: [2015-07-08 Wed 21:40]--[2015-07-08 Wed 21:43] =>  0:03
    CLOCK: [2015-07-08 Wed 20:46]--[2015-07-08 Wed 21:39] =>  0:53

At present we are ignoring all types that are non-generatable or
partially generatable. We are also not generating forward
declarations.

*** COMPLETED Switch off overrides for legacy formatters              :story:
    CLOSED: [2015-07-08 Wed 22:06]
    CLOCK: [2015-07-08 Wed 21:44]--[2015-07-08 Wed 22:05] =>  0:21
    CLOCK: [2015-07-08 Wed 16:32]--[2015-07-08 Wed 16:56] =>  0:24

We need to switch off the legacy formatters and deal with the fallout.

Problems:

- generating empty file names.
- not generating empty files for non-generatable types.
- not generating odb pragmas or serialisation for enumerations.

*** COMPLETED Switch off SML to CPP transformation                    :story:
    CLOSED: [2015-07-08 Wed 22:14]
    CLOCK: [2015-07-08 Wed 22:07]--[2015-07-08 Wed 22:14] =>  0:07

Switch the legacy transformation and formatting.

*** COMPLETED Remove knit backends and use backend model instead      :story:
    CLOSED: [2015-07-09 Thu 21:51]
    CLOCK: [2015-07-09 Thu 21:50]--[2015-07-09 Thu 21:55] =>  0:05
    CLOCK: [2015-07-09 Thu 20:56]--[2015-07-09 Thu 21:15] =>  0:09
    CLOCK: [2015-07-09 Thu 07:36]--[2015-07-09 Thu 08:22] =>  0:46
    CLOCK: [2015-07-09 Thu 07:22]--[2015-07-09 Thu 07:33] =>  0:11
    CLOCK: [2015-07-08 Wed 22:32]--[2015-07-08 Wed 22:53] =>  0:21

We need to stop using the knit version of the backends. This will
probably require fixing the managed directories problem.

*** COMPLETED Managed directories is not correct in new world         :story:
    CLOSED: [2015-07-10 Fri 09:57]
    CLOCK: [2015-07-10 Fri 09:51]--[2015-07-10 Fri 09:57] =>  0:06

When generating the config model, we used to get the following initial
configuration for the housekeeper:

: [ "/home/marco/Development/DomainDrivenConsulting/dogen/projects/config" ]

but now we get:

: [ "/home/marco/Development/DomainDrivenConsulting/dogen/projects/config/include",
:  "/home/marco/Development/DomainDrivenConsulting/dogen/projects/config/include" ]

*** COMPLETED Remove unused command line options                      :story:
    CLOSED: [2015-07-10 Fri 10:19]
    CLOCK: [2015-07-10 Fri 09:57]--[2015-07-10 Fri 10:19] =>  0:22
    CLOCK: [2015-07-10 Fri 09:15]--[2015-07-10 Fri 09:51] =>  0:36

Now that we mapped a number of command line options to meta-data, we
should be able to remove them from the config model.

*** COMPLETED Remove unused classes in cpp model                      :story:
    CLOSED: [2015-07-10 Fri 10:26]
    CLOCK: [2015-07-10 Fri 10:21]--[2015-07-10 Fri 10:26] =>  0:05

We need to remove all of the old world classes we had in the =cpp=
model such as content descriptor, project, etc.

*** COMPLETED Remove support for empty model name                     :story:
    CLOSED: [2015-07-10 Fri 10:57]
    CLOCK: [2015-07-10 Fri 10:27]--[2015-07-10 Fri 10:55] =>  0:28

One of the features we had originally added but for which we do not
have any use cases. Ability to have a model with an empty name.

*** COMPLETED Remove ability to output to stdout                      :story:
    CLOSED: [2015-07-10 Fri 11:16]
    CLOCK: [2015-07-10 Fri 10:56]--[2015-07-10 Fri 11:16] =>  0:20

One of the features we had originally added but for which we do not
have any use cases. Ability to output generated code to stdout.

*** COMPLETED Remove unused stereotypes and object types              :story:
    CLOSED: [2015-07-10 Fri 15:10]
    CLOCK: [2015-07-10 Fri 13:41]--[2015-07-10 Fri 15:10] =>  1:29
    CLOCK: [2015-07-10 Fri 11:19]--[2015-07-10 Fri 11:38] =>  0:19

At present we have a large number of stereotypes, but only a few are
actually in use. Remove all that aren't in use.

*** CANCELLED Remove is final from SML                                :story:
    CLOSED: [2015-07-10 Fri 15:12]

*Rationale*: This is actually fully coded with the new formatters.

We never did implement comparable properly. Remove all remnants of the
previous attempt.

*** COMPLETED Remove is comparable from SML                           :story:
    CLOSED: [2015-07-10 Fri 15:27]
    CLOCK: [2015-07-10 Fri 15:12]--[2015-07-10 Fri 15:27] =>  0:15

We never did implement comparable properly. Remove all remnants of the
previous attempt.

*** COMPLETED Add forward declarations to visitor                     :story:
    CLOSED: [2015-07-10 Fri 17:07]
    CLOCK: [2015-07-10 Fri 17:01]--[2015-07-10 Fri 17:07] =>  0:06

At present we are suppressing forward declarations for visitor in
transformer due to legacy compatibility. Remove this and see what
breaks.

*** COMPLETED Remove unused properties in CPP model                   :story:
    CLOSED: [2015-07-10 Fri 23:02]
    CLOCK: [2015-07-10 Fri 22:40]--[2015-07-10 Fri 23:02] =>  0:22

As part of the version clean up, we did not remove all of the C++
representations of the version related properties. Clean these up and
any others that are not used by the new world formatters.

*** COMPLETED Remove default values in SML                            :story:
    CLOSED: [2015-07-11 Sat 21:46]
    CLOCK: [2015-07-11 Sat 21:31]--[2015-07-11 Sat 21:46] =>  0:15

We seem to have started adding these but its just another case of
half-baked support. Remove all remnants.

*** COMPLETED Consider removing =number_of_type_arguments= in SML     :story:
    CLOSED: [2015-07-11 Sat 22:20]
    CLOCK: [2015-07-11 Sat 21:47]--[2015-07-11 Sat 22:20] =>  0:33

Check to see if this property is used and if not, remove it.

*** COMPLETED Consider removing =module_types= in SML                 :story:
    CLOSED: [2015-07-11 Sat 22:32]
    CLOCK: [2015-07-11 Sat 22:21]--[2015-07-11 Sat 22:32] =>  0:11

We need to see if this enum is used for anything sensible, and if not
remove it.

*** COMPLETED Remove unused relationship types in SML                 :story:
    CLOSED: [2015-07-11 Sat 22:39]
    CLOCK: [2015-07-11 Sat 22:33]--[2015-07-11 Sat 22:39] =>  0:06

We seem to have a few relationship types that are no longer required.

*** CANCELLED Remove inherited properties in SML                      :story:
    CLOSED: [2015-07-11 Sat 22:50]
    CLOCK: [2015-07-11 Sat 22:41]--[2015-07-11 Sat 22:50] =>  0:09

*Rationale*: the properties are in use by formattables.

It seems there is no user for these at the moment so remove them.

*** COMPLETED Remove all types traversal from SML                     :story:
    CLOSED: [2015-07-11 Sat 22:58]
    CLOCK: [2015-07-11 Sat 22:52]--[2015-07-11 Sat 22:57] =>  0:05

This does not appear to be used.

*** COMPLETED Remove operations in SML                                :story:
    CLOSED: [2015-07-11 Sat 23:17]
    CLOCK: [2015-07-11 Sat 22:59]--[2015-07-11 Sat 23:16] =>  0:17

We have some half-baked support for operations. Remove it.

*** COMPLETED Remove generation failure exception in knit             :story:
    CLOSED: [2015-07-11 Sat 23:31]
    CLOCK: [2015-07-11 Sat 23:18]--[2015-07-11 Sat 23:31] =>  0:13

At present we have two types of exceptions in knit: workflow error and
generation failure. We should only have one type.

*** COMPLETED Remove opaque parameters from cpp properties            :story:
    CLOSED: [2015-07-12 Sun 00:19]
    CLOCK: [2015-07-12 Sun 00:13]--[2015-07-12 Sun 00:19] =>  0:06

Seems like this got missed out on previous tidy-up.

*** STARTED Define end to end terminology given all refactoring stories :story:
    CLOCK: [2015-07-13 Mon 14:01]--[2015-07-13 Mon 14:17] =>  0:16
    CLOCK: [2015-07-12 Sun 14:10]--[2015-07-12 Sun 15:00] =>  0:50
    CLOCK: [2015-07-12 Sun 00:20]--[2015-07-12 Sun 00:57] =>  0:37

We have a number of refactoring stories, all covering different
aspects of the architecture. We need to combine all of them into a
unified view. This story focuses on defining the key terms.

Seems like the Model-Driven field already contains a lot of very
useful definitions in this space. In particular:

- [[http://www.voelter.de/data/books/mdsd-en.pdf][Model-Driven Software Development]]
- [[http://researcher.ibm.com/researcher/files/zurich-jku/mdse-08.pdf][Model-Driven Software Engineering]]

*Terms*

- *kernel*:
A programming language is a formal constructed language designed to
communicate instructions to a machine, particularly a computer.
- *formatter*:

*** STARTED Thoughts on cpp refactoring                               :story:
    CLOCK: [2015-07-10 Fri 13:15]--[2015-07-10 Fri 13:41] =>  0:26

We haven't quite arrived at the ideal configuration for the cpp
model. We are close, but not there yet. The problem we have at the
moment is that the formatters drive a lot of the work in
formattables, resulting in a circular dependency. This is happening
because we are missing some entities. This story is just a random set
of thoughts in this space, trying to clear up the terminology across
the board.

*Random thoughts*

What is probably needed is to have facets, aspects and "file kinds" as
top-level concepts rather than just strings with which we label
formatters. In addition, we need a good name for "file kinds". This is
a meta-concept, something akin to a file template. The formatter
produces a physical representation of that meta-concept. As part of
the formatter registration, we can also register this meta-concept
(provided it relies on an existing formattable). And in effect, these
are the pieces of the puzzle:

- you define a "file kind".
- a facet and a model are groupings of "file kinds". These happen to
  be hierarchical groupings. There are others: header and
  implementation, or class header formatter. Those are
  non-hierarchical.
- you bind a transformer to a SML type to generate a formattable.
- a formattable is associated with one or more "file kinds" or better
  yet a file kind is associated with a formattable. It is also
  associated with formatting properties and settings. It is those
  tuples that we pass to the formatters.
- you bind a formatter to a "file" and process the associated
  formattable.

Perhaps we can call these "file kinds" file archetypes or just
archetypes.

What can be said about an archetype:

- conceptual notion of something we want to generate.
- one SML entity can map to zero or many archetypes. Concept at
  present maps to zero. Object maps to many.
- a representation of the archetype as source code is done by the
  formatter. It uses a template to help it generate that
  representation.
- a given archetype maps to one and only one SML entity.
- a given archetype maps to one and only one CPP entity.
- archetypes can be grouped in many ways. One way is facets and
  models.
- archetypes have definitions: name of the archetype, what groups it
  belongs to.
- archetypes have associated data: formattables, settings,
  properties. This is an entity and needs a name.
- formatters work on one and only one archetype.
- archetypes have qualified names; this is (mostly) what we called
  ownership hierarchy. Qualified names can be represented as separate
  fields or using the dot notation.
- archetypes have labels: this is what we called groups.
- dynamic is a model designed to augment SML with some archetype
  data. This is not true in the dia case. Check all fields to see if
  it is true everywhere else.
- an aspect is a property of one or more archetypes; it is a knob that
  affects the generation of the source code representation.
- an archetype instance belongs to an archetype.
- we should remove the concept of "integrated facets". It just happens
  that a facet such as types may have aspects that enable features
  similar to aspects in other facets. There may be rules that
  determine that when certain aspects are enabled, certain facets must
  be switched off because they are incompatible.
- facet is a good name for grouping archetypes, but model isn't. We
  need a better name for a set of facets. Aspect is also a good
  name. In addition, a model group is also a bad name. A "model" is a
  cohesive group of archetypes that are meant to be used together. A
  "model group" is a cohesive group of models that provide the same
  conceptual representations in different programming languages. Maybe
  we should use a more "random" name such as: pod. Then perhaps a
  model group could become a "pod family": a family of related pods. A
  given model can be represented by one pod family or another - they
  are mutually exclusive. Of course, from a command line perspective,
  its better to think of "modes". Each mode corresponds to choosing
  one "pod family" over another. This does not map very cleanly.
- archetypes have an associated programming language - a grammar.
- a facet may exist in more than one programming language and an
  aspect too.
- pods are programming language specific.
- formattables are kind of like an archetype friendly representation
  of the domain types. We need a good name for this.
- internal and external now make slightly more sense, at least once we
  got a good name for formatters. We still need a good name for it
  though. If the archetype instance is generated because of the
  presence of the domain type, it is external. If the archetype has no
  sensitivity to domain types (but may have sensitivity to other
  things such as options) it is internal. The naming around this is
  not totally clear.
- internal formatters may not be allowed to be disabled. For example,
  if serialisation is on, registrar must be generated. With
  CMakeLists, we may want do disable them altogether.
- in the thrift story in the backlog we mention the existence of
  mutually exclusive groups of facets. We should also come up with a
  name for these.
- archetype may not quite be the right name. See [[http://www.pearsonhighered.com/samplechapter/032111230X.pdf][Archetypes and
  archetype patterns]]. See also:
  - [[http://www.step-10.com/SoftwareDesign/ModellingInColour/ColourCoding.html][Class Archetypes, UML and Colour]]
  - [[http://www.step-10.com/SoftwareDesign/ModellingInColour/index.html][Peter Coad's 'Modeling in Color']]
  - [[http://www.step-10.com/Books/JMCUBook.html][Java Modeling in Color with UML]]
- the process of mapping domain types to archetypes could be called
  "expansion" because its a one to many relationship in most cases.
- its not quite correct to call CPP types "formattables". The
  archetype has to have an ordered container of inputs to the
  formatter. This is sort of the "payload" for formatting; the
  archetype is a container of such entities. Taking into account the
  cases where more than one type is placed in the same file, this
  would result in the includes being merged. Or perhaps these things
  are really formattables, but then we need a way to distinguish
  between "top-level formatters" that generate archetypes from
  "partial" formatters that can be combined.
- with "facet specific types" we go one level deeper: it should be
  possible to add an enumeration definition to say test data. This
  would mean that archetypes and facets are not quite so aligned as we
  first thought. Potentially, one should be able to ask for say a
  formattable at facet X in an artchetype at facet Y.
- One way to look at it is as follows: there is the modeling
  dimension, in which we have an entity, say entity =A=; and there is
  the implementation dimension, in which =a= can be represented by
  =A1, A2, ..., An= archetypes. In effect, the implementation
  dimension has multiple dimensions, one for each pod (and of course
  the pod families would be an extra dimension and so on). Actually,
  we probably have 3 steps: the modeling dimension, the translation of
  that into a language-specific representation and then finally the
  archetype dimension.
- a good name for the top-level container of archetypes is
  "kernel". This was inspired (loosely) in some ideas from EMF. So
  we'd have say the "quilt kernel", with support for multiple
  programming languages such as cpp, java etc. We we'd have the "pleat
  kernel" and so forth. Each kernel has a set of languages and the
  languages have archetypes. Archetypes have a collection of
  properties such as the formattables they need, the formatters and so
  on. The job of a model such as =quilt::cpp= is to implement this
  binding.
- dynamic fields can be owned by archetypes or by other types of
  owners (e.g. dia). We should have a way of expressing this
  ownership.
- we haven't used the word "feature" anywhere yet (properly; we
  mentioned it in the manual and so on, but not given it any good
  meaning).
- we created a split between "internal" and "external" formatters, but
  its interesting to notice that we have "internal" formatters that
  are "regular" formatters - in that we need to create a qname for
  them and the formatter properties will work correctly; whereas some
  others are "irregular" formatters - they have strange filenames that
  cannot be generated without some fiddling. Actually, ODB options is
  the main problematic one. If we could place it in a sensible
  location we could probably get rid of irregular formatters
  altogether.
- we need to have "special" facets; cmake files for example should not
  really have a facet but it seems having an empty facet name breaks a
  lot of stuff.
- we need a map between types/states in SML and enablement. For
  example, if a type is "non-generatable" that is taken to mean
  "generate types if file does not exist, default all else to
  disabled". We need a way to express this sort of logic. This is akin
  to an "enablement map". For example, users could define these maps
  somewhere, given them a name and then assign a type to a map. In
  addition, we need a way to express "generate but don't override" and
  "generate and override".

*** STARTED Setup pgannon to develop dogen site                       :story:
    CLOCK: [2015-07-12 Sun 15:01]--[2015-07-12 Sun 16:50] =>  1:49

We need to get pgannon up to speed with all that is required to
develop a quick project site for dogen.

*** Thoughts on simplifying the formattables generation               :story:

We have a problem in the way which we are doing the formattables:
because we are doing model traversals for each of the factories, we
cannot easily introduce a set of manually generated qnames such as the
registrar and includers. However, if we started off the main workflow
by creating a structure like so:

- qname
- optional entity (new base class in SML); if null we need to create
  extensions as an empty object.

We then need a list of these that get passed in to all repository
factories. These use a visitor of entity to resolve to a type (where
required).

We can inject types to this list that have a qname but no entity. For
these we generate some parts of the formatter properties. Actually, we
still need to generate inclusion lists even when there is no
entity. Perhaps we need to create a new method in the provider that
does not take an SML entity but still generates the inclusion list.

Actually this should all be done in SML. We should have zero qname
look-ups coming out of SML, just follow references. This story is a
variation of the split between "partial" models and "full" models.

Well not everything should be done in SML. We still need to create a
structure with the properties above, but that is done by iterating
through a list in the SML model.

This work is dependent on [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#split-a-fully-formed-model-from-partial-models][this]] story.

One slight problem with this approach: sometimes we need to preserve
some relationships in the newly generated objects. For registrar we
need to preserve the model leaves. For the includers / master headers
we need to express somehow the inclusion relationship at the formatter
level. The latter is definitely a special case because it is a pure
C++ concept: include files cannot be modeled in SML. However,
registrar is slightly different because we still need to compute the
includes based on the leaves. This means that the above approach will
not provide a clean solution, unless we synthesise an SML object when
providing the includes. And of course we need to be careful taking
that route or else we will end up generating the object across all
facets.

It is important not to confuse formatters with archetypes. A formatter
(or at least, a "top-level formatter"; those that generate files) is
in a sense a "category" of archetypes. In other words, for a given
formatter many archetypes will be generated. This may mean that the
"archetype" is not a very good choice because it may imply some kind
of meta-class-ness. In a sense, we are dealing with arch-entities
("entity" being SML's base class for all modeled domain types). So
fundamentally, the correct workflow is vaguely like this:

- we create a model for some problem domain. We represent this model
  in SML. All objects are identifiable by a qname.
- we apply a transformation of this model into something which is
  closer to the programming language that we wish to generate; these
  we choose to call formattables.
- we may also inject some formattables which do not have a mapping to
  the original domain objects. These have synthetic qnames.
- we apply a function that takes the qname, the SML entity, the
  formattable and generates an archetype skeleton. To start off with,
  this is made up of only a file name and a top-level formatter. The
  structure exists in memory as a map of qnames to formatter names to
  archetypes.
- we then fill in the blanks: compute includes, enablement, etc. The
  final blank that needs to be filled in is the generation of the
  file, which is done by applying a formatter to a number of the
  archetype properties.

Another point of interest is that we may be able to move some of the
archetype processing to common code. For example, file name
generation, enablement, and so on are not language specific. However,
we need to have a representation of the archetype which is specific to
a model (e.g. =quilt::cpp= say) because not all properties will be
common. We could, possibly, have an archetype base class, which then
would imply a formatter's base class and so on - but then we hit the
visitor across models problem.

In this approach we do have an advantage which is we can parallelise a
lot of work across each stage in the "pipeline". For instance we can
run transformation from SML to formattables in parallel. We could
conceivably even have futures for each of the archetype
properties. None of this is a concern for the foreseable future, of
course.

FIXME: improve references by having models inside of models; we should
be able to keep only the types that we refer in the final model.

*** Model groups and multi-language support                           :story:

At present we have hard-coded knit to support a single C++ model,
cpp. However, in reality the world looks more like this:

- there are "groups of models" that have models that target specific
  languages. We need to give a name to the "default" model group in
  dogen. We should choose something from the [[http://en.wikipedia.org/wiki/Glossary_of_sewing_terms][sewing terms]]; for now
  lets call it =quilt=. =quilt= contains a number of languages such as
  =cpp=. A user can only generate one model group at a time. Users can
  generate one or more languages within a group (depending on what the
  group supports).
- we should have a top-level folder to house all model groups:
  =backends=. The existing =backend= model becomes =backends::core=.
- there may be facilities that are language specific, shared by model
  groups. These can be housed in language specific folders:
  =backends::cpp= and so on. For instance, the language specific stuff
  now in =formatters= should move here.
- different groups may express SML models differently; almost by
  definition, they will, or else there is little purpose in having
  multiple groups. For example, one can imagine a model group (say
  =pleat=) which expresses [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#add-support-for-language-agnostic-models-lam][LAM]] as a model that is identical on every
  supported language, ignoring native types; that is, expresses LAM as
  a LAM model. However, =quilt= would still express LAM as a mapping
  between generic LAM types and concrete native types (e.g. LAM
  dictionary is a C++ unordered map). A good candidate for =pleat=
  would be [[http://www.eclipse.org/modeling/emf/][eCore]].
- if one was to try to generate code that is identical to =protobuf=,
  the xsd tool, =odb=, etc one would generate model groups for these.
- we may need multiple "needles" for each model group. For example,
  the supporting libraries for =quilt= may be (and almost certainly,
  will be) totally different than that of those in =pleat=. And of
  course, needle would have different expressions in each programming
  language. So perhaps needle is more of a concept than a physical
  thing. We should rename it to something meaningful that represents
  "a library with supporting code for a given model group". However,
  it does make sense to have a top-level folder to house all of the
  supporting libraries, so maybe needle does exist physically as the
  namespace to house all of the different supporting libraries. For
  example: =dogen::needle::quilt=, etc.
- the different needle libraries should be pushed to the appropriate
  repositories (e.g. nuget for C# and maybe C++, biicode for C++,
  maven for Java, etc).
- in the model groups world, each model most likely will only support
  a single model group: for example either quilt or pleat, etc. This
  is because some types only make sense with a given model group (say
  for example a cross platform =String= type in pleat won't exist in
  quilt and so forth). This means one must filter the models one is
  loading depending on the model group. This applies to both internal
  and external models. Also a model group may support a different
  subset of programming languages compared to another model group.
- we need a better name than "model group". word-storming: dimension,
  universe, space, package, module, ensemble, generation unit,
  assembly.
- Another way to think about it is that model groups are really
  backends. Backends support one or more "languages" (we need a word
  to reflect variations such as XML). Only one backend can be enabled
  at one time. One or more languages can be enabled, depending on what
  the backend supports. The options that configure languages and
  backends are in the meta-data; it does not make sense to supply
  these in the command-line because the model is coupled with the
  backend to a large extent (for example, native types are only
  supported in the native backend and so on).
- model groups and type support: some types will only make sense with
  certain model groups. For example, if one were to create a "cross
  platform string type", say String, for =pleat= which would then be
  implemented in =needle::pleat= for all languages, it would not make
  sense to try to use this type from =quilt=. This means that we need
  some kind of way to associate types with a model group. In terms of
  code generation, the formatter "enabled/disabled" logic will kick
  in, and if the type has no formatters in a given backend, then it is
  effectively disabled. But one wonders if this is a sensible way to
  figure out what types are available to which model groups. Seems
  like one would have to spend a lot of time looking into the
  meta-data to determine whats available.
- we probably need to add the model group to the ownership hierarchy,
  but at present we cannot think of a use case for it; we never enable
  anything across languages in a model group. In the same vein, we
  would also need the language. Fields would then be
  =quilt.cpp.enabled= and so on.

This work must be integrated with the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*** Split a fully formed model from partial models                    :story:

We should really have two distinct types to represent the model that
is returned from the dia to sml transformer from the model returned by
the merger. Potentially this could be called =partial_model=.

In fact we may need to take this a step further and follow the same
approach as [[https://github.com/avao/Codge/tree/master/Src/Codge.DataModel][Cogen]]: having exactly the same types, but perhaps in a
separate namespace; one version represents the "connected" model and
the other the "disconnected" (or intermediate, or partial) model. The
idea being that on the connected model has references to types rather
than relaying on qname look-ups. So for example all the relationships
then become shared pointers to types and so on. The problem with this
approach is that we then need to have a common base type from where
all types inherit and this will mean that we will have to visit a lot
to dispatch types to their leaves.

Actually, this is also the chance to remove all of the qname
lookups. All relationships should just be boost shared pointers to
types rather than qnames. There should be no need for lookups at
all. This is a much better approach than the suggested below. We still
need qnames and some minor qname lookup (e.g. model is still made
up of a unordered map of qname to entity) but everyone should be using
entity pointers rather than qnames. It is not clear what models such
as CPP should be doing since the pointers are not particularly useful
there.

This would also be a good opportunity to use something like a pointer
container for all the pointers and then use either a "dumb pointer" or
even [[http://stackoverflow.com/questions/13874673/stdreference-wrappert-usage-in-a-container][references]] everywhere. Since we know the container will exist for
the duration of a run, we can rely on the objects being managed
elsewhere. This is a better way rather than using shared pointers
everywhere. Alexandrescu [[https://www.youtube.com/watch?v%3DQq_WaiwzOtI][discusses at length]] the side-effects of using
shared pointers. Whilst this is probably not a problem for Dogen, we
want to explore ways of doing the right thing. There is also the
[[https://vimeo.com/131189627][Josuttis talk]] on the subject.

In addition we will need support for concepts at the package level as
we need to have concepts with the same names for both partial and full
types. We should use namespaces to house these types instead of
postfixes/prefixes because there will be so many similarly named
types.

Properties will have types of the base type (=type=). We need a nested
type class. Modules will have types directly. We need a good name for
these (type references? something that alludes to referring to
existing types in the model).

Merged with other story:

Once the model has been merged and resolved, all qnames in the model
all known to resolve to a valid type, model or module. This means we
could cache in the qname itself a pointer to the object the qname
resolves into. There are two problems with this approach:

- we do not have a base class that covers types, models and
  module. one could be created (=modeling_entity=?) with an associated
  visitor. but then:
- formatters are not designed to think at the =modeling_entity= level;
  a formatter that does types may not necessarily be able to do
  modules or models. Thus we would need to convert from a
  =modeling_entity= to a type, model or module before we get to the
  formatter.

However one imagines that a great number of lookups would be avoided
if this was possible.

Actually we probably should have two different models for this. One
could be SML as we know it - just renamed - and the other one could be
the intermediate representation, etc.

Implementation tasks:

- rename all types to have a prefix such as =intermediate_=,
  e.g. =intermediate_model=, etc. Get all code to work with the new names.
- create a new model class with just a few properties (leaves, entities, etc).
- create a base class entity with all the required descendants.
- remove the type base class for intermediate.
- make entity visitable.
- rename the existing workflow to something like model factory; it
  takes in the intermediate models and generates a "final" model.
- update cpp code to use this new model.

*** Consider renaming formatter groups and model groups to sets       :story:

We should try to keep the words groups and sets to their mathematical
as much as possible - modulus our limited understanding. As such,
where we are using "group" we probably mean "set" since there is no
associated operation with the set; it is merely a way of gathering
elements.

Actually this rename should be part of the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*** Create a single container of element in model                     :story:

We did an experiment to figure out if it would be more efficient to
have separate containers of elements in SML's model, the idea being
that we would avoid using the heap, dispatching etc. We would also
create code that is more type-safe (e.g. avoid cases where we pass in
elements but we want a specific descendant only).

However, predictably, the code now has lots of loops across the
different collections. This pattern is scattered everywhere we use
SML. In almost all cases this could be handled by a single loop
without loss of type-safety (e.g. loop and visit where we need
specific types; just loop where an element suffices). Using the
traversals (all types traversals, etc) didn't help because we then
need to create all the associated machinery (overload =operator()=
etc.) and that is not much different from having a visitor on
element. We should consider this experiment at an end and just add a
single container of element in model and deal with the fallout.

Alternatively, we need a "view" over the different containers. In
truth after the SML workflow has finished executing the model is
constant. This means we could then use pointers to the objects to
create a synthetic element container and use this for looping over all
entities.

In an ideal world, this would be a property of the model:
e.g. =std::forward_list<entity*>=. However, we do not support pointer
containers and this is a non-trivial change to the spirit parser so we
won't be able to do it quickly. The alternative is to generate the
container from within the backend workflow for now and pass it to each
workflow. Once we are done with the refactoring we can then replace
this with a model property.

We need to have a look at all instances of the code where we loop
across all elements and see if this is a win or not. Also, we can move
=Element= from a concept to a type (e.g. =element=) and make it the
base class for all elements. Validator would have to make sure the
model is not nonsensical (object inheriting from a primitive, etc).

Merged stories:

Consider model as a container of types

At present model is composed of objects, primitives, concepts,
modules, etc. We could bring together all descendants of types into a
single container (e.g. types). However, in places we do thinks like
looking at the primitive container to see if the container has any
primitive types - these would become slower as we'd now be looking at
the entire type collection. Need to look at all usages of these
containers in the code to see if this would be a win or not.

*** Multi-purpose models per language                                  :epic:

#+begin_quote
This story is a very vague story that keeps track of ideas on making
dogen useful for code generators of other kinds.
#+end_quote

One of the stories in the backlog covers other targets of code generation:

[[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#add-support-for-thrift-and-protocol-buffers][Add support for thrift and protocol buffers]]

Originally we thought about adding support for these within a model;
that is to say, one would have additional serialisation "kinds"
available with a given dogen model. However, there is another way to
look at this; one could make other kinds of code generators using the
dogen infrastructure.

That is, contrary to it's name, dogen isn't just for "domain model
generation". Nothing stops one from building a protocol buffers or
thrift compiler using dogen infrastructure that outputs *exactly* the
same code as the original tools. All that would be required to do so
is:

- create a front-end that reads in their specification;
- to ensure SML is expressive enough to cover all of the aspects of
  the code that needs to be generated;
- to create the formatters.

In this view of the world, we have two options:

- create groups of facets within the =cpp= model; for example,
  the thrift group, the domain generation group etc. These are
  mutually incompatible sets of formatters and only one of them can be
  enabled for a given execution.
- create models at the same level of the =cpp= model. We could group
  them by language (e.g. the =cpp= namespace). However, this seems
  less practical because these models would probably have a lot in
  common. This is yet to be seen as we need to finish the large
  formatters refactor before we can answer this question.

Taking this to its logical consequence, even a tool as complex as ODB
could potentially be implementable in this way: one can conceive a
clang front-end that reads in source code and generates an SML model;
this model then can be used to generate C++ code that is identical to
the code produced by ODB (again assuming that SML is extended to be
expressive enough to represent all the constructs required by ODB).

This would be a compelling proposition if we had =stitch= because it
would make the generation of formatters quite trivial and would also
mean that people that want to create code generators don't have to
worry about a lot of the boilerplate code. However, the biggest
problem is that we'd be imposing a large and complex "framework" on
them with all the evilness that that entails.

Food for thought:

- in this light, a better name for dogen would be =codegen= (or =cogen=
  to make it a bit more unique in google). The tag line is then The
  Generic Code Generator. Unfortunately there are already a few
  projects with the name =cogen= so we may need to find a better
  name. Alternatively we can maintain the name dogen, but take away
  its meaning (i.e. no longer "The Domain Generator").
- the merge of =cpp= and =cpp_formatters= may not have been for the
  best in this case; it would make more sense to have a =cpp::dogen=
  where we collect all of the formatters related to domain
  generation - after the =cogen= rename; if no rename then we need
  some other name to imply domain generation. At this level we could
  then have =cogen::cpp::odb=, =cogen::cpp::protobuf= and so on. They
  all make use of the core types defined in =cogen::cpp=. The problem
  with this approach is that dogen is not really designed to share a
  namespace in this way. We won't be able to have a =cpp= project as
  well as placing other projects inside of the =cpp= namespace. We can
  have one or the other in the current setup, but not both. We could
  take the same approach as we did for test models: create a cpp
  folder and then put the model under a different name such as =model=
  or =domain= etc. Note that we still have to define all of the
  formatter interfaces in the "main" model, as well as workflows
  etc. However, some interfaces may not make sense for other models:
  what is a registrar in protocol buffers? If it exists at all, its
  probably something very different from boost serialisation and as
  such will require other data.
- note that this kind of grouping is not necessarily at the language
  level. For example, domain generation should be common to a set of
  languages, and so would protocol buffers. This means that rather
  than a facet or formatter grouping, we need a higher level construct
  to aggregate things; "domain generation" is made up of languages,
  languages are made of of facets, facets have formatters. We need a
  name/classification for "domain generation" in this context.

We should bear in mind [[http://st-www.cs.illinois.edu/users/droberts/evolve.html][this quote]]:

#+begin_quote
People develop abstractions by generalizing from concrete
examples. Every attempt to determine the correct abstractions on paper
without actually developing a running system is doomed to failure. No
one is that smart. A framework is a reusable design, so you develop it
by looking at the things it is supposed to be a design of. The more
examples you look at, the more general your framework will be.
#+end_quote

*** Models should have an associated language                          :epic:

#+begin_quote
*Story*: As a dogen user, I want to make sure I only use valid system
models so that I don't generate models that code generate but do not
compile.
#+end_quote

Certain models (e.g. system / library models) can only be used in a
give language; for example =boost= and =std= only make sense in C++. A
.Net library model would only make sense in .Net, etc. These are
Language Specific Models (LSM). Once a model depends on a LSM it
itself becomes an LSM and it should not be able to then make use of
models of other languages nor should one be able to request a code
generation for other languages.

However, one day we will have a system model which is a Language
Agnostic Model (LAM). The system model will provide a base set of
functionality across languages such as containers, and for each type
it will have mappings to language specific types. The mapping is
declared as dynamic extensions in the appropriate section
(i.e. =tags::cpp::mapped_type= or something of that ilk). If a model
depends only on LAMs, it is itself a LAM and can be used to generate
code on any supported language (presumably a supported language is
defined to be that for which we have both mappings and a code
generation backend).

A first step for this would be to have a language enumeration in SML
which is a property of the model, and one entry of which is "language
agnostic".

See also the model groups work.

See also the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*** Consider renaming SML                                             :story:

Originally we intended to rename SML - the Simplified Modeling
Language - to DDL - the Domain Driven Language. This was because we
had envisioned that SML was a model of the ideas in Domain Driven
Design, and not at all a cut down version of UML as the name seems to
imply. However, its becoming increasingly clear that, whilst we use a
lot of the Domain Driven Design ideas, we are also morphing them
considerably. Perhaps a more apt name would be SDML - the Simplified
Domain Modeling Language?

Or instead we could follow the compiler theme and call it the =ir= or
intermediate representation, or =im= for intermediate model. Actually
this is a confusing name because it clashes with the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/product_backlog.org#split-a-fully-formed-model-from-partial-models][partial model]]
notions we intend to introduce.

After more thinking on this, and since we now have a =backend= and a
=frontend=, it is obvious that SML is the =middle_end= since it is the
middle-end of the code generation process. So it could be the
Middle-End Model (MEM) or just Middle-End (ME).

However, this is not a very good name for the model as we also do some
front-end-y things (such as the JSON implementation). =ir= and =im=
still seem like the more likely candidates. Actually, JSON is not a
front-end; it is a direct representation of the middle-end into a
file. The same could also be done in XML. It only becomes a front-end
if there is an intermediate representation (such as the =dia= model)
that needs to be transformed into SML.

Another idea: common representation or =cr=. It is what is common to
all modeled languages. What is not common goes into dynamic. This will
also make the vision for this model much more focused.

Some more thinking on this: SML is a meta-model, or a model that
provides a language to talk about programming objects in
general. There may be other models suitable for formatting; for
example one may want to take a model of a neuron and represent it in
[[http://www.neuron.yale.edu/neuron/static/docs/refman/hoc.html][HOC]]. In this case the formatters would bind directly to the neuron
model rather than SML. So the name of SML must reflect the fact that
it is a model of programming objects. Object-Oriented Programming
Language Model?

*** Add "model types"                                                 :story:

At present we have a number of dynamic extensions that exist purely to
deal with non-dogen models:

- supported: is the facet supported by the external model
- file_name: what is the external model naming for files for this
  facet
- is_system: is the file name a system include file or not?

In reality, all of this could be avoided if we had a way of
distinguishing between models that follow dogen conventions and those
who do not; a "model type" of sorts such as "external" and "dogen" -
naming needs more thought. With this we could infer the rest: if no
file name is supplied then a given formatter/facet is not supported;
if the model is_system then all types are system and so on.

We should also have a flag in field definitions that verify that a
parameter is only present if the model is a non-dogen model. For
example, it makes no sense to supply =cpp.type.family= in a dogen
model but it may make sense to do so in an external model. However,
this would mean that if a user manually adds a type to a dogen model
it cannot be extended. Requires a bit of thinking.

This work must be integrated with the [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetype work]].

*** Consider reducing the number of qname lookups in cpp model        :story:

At present we are using qnames all over the place in CPP. Nothing
stops us from using strings instead of qnames if that is more
efficient.

What is worse is that we seem to be doing a ridiculous amount of qname
lookups. It would be much nicer if we could somehow have all the data
in the right shape to avoid doing so many lookups.

*** Refactor code around model origination                            :story:

In the past we added a number of knobs around generation, all with
their own problems:

- =origin_types=: was the model/type created by the user or the
  system. in reality this means did the model come from Dia or
  JSON. this is confusing as the user can also add JSON files (their
  own model library) and in the future the user can use JSON
  exclusively without needed Dia at all.

- =generation_types=: if the model is target, all types are to be
  generated /unless/ they are not properly supported, in which case
  they are to be "partially" generated (as is the case with
  services). This is a formatter decision and SML should not know
  anything about it.

These can be replaced by a single enumeration that indicates if the
type/model is target or not.

This work should be integrated with the model types story.

*** Consider renaming includers                                       :story:

Its very confusing to have header files that include lots of other
header files called "includers". There is too much overloading. We
should consider calling them "master header files" as per Schaling
terminology in the [[http://theboostcpplibraries.com/boost.spirit][boost book]].

*** Consider renaming general settings                                :story:

A while ago we came up with this name for the settings of the generic
formatter model. This is the model with basic infrastructure to be
reused by the more specialised formatters. However, now that we have
many (many) settings classes, general settings may not be the most
appropriate name. We need to look a bit more deeply into the role of
this class and see if a better name is not available.

We could call it preamble settings because all settings are related to
the file preamble; annoyingly, we also generate a post-amble from
it. There doesn't seem to be any good names for the pair (preamble,
post-amble). In networking this would be called frame markers perhaps.

Now that we are not using =meta_data= any more, perhaps we could
re-purpose it for this (=meta_data_settings=). In a way, preambles and
post-ambles are meta-data, as opposed to the real file
contents. Having said that, one could say the same about any kind of
comments.

We could also use [[http://www1.appstate.edu/~yaleread/typographichierarchy.pdf][typography terminology]]: headers and footers.

Now that we have subsidiary settings and principal settings do we need
the rename? We should consider "universal settings" maybe.

In addition, the convention is now that "settings" mean a strongly
typed representation of =dynamic= data; general "settings" are not
settings in this sense. However, we do need a class to model settings
properly (i.e. to mirror dynamic exactly, without any
transformations).

In truth, =annotation= is probably sufficient - or perhaps
=annotation_properties=. It could then have an =enabled= property to
replace =generate_preamble=. This is more accurate due to the
preamble/postamble setup explained above. In this setup, we'd have
=annotation_settings= to map to dynamic data, with an annotation
settings factory which reads these off of dynamic object; then, an
annotation factory to generate annotations. Finally, we can introduce
the annotation formatter to generate the portion of boilerplate
related to just the annotation. Boilerplate formatter collaborates
with annotation formatter.

In terms of [[https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_69.org#thoughts-on-cpp-refactoring][archetypes]], one would annotate an archetype which makes
conceptual sense.

*** Set enumeration underlying type in SML                            :story:

In cpp transformer we have hacked the underlying type of the
enumeration. Remove this hack and set it in SML. Still a hack, but
a tad better.

*** Move language-specific object types to meta-data                  :story:

There are a number of object types that exist solely to provide the
method helpers with information:

- smart_pointer
- hash_container
- sequence_container
- ordered_container

These should be conveyed using the meta-data.

*** Handling of managed directories is incorrect                      :story:

At present we are querying the dia to sml transformer to figure out
what the managed directories are. These are basically the top-level
directories from where we want the housekeeper to operate. In reality
this is (or can be placed) in the meta-data. We should be able to
extract the managed directories from the meta-data as a step in one of
the workflows.

This can be done by the backend. It does mean that we should be
returning a composite type from generation:

- list of files;
- list of managed directories.

Alternatively we could have a =managed_directories= method that takes
in an SML model and then internally reads in the meta-data for a given
model to produce the list.

*Merged with previous story*

Compute managed directories from knitting options

At present the backend is returning empty managed directories. This
means housekeeping will fail in the new world. We need to change the
interface of this method to take in the knitting options and return
the managed directories.

This is not entirely trivial. At present the managed directories are
computed in the locator. It takes into account split project, etc to
come up with all the directories used by the backend. We need to make
these decisions during path expansion, expect we only need manged
directories for the root object. However we do not know which object
is the root object at present, during the expansion. We could identify
it via the QName and the SML model in context thought. We could then
populate the managed directories as a text collection. We then need
some settings and a factory to pull out the managed directories from
the root object. This could be done in =managed_directories=, by
having an SML model as input.

*** Consider creating a "locator" like class for path management      :story:

At present we are using path settings to compute paths in several
places. Most of these exist because of hacks but it still seems that
it needs to be done in more than one place. We should consider
something like =sml_to_cpp::locator= that is initialised with the path
settings and can then be used to create paths.

*** Add include providers for all types                               :story:

We need to implement the provider container support for primitives,
modules and concepts.

Update:

- inclusion dependencies factory
- provider container

*** Implement all formatter interfaces                                :story:

We still have a couple of skeleton interfaces:

- primitve
- concepts

*** Factor all =housekeeping_required= methods into one               :story:

In knit model we seem to have several of these: =housekeeping_required=.

*** Remove unused features                                             :epic:

At the very start of dogen we added a number of features that we
thought were useful such as suppressing model directory, facet
directories etc. We should look at all the features and make a list of
all features that we are not currently making use of and create
stories to remove them.

We may have to split this story into several but we should at least
trim down the obvious ones:

- empty model name (done)
- output to stdout (done)
- keys, entities (done)
- remove repository, factory, stereotypes (done)
- versioning (done)
- split project (or vice-versa, whichever one we don't use).
- removing cpp backend?
- delete extra files: we always do so why make it optional.
- force write: we never do.
- etc.

Basically any feature which we are not using at present and cannot
think of an obvious use case.

*** Do not compute inclusion directives for system models             :story:

It seems we are computing inclusion directives and other path
derivatives for system models:

: {
:   "__type__": "dogen::cpp::expansion::path_derivatives",
:   "file_path": "/home/marco/Development/DomainDrivenConsulting/output/dogen/clang-3.5/stage/bin/../test_data/all_primitives/actual/std/include/std/serialization/unique_ptr_fwd_ser.hpp",
:   "header_guard": "STD_SERIALIZATION_UNIQUE_PTR_FWD_SER_HPP",
:   "inclusion_directive": "<quote>std/serialization/unique_ptr_fwd_ser.hpp<quote>"
: }

This comes out of the workflow, so we possibly are then ignoring it
for the non-target types. So:

- can we avoid computing these altogether?
- are we ignoring it?

Actually this is the usual problem with the "origin" of the type. We
need a way to determine if this type needs computations or not. We
need to create a story to clean up the =origin_type= and
=generation_type= and then we can make use of it to determine if we
need to compute inclusion, path etc or not.

*** Header guard in formatters should be optional                     :story:

At present we are relying on empty header guards to determine what to
do in boilerplate. We should use boost optional.

*** Remove complete name and use qualified name                       :story:

At present we have both complete name and qualified name in
formatables. Qualified name is blank. We should remove complete name
and populate qualified name.

This is in nested type info.

*** Remove intermediate fields from dynamic                           :story:

With the previous approach we had fields in dynamic that were
generated within dogen; we now should only have fields that are set
from the outside world. Remove all of the fields that are not supposed
to be settable from the outside world. At present this just file path.

*** Create knitter options for each frontend                          :story:

At present some knitting options are specific to a frontend
(particularly in troubleshooting). We should create different classes
to represent options on a per fronend basis.

*** Remove unnecessary properties from model                          :story:

The model should be just dumb container of types. We have a few legacy
properties left behind from the days where the model was also used in
the transformation process. Remove all the concepts from the model
(=Element= etc) and deal with the fall out. Unnecessary properties:
documentation, containing module, extensions.

We need to keep the name because it is now used to locate the model's
module.

*** Include groups                                                    :story:

#+begin_quote
*Story*: As a dogen user, I want to create includers for user defined
groups of files so that I don't have to do it manually.
#+end_quote

One of my personal preferences has always been to group includes by
"library". Normally first come the C includes, then the standard
library ones, then boost, then utilities and finally types of the same
model. Each of these can be thought of as a group. Inside each group
the file names are normally ordered by size, smallest first. It would
be nice to have support for such a feature in Dogen.

Formatters would then push their includes into the correct
group. Group names could be the model name (=std=, etc).

A bit of a nitpick but nice nonetheless.

*** Consider renaming registrar in boost serialisation                :story:

At present we have a registrar formatter that does the boost
serialisation work. However, the name =registrar= is a bit too
generic; we may for example add formatters for static registrars. We
should rename this formatter to something more meaningful. Also the
name registrar is already well understood to mean static registrar.

This is a big problem now that we cannot add a type with the name
registrar to the main model as it clashes with the serialisation
registrar.

*** Add support for formatter and facet dependencies                  :story:

Once we are finished with the refactoring of the C++ model, we should
add a way of declaring dependencies between facets and between
formatters. We may not need dependencies between facets as these are
actually a manifestation of the formatter dependencies.

These are required to ensure users have not chosen some invalid
combination of formatters (for example disable serialisation when a
formatter requires it). It is also required when a given
facet/formatter is not supported (for example when an STL type does
not support serialisation out of the box).

Note that the dependencies are not just static. For example, the types
facet depends on the hash facet if the user decides to add a
=std::unordered_map= of a user defined type to another user defined
type. We need to make sure we take these run-time dependencies into
account too.

** Deprecated
*** CANCELLED Injection framework                                      :epic:
    CLOSED: [2015-07-09 Thu 21:26]

*Rationale*: We should inject types on a case-by-case basis. At
present we have covered all use cases in a fairly sensible way.

We need a more generic way of handling system types injection into
models. This is because there is a number of things that can be
derived from the existing model types:

- keys
- diff support
- reflection
- cache code
- etc.

So we need to:

- make injector a composite of injectors that do the real work such as
  =key_injector=. internally =injector= just delegates the work to
  these classes.
- injector decides which internal injectors to use based on options
  passed in.
- in the IoC spirit, we should probably create a =injector_interface=.

*** CANCELLED IoC work                                                 :epic:
    CLOSED: [2015-07-09 Thu 21:28]

*Rationale*: this is a lot of work and does not buy us much. We should
tackle each IoC requirement at a time.

All stories related to IoC work are tracked here.

*New Understanding*:

in reality, there is really only one place where IoC makes sense: in
the workflows. It would be great if one could pass in something akin
to a IoC container into the workflow's constructor and then use the
container to obtain access to all services via interfaces. Using
sml::workflow as an example, one could have:

- container_interface which returns grapher_interface,
  processor_interface, etc.
- the container could even return references to the these interfaces
  and own the lifetime of the objects.
- this would then allow us to provide mock container interface
  implementations returning mock services.

However:

- it seems like a lot of moving parts just to allow testing the
  workflow in isolation. this is particularly more so in the case of
  the workflows we have, which are fairly trivial. perhaps we should
  consider this approach when dogen is generating the interfaces
  automatically as this would require a lot of manual work for little
  gain.

*Old understanding*:

- add workflow_interface to SML.
- we should be doing a bit more IoC, particularly with inclusion
  manager, location manager etc. In order to do so we could define
  interfaces for these classes and provide mocks for the tests. This
  would make the tests considerably smaller.
*** CANCELLED Log analysis tool                                       :story:
    CLOSED: [2015-07-09 Thu 21:35]

*Rationale*: we will incubate these ideas on its own project.

We should create a log analyser tool (=logan=?), as follows:

- separate repo. it could be incubated in dogen to start off with
  though.
- use a dogen model to describe the tool's domain. Very simple domain.
- use the dogen version line to determine the application, the version
  and the run time. All other entries are foreign-keyed against this
  entry.
- use JSON object markers to extract JSON objects from the log line
  into a postgres JSON field.
- use ODB to create the database schema.
- create a simple parser that is hard-coded to the log lines in dogen,
  with perhaps an addition for threads.
- when profiling is present, have a way to split profiling information
  from the rest.
- create some simple stored procs that compare two runs from a
  performance perspective.
- create a stored proc to list all errors and all warnings, with
  perhaps some lines around it.
- create a stored proc that does a text search using postgres text
  search facilities.
- we need to figure out how splunk decides to start loading the log
  files (only after roll, incrementally - and if so, how does it keep
  track, etc).

*** CANCELLED Create a trivial Linux gcc script                       :story:
    CLOSED: [2015-07-09 Thu 21:35]

*Rationale*: we want to move away from complicated CDash scripts. We
should stick with what we got for valgrind, and use travis etc for any
new developments.

The previous attempts to clean up the build environment were too
elaborate given the available time. We need to go back to basics with
a trivial script that works for Linux 32-bit and 64-bit with gcc.

*** CANCELLED Create a trivial Linux clang script                     :story:
    CLOSED: [2015-07-09 Thu 21:35]

*Rationale*: we want to move away from complicated CDash scripts. We
should stick with what we got for valgrind, and use travis etc for any
new developments.

We need to be able to build Linux clang 32-bit and 64-bit again.
*** CANCELLED Handle unnamed models properly                          :story:
    CLOSED: [2015-07-10 Fri 10:48]

*Rationale*: we do not have a use case for this.

The option disable model name was meant to allow the generation of
flat models, without any folders or namespaces for the model
name. However, as a side-effect, this also means the artefacts being
generated do not have any names. This resulted in the creation of a
libSTATIC, purely because the next command in the cmake add_library is
STATIC (e.g. static library). As a quick hack, when an empty model
name is detected, a model named "unnamed_model" is created.

The correct solution for this is to have a flag (or flags) at the SML
level which state whether to use the model name for folders, packages,
etc. The view model generation will then take this into account.
*** CANCELLED All model items traversal should resolve types          :story:
    CLOSED: [2015-07-10 Fri 15:37]

*Rationale*: This has been fixed.

This traversal was designed for tagger but yet it does not resolve
=type= into one of the sub-classes, forcing tagger to implement
visitation to resolve the types. We should improve the traversal.

*** CANCELLED Add tests for tagging of modules, primitves and enumerations :story:
    CLOSED: [2015-07-10 Fri 15:40]

*Rationale*: story has bit-rotted and doesn't make a lot of sense any
more.

We've tested abstract objects et al quite a lot but forgotten the
other aspects of the model.

*** CANCELLED Check concept properties for identity                   :story:
    CLOSED: [2015-07-10 Fri 15:41]

*Rationale*: identity properties have been removed.

When we added concepts we didn't had a link to the processing of
identity attributes. This means that if we get a property via modeling
a concept it is not processed and added to the keys.

Update injector to follow concepts.
