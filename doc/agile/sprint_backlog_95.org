#+title: Sprint Backlog 95
#+options: date:nil toc:nil author:nil num:nil
#+todo: STARTED | COMPLETED CANCELLED POSTPONED
#+tags: { story(s) epic(e) }

* Mission Statement

- Finish C# support.

* Stories

** Active

#+begin: clocktable :maxlevel 3 :scope subtree :indent nil :emphasize nil :scope file :narrow 75 :formula %
#+CAPTION: Clock summary at [2017-01-12 Thu 14:43]
| <75>                                                                        |         |       |      |       |
| Headline                                                                    | Time    |       |      |     % |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| *Total time*                                                                | *66:49* |       |      | 100.0 |
|-----------------------------------------------------------------------------+---------+-------+------+-------|
| Stories                                                                     | 66:49   |       |      | 100.0 |
| Active                                                                      |         | 66:49 |      | 100.0 |
| STARTED Sprint and product backlog grooming                                 |         |       | 0:35 |   0.9 |
| COMPLETED Edit release notes for previous sprint                            |         |       | 0:57 |   1.4 |
| COMPLETED Consider supporting multiple inheritance on non-proxy models      |         |       | 3:24 |   5.1 |
| COMPLETED Add basic validation infrastructure                               |         |       | 8:40 |  13.0 |
| COMPLETED Fix borked windows build                                          |         |       | 0:26 |   0.6 |
| COMPLETED Clean up enumerator implementation                                |         |       | 1:05 |   1.6 |
| COMPLETED Measure validation slowdown                                       |         |       | 6:38 |   9.9 |
| COMPLETED Parsing should support dot notation                               |         |       | 2:54 |   4.3 |
| COMPLETED Analysis for changes required in order to support containers      |         |       | 3:15 |   4.9 |
| COMPLETED Add support for object based container types in C#                |         |       | 5:48 |   8.7 |
| COMPLETED Understand the behaviour of helpers and assistants                |         |       | 1:13 |   1.8 |
| CANCELLED Add support for generic parents in yarn                           |         |       | 0:35 |   0.9 |
| COMPLETED Fix assorted windows warnings                                     |         |       | 0:19 |   0.5 |
| COMPLETED Build dogen on windows locally                                    |         |       | 7:32 |  11.3 |
| COMPLETED Fix borked windows build                                          |         |       | 1:54 |   2.8 |
| COMPLETED Generate windows packages with WIX                                |         |       | 3:28 |   5.2 |
| COMPLETED Add validation around instatitation of abstract classes           |         |       | 2:25 |   3.6 |
| COMPLETED Add validation to ensure enumerators do not have types            |         |       | 0:21 |   0.5 |
| COMPLETED Add appveyor support for bintray                                  |         |       | 2:23 |   3.6 |
| STARTED Add upsilon support                                                 |         |       | 5:39 |   8.5 |
| STARTED Add auxiliary function properties to c#                             |         |       | 1:11 |   1.8 |
| STARTED Add internal object dumper resolution                               |         |       | 4:51 |   7.3 |
| STARTED Add support for generic container types to C#                       |         |       | 1:16 |   1.9 |
#+TBLFM: $5='(org-clock-time% @3$2 $2..$4);%.1f
#+end:

*** STARTED Sprint and product backlog grooming                       :story:
    CLOCK: [2017-01-07 Sat 13:41]--[2017-01-07 Sat 13:46] =>  0:05
    CLOCK: [2017-01-03 Tue 17:06]--[2017-01-03 Tue 17:11] =>  0:05
    CLOCK: [2017-01-03 Tue 17:02]--[2017-01-03 Tue 17:06] =>  0:04
    CLOCK: [2016-12-28 Wed 12:02]--[2016-12-28 Wed 12:23] =>  0:21

Updates to sprint and product backlog.

*** COMPLETED Edit release notes for previous sprint                  :story:
    CLOSED: [2016-12-28 Wed 13:01]
    CLOCK: [2016-12-28 Wed 13:06]--[2016-12-28 Wed 13:23] =>  0:17
    CLOCK: [2016-12-28 Wed 13:02]--[2016-12-28 Wed 13:05] =>  0:03
    CLOCK: [2016-12-28 Wed 12:49]--[2016-12-28 Wed 13:01] =>  0:12
    CLOCK: [2016-12-28 Wed 12:23]--[2016-12-28 Wed 12:48] =>  0:25

Add github release notes for previous sprint.

Title: Dogen v0.94.0, "Baía dos Tigres"

#+begin_src markdown
Overview
=======
The sprint's headline feature is the continued work on the C# kernel. It is still considered experimental and the generated code has an unstable API, liable to change without notice.

User visible changes
===============

In this sprint, a number of user visible features were added to C#:

- **improvements in the ```Types``` facet**: support for exceptions and enumerations, initial immutability support, complete constructors, improvements around equality, associations and inheritance with other model types, as well as support for modules (namespaces).
- **basic ```IO``` facet support**: dumping the POCOs as a JSON stream. The JSON format is the same as used in C++.
- **basic ```Test Data``` facet support**: We tried to use C# idioms for this, so Sequence Generators are based on ```IEnumerable```.

Please refer to the test data sets for the sample model:

- input: [Dia](https://github.com/DomainDrivenConsulting/dogen/blob/master/test_data/yarn.dia/input/CSharpModel.dia), [JSON](https://github.com/DomainDrivenConsulting/dogen/blob/master/test_data/yarn.json/input/CSharpModel.json)
- output: [CSharpModel](https://github.com/DomainDrivenConsulting/dogen/tree/master/projects/test_models/CSharpModel)
- tests: [CSharpModel.Tests](https://github.com/DomainDrivenConsulting/dogen/tree/master/projects/test_models/CSharpModel.Tests)

C# development is being validated at present with Mono and MonoDevelop from Xamarin's Alpha channel, but should work equally well with any recent versions of Visual Studio.

For more details of the work carried out this sprint, see the [sprint log](https://github.com/DomainDrivenConsulting/dogen/blob/master/doc/agile/sprint_backlog_94.org).

Next Sprint
========
The next sprint will continue to focus on C#, particularly the addition of collections.

Binaries
======
You can download experimental binaries from [Bintray](https://bintray.com/domaindrivenconsulting/Dogen) for OSX and Linux:

- [dogen_0.94.0_amd64-applications.deb](https://dl.bintray.com/domaindrivenconsulting/Dogen/0.94.0/dogen_0.94.0_amd64-applications.deb)
- [dogen-0.94.0-Darwin-x86_64.dmg](https://dl.bintray.com/domaindrivenconsulting/Dogen/0.94.0/dogen-0.94.0-Darwin-x86_64.dmg)

**Note**: They are produced by CI so they may not yet be ready.

For all other operative systems you need to build it from source. Source downloads are available below.
#+end_src

- [[https://twitter.com/MarcoCraveiro/status/808591399855734784][Tweet]]

*** COMPLETED Consider supporting multiple inheritance on non-proxy models :story:
    CLOSED: [2016-12-28 Wed 17:25]
    CLOCK: [2016-12-28 Wed 16:03]--[2016-12-28 Wed 17:25] =>  1:22
    CLOCK: [2016-12-28 Wed 14:01]--[2016-12-28 Wed 16:03] =>  2:02

We need to be able to express relationships such as the ones used by
C# containers. But first we need to build an inheritance graph of all
relevant collections.

Notes:

- if we have leaves at all levels of an hierarchy, we may need to map
  them to the base class. Actually, in practice, we only care about
  leaves at the base class level.
- we need to know which root parent we are visiting. So presumably the
  question is: did we use root parent as a short-hand for visitation
  root?
- equals method is using root parent because apparently "service leafs
  are not being processed atm". We should remove this check and add a
  method to assistant that checks there is one root parent.
- we need to (should?) introduce the validator to ensure non-proxy
  model objects have only one parent and root parent.

Validation check removed from transformer:

:        /*
:         * Ensure we have at most one parent as we do not support
:         * multiple inheritance for objects.
:         */
:        if (parent_names.size() > 1) {
:            BOOST_LOG_SEV(lg, error) << multiple_inheritance
:                                     << po.id();
:            BOOST_THROW_EXCEPTION(transformation_error(multiple_inheritance +
:                    po.id()));
:        }

*** COMPLETED Add basic validation infrastructure                     :story:
    CLOSED: [2017-01-03 Tue 17:50]
    CLOCK: [2017-01-03 Tue 17:12]--[2017-01-03 Tue 17:55] =>  0:43
    CLOCK: [2017-01-03 Tue 16:48]--[2017-01-03 Tue 17:01] =>  0:13
    CLOCK: [2017-01-03 Tue 16:37]--[2017-01-03 Tue 16:47] =>  0:10
    CLOCK: [2017-01-03 Tue 14:46]--[2017-01-03 Tue 16:36] =>  1:50
    CLOCK: [2017-01-03 Tue 13:51]--[2017-01-03 Tue 14:45] =>  0:54
    CLOCK: [2017-01-03 Tue 11:18]--[2017-01-03 Tue 12:51] =>  1:33
    CLOCK: [2017-01-03 Tue 11:01]--[2017-01-03 Tue 11:18] =>  0:17
    CLOCK: [2017-01-03 Tue 09:50]--[2017-01-03 Tue 10:40] =>  1:28
    CLOCK: [2016-12-28 Wed 20:24]--[2016-12-28 Wed 21:25] =>  1:01
    CLOCK: [2016-12-28 Wed 19:21]--[2016-12-28 Wed 20:23] =>  1:02
    CLOCK: [2016-12-28 Wed 17:29]--[2016-12-28 Wed 17:36] =>  0:07

The objective of this story is to create enough of the validation
infrastructure required to ensure non-proxy models do not have
multiple inheritance. We should add a couple of other validation rules
to make sure the infrastructure is good enough. All other validation
work will be moved to the backlog.

Implemented checks:

*Merged model checks*

- enumerator name must not be empty
- enumerator name must be unique
- model name is non-empty.
- property must have non-empty name.
- duplicate checks: properties cannot have duplicate names; classes in
  a package cannot have the same name; namespaces at the same level
  cannot have the same name;
- type_name is non-empty; cannot be blank or a variable name
- type names, model names, etc must not contain spaces or other
  invalid characters. They should also not be a keyword on the target
  language (e.g. =if=, =default=, etc.). We should use a identifier
  parser for name validation. We should have a data file that lists
  keywords by language. See [[http://en.cppreference.com/w/cpp/keyword][C++ keywords]]. This is done in merged model
  to ensure we can report provenience correctly. Note that we need to
  be careful with built in models; these will use "invalid" type names
  such as =int= etc.
- all properties of types in current model must exist.
- parent names and original parent names must exist in current model
  (resolver?)
- multiple inheritance is only allowed on non-proxy models.
- refined concepts must not have properties (or methods) with clashing
  names.
- type name must not exist on any model: basically detect duplicate
  element names. At present we simply silently drop duplicates.
- leaves exist in current model.

*Previous Understanding*

#+begin_quote
*Story*: As a dogen user, I want to know exactly why my diagram is not
correct so that I can fix the issues. I also want dogen to pick up
errors and generate valid code so that I don't have to figure out what
went wrong by looking at the generated code and the compiler errors.
#+end_quote

We need a class responsible for checking the consistency of the yarn
model.

*** COMPLETED Fix borked windows build                                :story:
    CLOSED: [2017-01-03 Tue 22:02]
    CLOCK: [2017-01-03 Tue 21:35]--[2017-01-03 Tue 22:01] =>  0:26

We've borked the windows build with the validator changes.

:  C:\projects\dogen\projects\yarn\src\types\model_validator.cpp(48): error C2079: 'cpp_reserved' uses undefined class 'std::array<std::string,81>' [C:\projects\dogen\build\output\msvc\Debug\projects\yarn\src\yarn.vcxproj]
:  C:\projects\dogen\projects\yarn\src\types\model_validator.cpp(62): error C2440: 'initializing': cannot convert from 'initializer list' to 'int' [C:\projects\dogen\build\output\msvc\Debug\projects\yarn\src\yarn.vcxproj]
:  C:\projects\dogen\projects\yarn\src\types\model_validator.cpp(64): error C2079: 'cpp_builtins' uses undefined class 'std::array<std::string,11>' [C:\projects\dogen\build\output\msvc\Debug\projects\yarn\src\yarn.vcxproj]

*** COMPLETED Clean up enumerator implementation                      :story:
    CLOSED: [2017-01-03 Tue 22:37]
    CLOCK: [2017-01-03 Tue 22:29]--[2017-01-03 Tue 22:37] =>  0:08
    CLOCK: [2017-01-03 Tue 22:03]--[2017-01-03 Tue 22:28] =>  0:25
    CLOCK: [2017-01-03 Tue 18:30]--[2017-01-03 Tue 19:02] =>  0:32

- make enumerator nameable, and compute name correctly (qualified,
  etc). This makes it conceptually consistent
- move value computations to yarn so that in the future we can add
  meta-data to override it.

*** COMPLETED Add unit test benchmarking                              :story:
    CLOSED: [2017-01-04 Wed 16:03]

*Rationale*: the new benchmark infrastructure - external to the c++
code - is good enough.

#+begin_quote
*Story*: As a dogen developer, I would like to know if any of my
changes impact performance so that I can address these problems early.
#+end_quote

*New understanding*:

Create a set of performance specific tests. These wont get executed by
regular users (e.g. they are not part of =run_all_specs=) but they do
get executed in the build machine. These are selected tests with big
loops (say 1M times) doing things like reading dia diagrams etc. We
could chose a few key things just to give us some metrics around
performance.

In fact, we could create a set of colossi models: models with really
large number of classes (say 500), maybe 5 of these with
references. We could then use the diagrams to test the individual
workflows: dia, dia_to_sml, cpp and engine with no writing. We should
avoid writing files to filesystem to avoid number jitter caused by the
hard drive. There should be no comparisons between actual and expected
for the same reason.

We need to make sure the benchmark tests won't run on valgrind or else
the nightly builds will take over 24 hours. However, if we had it
running on continuous we'd spot regressions on every check-in. But we
don't want to delay continuous any more than necessary. Perhaps we
need a separate build called performance which is also continuous and
only runs these tests. We could pass in some kind of variable to CMake
so that if performance is on, it ignores all tests other than
performance and vice-versa. We'd also need a performance target that
only builds the performance binary, and a =run_performance= target
that executes it.

Perhaps we could use a ruby script to generate the test models?

Also, investigate nonius:

https://github.com/rmartinho/nonius

*Old understanding*:

[[https://svn.boost.org/trac/boost/ticket/7082][Raised ticket]]

- nightly builds should run all unit tests in "benchmarking mode";
- for each test we should find the sweet spot for N repetitions;
- when plugged into ctest, make sure the benchmark tests have
  different names from the main tests otherwise the timing history
  will be nonsense.
- [[http://lists.boost.org/boost-users/2011/01/65790.php][sent]] email to boost users mailing list asking for benchmarking
  support.
- some tips on using chrono to benchmark [[http://www.cookandcommit.eu/2014/11/simple-macro-for-algorithms-time.html][here]].

*** COMPLETED Measure validation slowdown                             :story:
    CLOSED: [2017-01-04 Wed 16:21]
    CLOCK: [2017-01-04 Wed 16:10]--[2017-01-04 Wed 16:21] =>  0:11
    CLOCK: [2017-01-04 Wed 13:41]--[2017-01-04 Wed 16:09] =>  2:28
    CLOCK: [2017-01-04 Wed 11:49]--[2017-01-04 Wed 11:56] =>  0:07
    CLOCK: [2017-01-04 Wed 11:34]--[2017-01-04 Wed 11:48] =>  0:14
    CLOCK: [2017-01-04 Wed 09:01]--[2017-01-04 Wed 11:33] =>  2:32
    CLOCK: [2017-01-03 Tue 22:37]--[2017-01-03 Tue 23:43] =>  1:06

*Rationale*: The new benchmark infrastructure points to a small change
in knit tests, and not a lot of movements in model generation. The
movement is signed-off.

It appears generating the dogen models is a lot slower with validation
enabled. We need to measure this using the traditional benchmark. If
there is really a slowdown, we need to add a command line flag to
enable validation (disabled by default). This makes sense from a
workflow perspective - one can occasionally check if the model is not
quite right, but its probably not a requirement to always check
validation.

One of the reasons for the slowdown is probably the use of regular
expressions to validate names. It is probably faster to hard-code a
validator by hand, given that the regex is so trivial.

Actually, having to manually benchmark is a pain in the backside. We
need a simple script that performs a number of runs and records all
the data in a CSV. We can then easily perform measurements (std dev,
etc) and diff runs.

: echo "elapsed real time, filesystem inputs, filesystem outputs, Max RSS, Avg RSS, Avg total memory, Avg unshared, Avg shared, Page faults, Soft page faults" > bench.csv && /usr/bin/time -f "%e,%I,%O,%M,%t,%K,%D,%X,%F,%R" -o bench.csv -a ./dogen.knit.tests

Links:

- [[https://gist.github.com/bytespider/3864921][bytespider/benchmark.sh]]

**** Manual Measurements

*Knit tests Validation Off*

: $ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real  0m8.360s
: user  0m6.340s
: sys     0m1.780s
: $ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real    0m9.576s
: user    0m6.556s
: sys     0m1.620s
: $ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real    0m8.852s
: user    0m6.752s
: sys     0m1.780s

*Knit tests Validation On*

: [marco@lorenz bin(integration)]$ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real    0m9.755s
: user    0m7.524s
: sys     0m1.964s
: $ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real    0m10.323s
: user    0m6.720s
: sys     0m1.684s
: $ time ./dogen.knit.tests
: Running 61 test cases...
:
: *** No errors detected
:
: real    0m9.172s
: user    0m7.216s
: sys     0m1.884s

An increase of around 1s - 1.5s.

*** COMPLETED Parsing should support dot notation                     :story:
    CLOSED: [2017-01-04 Wed 22:20]
    CLOCK: [2017-01-04 Wed 22:21]--[2017-01-04 Wed 22:42] =>  0:21
    CLOCK: [2017-01-04 Wed 22:17]--[2017-01-04 Wed 22:20] =>  0:03
    CLOCK: [2017-01-04 Wed 20:31]--[2017-01-04 Wed 22:16] =>  1:45
    CLOCK: [2017-01-04 Wed 17:45]--[2017-01-04 Wed 17:55] =>  0:10
    CLOCK: [2017-01-04 Wed 17:09]--[2017-01-04 Wed 17:44] =>  0:35

At present we only support the c++ scope operator =::= as a separator
for fully qualified names in a model. However, it probably would be
quite trivial to have a "mode" in the parser and support either =.= or
=::=, depending on a construction-supplied flag (inferred from the
model language). This would allow C# users to enter their model in a
more natural way, instead of forcing them to use C++ notation.

Notes:

- we seem to use a different parser for the external modules, which
  means that we are still using the C++ scope operator for those even
  after fixing the parser. We need to update the name builder to infer
  the scope delimiter.
- in fact we have multiple sources of names with scopes: a) parent
  names via the meta-data (parsing expander via name builder) b) model
  name via file name (name builder) c) external module path via
  meta-data (name builder).

*** COMPLETED Analysis for changes required in order to support containers :story:
    CLOSED: [2017-01-07 Sat 13:43]
    CLOCK: [2017-01-05 Thu 10:05]--[2017-01-05 Thu 12:22] =>  2:17
    CLOCK: [2017-01-05 Thu 09:03]--[2017-01-05 Thu 09:15] =>  0:12
    CLOCK: [2017-01-04 Wed 16:22]--[2017-01-04 Wed 17:08] =>  0:46

Notes:

- abstract types require knowing the leaves. We could use the existing
  machinery to map them.
- many c# types implement multiple interfaces; we need support for
  multiple inheritance at the non-proxy model level.
- we need a way to mark a type as abstract so that we don't attempt to
  instantiate it.
- at present we do not support inheritance from generic types, so we
  need to update yarn for this in order to support generic collections
  properly. This should be doable by making the parents a name tree
  rather than a name. Validator will ensure only non-proxy models use
  generic inheritance. In addition, when generating helpers for
  abstract classes, we need to take into account additional generic
  parameters supplied by the leaves. For example:

: IDictionary<K, V> : ICollection<KeyValuePair<K, V>>

  when we generate the helper for =ICollection<T>=, it must take into
  account the =KeyValuePair<K, V>= when it tries to instantiate a
  dictionary. In fact, it should probably just ignore it since we only
  have =T= and we need =K= and =V=. So for =ICollection<T>=, only
  descendants with a single type parameter should be leaf
  candidates. However, if the user supplies:

: ICollection<KeyValuePair<K, V>>

  then we should consider =Dictionary<K, V>= as a leaf. This is quite
  tricky. We need to navigate the name tree to figure out what
  matches.
- for collection IO we probably just need a method in the assistant
  that loops through the =IEnumerable=, plus the usual assistant
  machinery.
- For test data and IO we have a problem: given a type presented as an
  =object=, we cannot statically determine what generators/dumpers to
  use. Thus for non-generic collections, we cannot dump its
  contents. We have several possible solutions for this: a) create a
  needle library, add the appropriate interfaces and a registrar, add
  a dependency on the model. Downside is the models are no longer
  self-contained. b) use castle - but its still not clear how
  cross-model dependencies would work c) leave as is; anything
  presented as an object will be dumped using the opaque object
  dumper. d) mix-and-match: support dynamic dumper resolution, but
  only within the current model. This should solve most of the
  use cases. We could also extend it to look up on any dependant
  models.

Approach:

- first we add support for all non-generic collections. This should
  require no changes at all to the meta-model. It will prove the
  helpers work correctly.
- then we update the meta-model to have parent and original parent as
  name trees (with validation to ensure only non-proxy models).
- then we add support for trivial cases of generic collections such as
  =List<T>=.
- finally we handle dictionaries. The solution is to ignore
  dictionaries on the =ICollection<KeyValuePair<K, V>>= scenario. We
  basically filter out all leaves that require more than one type
  parameter. As a result we end up creating a
  =List<KeyValuePair<K, V>>= etc. This means we will add name trees as
  parents purely to ensure we express the inheritance relationship
  correctly but not actually make use of it. It will lay the ground
  work to add generics in the future. We need to update the story in
  the backlog to reflect these changes.

Other notes:

- removed unused helper families:

:         "quilt.csharp.helper.family": "Number",
:         "quilt.csharp.helper.family": "Character",
:         "quilt.csharp.helper.family": "Boolean",
:         "quilt.csharp.helper.family": "Object",
:         "quilt.csharp.helper.family": "String",
:         "quilt.csharp.helper.family": "Number",

Links:

- [[https://msdn.microsoft.com/en-us/library/0ytkdh4s(v%3Dvs.110).aspx][Commonly Used Collection Types]]

**** Create an inheritance graph of the main collections

System.Collections:

: IEnumerable
: ICollection: IEnumerable
: IList : ICollection, IEnumerable
: ArrayList : IList, ICollection, IEnumerable
: IDictionary : ICollection
: Hashtable : IDictionary, ICollection, IEnumerable
: DictionaryEntry
: HybridDictionary : IDictionary, ICollection, IEnumerable (System.Collections.Specialized)
: IOrderedDictionary : IDictionary, ICollection, IEnumerable (System.Collections.Specialized)
: NameValueCollection NameObjectCollectionBase (System.Collections.Specialized)
:    ICollection, IEnumerable
: BitArray : ICollection, IEnumerable
: Queue : ICollection, IEnumerable
: SortedList : IDictionary, ICollection, IEnumerable
: Stack : ICollection, IEnumerable

https://msdn.microsoft.com/en-us/library/system.collections.specialized.namevaluecollection(v=vs.110).aspx

System.Collections.ObjectModel:

: Collection<T> : IList<T>, ICollection<T>, IEnumerable<T>,
:                 IEnumerable, IList, ICollection, IReadOnlyList<T>,
:                 IReadOnlyCollection<T>
: KeyedCollection<TKey, TItem> : Collection<TItem>

System.Collections.Generic:

: KeyValuePair<TKey, TValue> (structure)
: IEnumerable<out T> : IEnumerable
: ICollection<T> : IEnumerable<T>, IEnumerable
: IList<T> : ICollection<T>, IEnumerable<T>, IEnumerable
: IReadOnlyCollection<out T> : IEnumerable<T>, IEnumerable
: IReadOnlyList<out T> : IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable
: IReadOnlyDictionary<K, V>: IReadOnlyDictionary<K, V> :
:                            IReadOnlyCollection<KeyValuePair<K, V>>,
:                            IEnumerable<KeyValuePair<K, V>>, IEnumerable
: ISet<T> : ICollection<T>, IEnumerable<T>, IEnumerable
: HashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable,  ISet<T>,
:              IReadOnlyCollection<T>
: List<T> : IList<T>, ICollection<T>, IEnumerable<T>,  IEnumerable, IList,
:           ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>
:           -> IList<T>, IReadOnlyList<T>
: Queue<T> : IEnumerable<T>, IEnumerable, ICollection, IReadOnlyCollection<T>
: HashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ISet<T>,
:              IReadOnlyCollection<T>
: IDictionary<K, V> : ICollection<KeyValuePair<K, V>>,
:                     IEnumerable<KeyValuePair<K, V>>, IEnumerable
: Dictionary<K, V> : IDictionary<K, V>, ICollection<KeyValuePair<K, V>>,
:                    IEnumerable<KeyValuePair<K, V>>, IEnumerable, IDictionary,
:                    ICollection, IReadOnlyDictionary<K, V>,
:                    IReadOnlyCollection<KeyValuePair<K, V>>
: SortedDictionary<K, V> : IDictionary<K, V>,
:                          ICollection<KeyValuePair<K, V>>,
:                          IEnumerable<KeyValuePair<K, V>>,
:                          IEnumerable, IDictionary, ICollection,
:                          IReadOnlyDictionary<K, V>,
:                          IReadOnlyCollection<KeyValuePair<K, V>>
: SortedList<K, V> : IDictionary<K, V>, ICollection<KeyValuePair<K, V>>,
:                    IEnumerable<KeyValuePair<K, V>>, IEnumerable, IDictionary,
:                    ICollection, IReadOnlyDictionary<K, V>,
:                    IReadOnlyCollection<KeyValuePair<K, V>>
: SortedSet<T> : ISet<T>, ICollection<T>, IEnumerable<T>, IEnumerable,
:                ICollection, IReadOnlyCollection<T>
: KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem>
: LinkedList<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ICollection,
:                 IReadOnlyCollection<T>
: Stack<T> : IEnumerable<T>, IEnumerable, ICollection, IReadOnlyCollection<T>
: SynchronizedCollection<T> : IList<T>, ICollection<T>, IEnumerable<T>,
:                             IEnumerable, IList, ICollection
: SynchronizedKeyedCollection<K, T> : SynchronizedCollection<T>
: SynchronizedReadOnlyCollection<T> : IList<T>, ICollection<T>, IEnumerable<T>,
:                                     IEnumerable, IList, ICollection

System.Collections.Immutable:

: IImmutableList<T> : IReadOnlyList<T>,  IReadOnlyCollection<T>, IEnumerable<T>,
:                     IEnumerable
: ImmutableList<T>: IImmutableList<T>,  IList<T>, ICollection<T>, IList,
:                   ICollection,, IReadOnlyList<T>,  IReadOnlyCollection<T>,
:                   IEnumerable<T>, IEnumerable
: IImmutableQueue<T> : IEnumerable<T>, IEnumerable
: ImmutableQueue<T> : IImmutableQueue<T>, IEnumerable<T>,  IEnumerable
: IImmutableStack<T> : IEnumerable<T>, IEnumerable
: ImmutableStack<T> : IImmutableStack<T>, IEnumerable<T>,  IEnumerable
: IImmutableDictionary<K, V> : IReadOnlyDictionary<K, V>,
:                              IReadOnlyCollection<KeyValuePair<K, V>>,
:                              IEnumerable<KeyValuePair<K, V>>, IEnumerable
: ImmutableDictionary<K, V> : IImmutableDictionary<K, V>,
:                             IReadOnlyDictionary<K, V>,
:                             IReadOnlyCollection<KeyValuePair<K, V>>,
:                             IDictionary<K, V>, ICollection<KeyValuePair<K, V>>,
:                             IEnumerable<KeyValuePair<K, V>>, IDictionary
:                             ICollection, IEnumerable
: ImmutableSortedDictionary<K, V> : IImmutableDictionary<K, V>,
:                                   IReadOnlyDictionary<K, V>,
:                                   IReadOnlyCollection<KeyValuePair<K, V>>,
:                                   IDictionary<K, V>,
:                                   ICollection<KeyValuePair<K, V>>,
:                                   IEnumerable<KeyValuePair<K, V>>,
:                                   IDictionary, ICollection, IEnumerable
: IImmutableSet<T> : IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable
: ImmutableSortedSet<T> : IImmutableSet<T>,  IReadOnlyList<T>,
:                         IReadOnlyCollection<T>, IList<T>, ISet<T>,
:                         ICollection<T>, IEnumerable<T>, IList, ICollection,
:                          IEnumerable
: ImmutableHashSet<T> : IImmutableSet<T>, IReadOnlyCollection<T>,
:                       ISet<T>, ICollection<T>, IEnumerable<T>, ICollection,
:                       IEnumerable

System.Collections.Concurrent

*** COMPLETED Add support for object based container types in C#      :story:
    CLOSED: [2017-01-07 Sat 13:44]
    CLOCK: [2017-01-07 Sat 13:30]--[2017-01-07 Sat 13:40] =>  0:10
    CLOCK: [2017-01-07 Sat 13:24]--[2017-01-07 Sat 13:29] =>  0:05
    CLOCK: [2017-01-07 Sat 13:12]--[2017-01-07 Sat 13:23] =>  0:11
    CLOCK: [2017-01-07 Sat 12:58]--[2017-01-07 Sat 13:11] =>  0:13
    CLOCK: [2017-01-07 Sat 12:30]--[2017-01-07 Sat 12:57] =>  0:27
    CLOCK: [2017-01-07 Sat 11:02]--[2017-01-07 Sat 11:57] =>  0:55
    CLOCK: [2017-01-06 Fri 22:01]--[2017-01-06 Fri 23:27] =>  1:26
    CLOCK: [2017-01-06 Fri 17:52]--[2017-01-06 Fri 18:05] =>  0:13
    CLOCK: [2017-01-06 Fri 17:37]--[2017-01-06 Fri 17:51] =>  0:14
    CLOCK: [2017-01-06 Fri 17:32]--[2017-01-06 Fri 17:36] =>  0:04
    CLOCK: [2017-01-06 Fri 16:40]--[2017-01-06 Fri 17:32] =>  0:52
    CLOCK: [2017-01-05 Thu 14:01]--[2017-01-05 Thu 14:53] =>  0:52
    CLOCK: [2017-01-05 Thu 12:26]--[2017-01-05 Thu 12:30] =>  0:04
    CLOCK: [2017-01-05 Thu 12:23]--[2017-01-05 Thu 12:25] =>  0:02

Add all the main object based containers and perform all the required
changes to the framework in order to support them. Add also the
interfaces.

: IEnumerable
: ICollection
: IList
: IDictionary
: ArrayList
: Queue
: Stack
: Hashtable
: SortedList

*Skipped collections and types*

- =IOrderedDictionary=: no implementations in framework. This means
  generators will not work.
- =DictionaryEntry=: no use case.

*** COMPLETED Understand the behaviour of helpers and assistants      :story:
    CLOSED: [2017-01-08 Sun 10:24]
    CLOCK: [2017-01-08 Sun 09:49]--[2017-01-08 Sun 10:24] =>  0:35
    CLOCK: [2017-01-08 Sun 09:02]--[2017-01-08 Sun 09:40] =>  0:38

Notes:

- the difference in implementation between C++ and C# is that we
  always call the helpers in C++, and the decision on whether to call
  another helper or to use the class generator is made within the
  helper. Helpers already contain all the information required to make
  this decision (helper descriptor etc). In C# we are trying to decide
  whether to call the assistant, or the class sequence generator or
  the helper.
- in types we are using helpers via the aspect properties: if a type
  is floating point, we call the helper. Separately, we use the usual
  helper binding mechanism to generate the helper. For assistants we
  have taken a different approach: if the type requires an assistant,
  via the assistant properties, we call the assistant across the board
  on all facets which have assistants (test data and io). This works
  so far because we do not have assistants in types, so any clashes
  between is floating point and requires assistant are not causing
  issues.
- seems like a clear pattern is emerging. Use cases:
  - template itself is sufficient to handle the case - e.g. baseline
    case for most types;
  - type dependent behaviour but still handled within the template -
    i.e. we need some switch, but the code is self-contained at one
    point.
  - type dependent behaviour that requires calling "external" code -
    i.e. the assistant. The calling code is "manually" generated. C#
    only at present.
  - type dependent behaviour that requires generating additional
    code - i.e. helpers. The calling code is "automatically" generated
    based on the types.
- all of the above is associated with a property.
- in addition to this, we then have the helper properties, which are
  associated with an element. These are basically the other side of
  use case four: the automatically generated code used by the calling
  code. We may have n instances of calling code, but only one helper
  (say if we have n properties of =std::vector<std::string>=).
- in c++ we go a step further and add configuration of the helper
  itself: streaming properties, requires hashing helper and so forth.
- why do we make a distinction between helpers/assistants and say
  =requires_manual_default_constructor=? Mainly because these are at
  the element level? In addition, can we make these common across all
  languages?
- note that the behaviour of helpers is "homogeneous": we either do
  not need helpers or if we do, all helpers provide the same
  "functionality" but for different type parameters. E.g. it is never
  the case (up to now) that we have one type that needs two different
  helpers for two distinct purposes. This may be a consequence of
  having facets.
- note also that we cannot simply have a string with a method name to
  call (which could either be the assistant, the helper or
  nothing). This is because the function prototype is not always the
  same. But we could possibly enforce this though, at least given the
  current use cases.
- the assistant is mapped to a type rather than an attribute. We just
  check to see if the attribute's type is in the assistant properties
  map.

Conclusions:

- some future taxonomy work is required to clean up these
  concepts. This can be done as we move code from the kernels into
  quilt.
- add the concept of "auxiliary function". This is a string that is
  set to either nothing, the helper invocation or the assistant
  invocation. There is a map of attribute id to "auxiliary
  function". Whenever we are processing an attribute we request its
  auxiliary function first.

*** CANCELLED Add support for generic parents in yarn                 :story:
    CLOSED: [2017-01-08 Sun 10:24]
    CLOCK: [2017-01-07 Sat 15:01]--[2017-01-07 Sat 15:36] =>  0:35

*Rationale*: its not clear this is required at present. If so we can
always revisit. This story should be tidied up and moved to product
backlog.

At present in yarn a parent can only be a name. This means that if we
have a parent with type parameters, we cannot capture the value of the
type parameter in the inheritance relationship. For example, say the
parent is =std::vector<my_type>=. This is of course not a good idea as
STL containers were not designed for inheritance but one can imagine
the exact same approach with user types (were dogen to support the
generation of generic types). Yarn would see only =std::vector=.

We should be able to "trivially" extend yarn to cope with this though,
by making parents and original parents name trees.

Actually it is not entirely clear we need to do this. The core problem
we are trying to solve is: if the user creates an =IList<T>=, we just
need to iterate through the leaves of =IList= which have the same
number of type parameters. So in this case =Dictionary<K, V>= would
not be considered.

We should attempt to implement generic collections with the existing
yarn infrastructure first and see where/if it breaks.

*** COMPLETED Fix assorted windows warnings                           :story:
    CLOSED: [2017-01-10 Tue 16:30]
    CLOCK: [2017-01-10 Tue 16:11]--[2017-01-10 Tue 16:30] =>  0:19

There are a number of easy-to-fix windows warnings which we should get
out of the way.

*** COMPLETED Build dogen on windows locally                          :story:
    CLOSED: [2017-01-10 Tue 16:30]
    CLOCK: [2017-01-10 Tue 09:27]--[2017-01-10 Tue 12:00] =>  2:33
    CLOCK: [2017-01-09 Mon 14:01]--[2017-01-09 Mon 19:00] =>  4:59

At present we are building on AppVeyor and that works well
enough. However, in order to fix the errors we are getting in AppVeyor
we need to build locally on windows. This may not be quite so trivial
due to proxy, etc.

*** COMPLETED Fix borked windows build                                :story:
    CLOSED: [2017-01-10 Tue 21:34]
    CLOCK: [2017-01-11 Wed 08:52]--[2017-01-11 Wed 10:07] =>  1:15
    CLOCK: [2017-01-10 Tue 20:55]--[2017-01-10 Tue 21:34] =>  0:39

It seems that conan does not support static runtimes for boost or
libxml. We need to use our build of boost instead.

*** COMPLETED Windows build debug failures                             :epic:
    CLOSED: [2017-01-10 Tue 21:35]

*Rationale*: the changes around runtimes should fix this problem.

The windows debug build fails to link with the following errors:

: C:\projects\dogen\build\output\projects\config\tests\config.tests.vcxproj" (default target) (14) ->
: (Link target) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\config\tests\config.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\dia\tests\dia.tests.vcxproj" (default target) (17) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\dia\tests\dia.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\dynamic\tests\dynamic.tests.vcxproj" (default target) (21) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\dynamic\tests\dynamic.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\formatters\tests\formatters.tests.vcxproj" (default target) (29) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\formatters\tests\formatters.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\knit\tests\knit.tests.vcxproj" (default target) (36) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\knit\tests\knit.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\knitter\src\knitter.vcxproj" (default target) (37) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\knitter\src\knitter.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\knitter\tests\knitter.tests.vcxproj" (default target) (38) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\knitter\tests\knitter.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\quilt.cpp\tests\quilt.cpp.tests.vcxproj" (default target) (39) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\quilt.cpp\tests\quilt.cpp.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\quilt\tests\quilt.tests.vcxproj" (default target) (40) ->
:   libboost_log-vc140-mt-gd-1_60.lib(default_attribute_names.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\quilt\tests\quilt.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\test_models\seam\tests\seam.tests.vcxproj" (default target) (41) ->
:   libboost_log-vc140-mt-gd-1_60.lib(core.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\test_models\seam\tests\seam.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\stitch\tests\stitch.tests.vcxproj" (default target) (46) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\stitch\tests\stitch.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\stitcher\src\stitcher.vcxproj" (default target) (47) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\stitcher\src\stitcher.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\stitcher\tests\stitcher.tests.vcxproj" (default target) (48) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\stitcher\tests\stitcher.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\test_models\test_model_sanitizer\tests\test_model_sanitizer.tests.vcxproj" (default target) (49) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\test_models\test_model_sanitizer\tests\test_model_sanitizer.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\utility\tests\utility.tests.vcxproj" (default target) (53) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\utility\tests\utility.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\yarn.dia\tests\yarn.dia.tests.vcxproj" (default target) (54) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\yarn.dia\tests\yarn.dia.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\yarn.json\tests\yarn.json.tests.vcxproj" (default target) (55) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\yarn.json\tests\yarn.json.tests.vcxproj]
: "C:\projects\dogen\build\output\ALL_BUILD.vcxproj" (default target) (1) ->
: "C:\projects\dogen\build\output\projects\yarn\tests\yarn.tests.vcxproj" (default target) (56) ->
:   libboost_log-vc140-mt-gd-1_60.lib(unhandled_exception_count.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' [C:\projects\dogen\build\output\projects\yarn\tests\yarn.tests.vcxproj]
:     910 Warning(s)
:     18 Error(s)

This appears to be a mixing of 32-bit and 64-bit settings somewhere in
the boost tests, according to SO:

[[http://stackoverflow.com/questions/3563756/fatal-error-lnk1112-module-machine-type-x64-conflicts-with-target-machine-typ][fatal error LNK1112: module machine type 'x64' conflicts with target
machine type 'X86']]

Debug build is back down to =knit= target again.

*** COMPLETED Generate windows packages with WIX                      :story:
    CLOSED: [2017-01-11 Wed 16:22]
    CLOCK: [2017-01-11 Wed 10:08]--[2017-01-11 Wed 10:52] =>  0:44
    CLOCK: [2017-01-10 Tue 14:00]--[2017-01-10 Tue 15:09] =>  1:09
    CLOCK: [2017-01-10 Tue 12:00]--[2017-01-10 Tue 13:35] =>  1:35

It seems NSIS is no longer considered the right way of building
windows installers. One should instead use WIX. Add support for WIX.

*** COMPLETED Add validation around instatitation of abstract classes :story:
    CLOSED: [2017-01-11 Wed 21:09]
    CLOCK: [2017-01-11 Wed 22:48]--[2017-01-11 Wed 23:25] =>  0:37
    CLOCK: [2017-01-11 Wed 21:10]--[2017-01-11 Wed 21:16] =>  0:06
    CLOCK: [2017-01-11 Wed 20:25]--[2017-01-11 Wed 21:09] =>  0:44
    CLOCK: [2017-01-11 Wed 19:53]--[2017-01-11 Wed 20:24] =>  0:31
    CLOCK: [2017-01-11 Wed 19:25]--[2017-01-11 Wed 19:52] =>  0:27

At present dogen allows one to create variables of an abstract
class. We should have a validation rule to stop this.

Rule:

- Issue error when a property is a value of an abstract class: yarn
  should fail to merge if the user attempts to create a property of a
  base class. It should allow pointers to the base class though (raw,
  shared pointers, boost optional etc).

*** COMPLETED Add validation to ensure enumerators do not have types  :story:
    CLOSED: [2017-01-11 Wed 22:48]
    CLOCK: [2017-01-11 Wed 22:26]--[2017-01-11 Wed 22:47] =>  0:21

In =upsilon= we set an object's type to enumeration by mistake. It
resulted in an enumeration. The error should have been picked up by
noticing the enumerators had a type. Add a validation error for this.

*** COMPLETED Add appveyor support for bintray                        :story:
    CLOSED: [2017-01-12 Thu 11:38]
    CLOCK: [2017-01-12 Thu 11:18]--[2017-01-12 Thu 11:38] =>  0:20
    CLOCK: [2017-01-12 Thu 11:02]--[2017-01-12 Thu 11:17] =>  0:15
    CLOCK: [2017-01-12 Thu 09:10]--[2017-01-12 Thu 09:43] =>  0:33
    CLOCK: [2017-01-11 Wed 22:10]--[2017-01-11 Wed 22:25] =>  0:15
    CLOCK: [2017-01-10 Tue 15:10]--[2017-01-10 Tue 16:10] =>  1:00

It seems appveyor also supports bintray:

[[https://www.appveyor.com/docs/deployment/bintray/][Deploying to Bintray]]

We need to change our targets to generate the MSI, and then try to
deploy it over to bintray.

Sample:

: deploy:
: - provider: BinTray
:   username: johnsmith
:   api_key:
:     secure: AABBCC+DDD==
:   subject: johnsmith
:   repo: myrepo
:   package: mypackage
:   version: version
:   publish: true
:   override: true
:   explode: true

  on:
    branch: master                 # release from master branch only
    appveyor_repo_tag: true

Errors:

: Deploying using BinTray provider
: Uploading "dogen-0.95.0-Windows-AMD64.msi" to BinTray as domaindrivenconsulting/Dogen/Dogen/0.94.0/dogen-0.95.0-Windows-AMD64.msi...Error uploading artifact to BinTray (401 status): This resource requires authentication

*** STARTED Add upsilon support                                       :story:
    CLOCK: [2017-01-12 Thu 14:33]--[2017-01-12 Thu 14:43] =>  0:10
    CLOCK: [2017-01-12 Thu 14:30]--[2017-01-12 Thu 14:32] =>  0:02
    CLOCK: [2017-01-12 Thu 14:02]--[2017-01-12 Thu 14:29] =>  0:27
    CLOCK: [2017-01-12 Thu 12:29]--[2017-01-12 Thu 12:49] =>  0:20
    CLOCK: [2017-01-12 Thu 11:39]--[2017-01-12 Thu 12:28] =>  0:49
    CLOCK: [2017-01-12 Thu 10:22]--[2017-01-12 Thu 11:01] =>  0:39
    CLOCK: [2017-01-12 Thu 10:17]--[2017-01-12 Thu 10:21] =>  0:04
    CLOCK: [2017-01-12 Thu 10:05]--[2017-01-12 Thu 10:16] =>  0:11
    CLOCK: [2017-01-12 Thu 09:44]--[2017-01-12 Thu 10:04] =>  0:20
    CLOCK: [2017-01-11 Wed 21:28]--[2017-01-11 Wed 21:46] =>  0:18
    CLOCK: [2017-01-11 Wed 21:17]--[2017-01-11 Wed 21:28] =>  0:11
    CLOCK: [2017-01-11 Wed 18:16]--[2017-01-11 Wed 18:32] =>  0:16
    CLOCK: [2017-01-11 Wed 17:35]--[2017-01-11 Wed 18:15] =>  0:40
    CLOCK: [2017-01-11 Wed 16:05]--[2017-01-11 Wed 17:17] =>  1:12

A customer has models in a legacy format, which need to be imported
into Dogen. The easiest thing to do is to create a simple frontend
which imports these models into yarn. We will subsequently have to
map these types into native types, depending on the language - or
probably into LAM types.

*** STARTED Add auxiliary function properties to c#                   :story:
    CLOCK: [2017-01-08 Sun 11:27]--[2017-01-08 Sun 11:40] =>  0:13
    CLOCK: [2017-01-08 Sun 10:56]--[2017-01-08 Sun 11:26] =>  0:30
    CLOCK: [2017-01-08 Sun 10:50]--[2017-01-08 Sun 10:55] =>  0:05
    CLOCK: [2017-01-08 Sun 10:37]--[2017-01-08 Sun 10:49] =>  0:12
    CLOCK: [2017-01-08 Sun 10:28]--[2017-01-08 Sun 10:37] =>  0:09
    CLOCK: [2017-01-08 Sun 10:25]--[2017-01-08 Sun 10:27] =>  0:02

We need to associate a function with an attribute and a
formatter. This could be the helper or the assistant (or nothing).

Actually this is not quite so straightforward. In =io= (c#) we have:

: assistant.Add("ByteProperty", value.ByteProperty, true/*withSeparator*/);

This is a bit of a problem because we now need to different
invocations, one for helper another for the assistant, which differ on
the function prototype. For the helper we need something like:

: Add(assistant, "ByteProperty", value.ByteProperty, true/*withSeparator*/);

So a string is no longer sufficient. Maybe we could have a struct with
auxiliary function properties:

- auxiliary function types = enum with { assistant, helper }
- auxiliary function name = string

So we can have a map of attribute id to map of formatter id to
auxiliary function properties.

Actually we should also create "attribute properties" as a top-level
container so that in the future we can latch on other attribute level
properties.

*** STARTED Add internal object dumper resolution                     :story:
    CLOCK: [2017-01-06 Fri 11:10]--[2017-01-06 Fri 12:55] =>  1:45
    CLOCK: [2017-01-05 Thu 17:38]--[2017-01-05 Thu 18:01] =>  0:23
    CLOCK: [2017-01-05 Thu 14:54]--[2017-01-05 Thu 17:37] =>  2:43

We should try to resolve an object to a local dumper, if one exists;
for all model types and primitives. Add a registrar for local dumpers.

: using System;
: using System.Collections.Generic;
:
: namespace Dogen.TestModels.CSharpModel
: {
:     static public class DynamicDumperRegistrar
:     {
:         public interface IDynamicDumper
:         {
:             void Dump(AssistantDumper assistant, object value);
:         }
:
:         static private IDictionary<Type, IDynamicDumper> _dumpers = new Dictionary<Type, IDynamicDumper>();
:
:         static void RegisterDumper(Type type, IDynamicDumper dumper)
:         {
:         }
:     }
: }

*** STARTED Add support for generic container types to C#             :story:
    CLOCK: [2017-01-07 Sat 20:43]--[2017-01-07 Sat 21:08] =>  0:25
    CLOCK: [2017-01-07 Sat 18:05]--[2017-01-07 Sat 18:56] =>  0:51

We should add all major container types and tests for them.

: IEnumerable<T>
: ICollection<T>
: IList<T>
: IDictionary<K, V>
: List<T>
: ConcurrentQueue<T>, ConcurrentStack<T>, LinkedList<T>
: Dictionary<TKey, TValue>
: SortedList<TKey, TValue>
: ConcurrentDictionary<TKey, TValue>
: KeyedCollection<TKey, TItem>

Notes:

- we need a way to determine if we are using a helper, the assistant
  or a sequence generator directly.

*** Fix issues with bintray windows uploads                           :story:

At present we are doing a lot of hacks for windows:

- hardcoding the path to the package
- not uploading on just tags
- uploading to the top-level folder instead of the version.

Ideally we want to reuse the Travis BinTray descriptor but AppVeyor
does not support this directly.

*** Model references are not transitive                               :story:

For some reason we do not seem to be following references of
referenced models. We should load them automatically, now that they
are part of the meta-data. However, the =yarn.json= model breaks when
we remove the reference to annotation even though it does not use this
model directly and =yarn= is referencing it correctly.

*** Add support for boxed types                                       :story:

At present we support built-in types such as =int= but not
=System.Integer=. In theory we should be able to add these types with:

:        "quilt.csharp.assistant.requires_assistance": true,
:        "quilt.csharp.assistant.method_postfix": "ShortByte"

And they should behave just like built-ins.

*** Add handcrafted class to C# test model                            :story:

We should make sure handcrafted code works in C#.

Actually in order to get handcrafted types to work we need support for
enablement. This is a somewhat tricky feature so we should leave it
for after all the main ones are done.

*** Add support for arrays                                            :story:

At present the yarn parser does not support array notation:
=string[]=. We need to look into how arrays would work for C++ and
implement it in a compatible way.

Links:

- [[https://www.dotnetperls.com/array][array]]

*** Add fluency support for C#                                        :story:

We need to add fluent support for C#.

C# properties are not compatible with the fluent pattern. Instead, one
needs to create builders, across the inheritance tree.

Links:

- [[http://stackoverflow.com/questions/13761666/how-to-use-fluent-style-syntactic-sugar-with-c-sharp-property-declaration][How to use Fluent style syntactic sugar with c# property declaration]]

*** Add visitor support to C#                                         :story:

Implement the visitor formatters for C#.

*** Benchmarks do not work for utility tests                          :story:

When we run the benchmarks for utility we get an error:

: Running 95 test cases...
: /home/marco/Development/DomainDrivenConsulting/dogen/projects/utility/tests/asserter_tests.cpp(141): error: in "asserter_tests/assert_directory_good_data_set_returns_true": check asserter::assert_directory(e, a) has failed

Seems like the tests do not clean up after themselves. We need to add
some clean up logic and re-enable the tests.

*** Add cross-model support to C#                                     :story:

At present we do not have any tests that prove that cross-model
support is working (other than proxy models). We need to create a user
level model that makes use of types from another model. In theory it
should just work since we are using fully qualified names everywhere.

*** Generate AssemblyInfo in C#                                       :story:

We need to inject a type for this in fabric. For now we can leave it
mainly blank but in the future we need to have meta-data in yarn for
all of its properties:

: [assembly: AssemblyTitle ("TestDogen")]
: [assembly: AssemblyDescription ("")]
: [assembly: AssemblyConfiguration ("")]
: [assembly: AssemblyCompany ("")]
: [assembly: AssemblyProduct ("")]
: [assembly: AssemblyCopyright ("marco")]
: [assembly: AssemblyTrademark ("")]
: [assembly: AssemblyCulture ("")]
: [assembly: AssemblyVersion ("1.0.*")]

These appear to just be properties at the model level.

*** Consider adding a clone method for C#                             :story:

It would be nice to have a way to clone a object graph. We probably
have an equivalent story for this for C++ in the backlog.

*** Consider making the output directory configurable in C#           :story:

At present we are outputting binaries into the =bin= directory,
locally on the project directory. However, it would make more sense to
output to =build/output= like C++ does. For this to work, we need to
be able to supply an output directory as meta-data.

*** Add support for nuget                                             :story:

A proxy model may require obtaining a nuget package. Users should be
able to define a proxy model as requiring a nuget package and then
Dogen should generate packages.config and add all such models to it.

: +  <package id="NUnit" version="2.6.4" targetFramework="net45" />

*** Augment element ID with meta-model type                           :story:

The element ID is considered to be a system-level, opaque
identifier. It could, for all intents and purposes, be a large int. We
have decided to use a string so we can dump it to the log and figure
out what is going on without having to map IDs to a human-readable
value. In the same vein, we could also add another component to the ID
that would contain the meta-model element for that ID. This
information could be placed at the start.

Of course, we will not be able to remove the look-ups we have at
present that try to figure out the meta-model element because they are
related to resolution. But for any other cases it may result in
slightly more performant code. We need to look at all the use cases.

*** Identifiable needs to use camel case in C#                        :story:

At present we are building identifiables with underscores.

*** Generate windows packages with CPack                              :story:

We tried to generate windows packages by using the NSIS tool, but
there are no binaries available for it at present. However, it seems
CPack can now generate MSIs directly:

- [[http://stackoverflow.com/questions/18437356/how-to-generate-msi-installer-with-cmake][How to generate .msi installer with cmake?]]
- [[https://cmake.org/cmake/help/v3.0/module/CPackWIX.html][CPackWIX]]

We need to investigate how to get the build to produce MSIs using WIX.

*** Move enablement into quilt                                        :story:

We need to make use of the exact same logic as implemented in
=quilt.cpp= for enablement. Perhaps all of the enablement related
functionality can be lifted and grafted onto quilt without any major
changes.

*** Add feature to disable regions                                    :story:

We need a way to stop outputting regions if the user does not want
them.

*** Add parameters for using imported assemblies                      :story:

Assemblies imported via proxy models need to have the ability to
supply two parameters:

- assembly name: this is not always the same as the proxy model name;
- root namespace: similarly this may differ from the proxy model name.

These should be supplied as meta data and used when constructing
fabric types.

*** Add msbuild target for C# test model                              :story:

Once we are generating solutions, we should detect msbuild (or xbuild)
and build the solution. This should be a CMake target that runs on
Travis.

*** Add visibility to yarn elements                                   :story:

We need to be able to mark yarn types as:

- public
- internal

This can then be used by C++ as well for visibility etc.

*** Add partial element support to yarn                               :story:

We need to be able to mark yarn elements as "partial". It is then up
to programming languages to map this to a language feature. At present
only [[https://msdn.microsoft.com/en-us/library/wa80x488.aspx][C# would do so]].

It would be nice to have a more meaningful name at yarn
level. However, seems like this is a fairly general programming
concept now: [[https://en.wikipedia.org/wiki/Class_(computer_programming)#Partial][wikipedia]].

*** Add visibility to yarn attributes                                 :story:

We need to be able to mark yarn attributes as:

- public
- private
- protected

*** Add final support in C#                                           :story:

Links:

- [[https://msdn.microsoft.com/en-us/library/88c54tsw.aspx][sealed (C# Reference)]]

*** Add aspects for C# serialisation support                          :story:

We need to add serialisation support:

- C# serialisation
- Data Contract serialisation
- Json serialisation

In C# these are done via attributes so we do not need additional
facets. We will need a lot of configuration knobs though:

- ability to switch a serialisation method on at model level or
  element level.
- support for serialisation specific arguments such as parameters for
  Json.Net.

Links:

- [[https://msdn.microsoft.com/en-us/library/ms731923(v%3Dvs.110).aspx][Types Supported by the Data Contract Serializer]]
- [[https://msdn.microsoft.com/en-us/library/ms731073(v%3Dvs.110).aspx][Serialization and Deserialization]]
- [[https://msdn.microsoft.com/en-us/library/ms733127(v%3Dvs.110).aspx][Using Data Contracts]]
- [[https://msdn.microsoft.com/en-us/library/ms731923(v%3Dvs.110).aspx][Types Supported by the Data Contract Serializer]]

*** Consider adding =artefact_set= to formatters' model               :story:

We are using collections of artefacts quite a bit, and it makes sense
to create an abstraction for it such as a =artefact_set=. However, for
this to work properly we need to add at least one basic behaviour: the
ability to merge two artefact sets. Or else we will end up having to
unpack the artefacts, then merging them, then creating a new artefact
set.

Problem is, we either create the artefact set as a non-generatable
type - not ideal - or we create it as generatable and need to add this
as a free function. We need to wait until dogen has support for
merging code generation.

** Deprecated
